<meta charset="utf-8">
<meta name="viewport" id="preventAutomaticZoom">
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<p id="imageSettings">
<input type="text" value="4" id="anzahl" onchange="anzahlVerschieben.value = value*value" placeholder="Puzzle Teile je x und y achse">
<br>
<input type="file" onchange="readImg(this);">
<br>
<input type="text" placeholder="URL" id="sourceURL">
<button type="button" onclick="useURL();" name="button">use</button>
<br>
<input id="sourceIsPicture" checked="true" name="mediaType" type="radio">picture
<input id="sourceIsVideo" name="mediaType" type="radio">video
<br>
<input type="range" width="window.innerWidth" oninput="zeigeGröße();" placeholder="Pixelanzahl x achse" id="größeAnpassenX"> Breite des Bildes
<br>
<input type="range" width="window.innerHeight"  max="window.innerHeight" onInput="zeigeGröße();" placeholder="Pixelanzahl y achse" id="größeAnpassenY"> Höhe des Bildes
<br>
<button type="button" onclick="zuBildschirmgröße();" name="button">Größe auf Bildschirmgröße anpassen</button>
<button type="button" onclick="zuAngepassterBildschirmgröße();" name="button">Größenverhältnis angleichen</button>
<button type="button" onclick="zuOptimalerBildschirmgröße();" name="button">Größenverhältnis optimieren</button>
<br>
<button type="button" onclick="create();" name="button">create puzzle</button>
</p>
<button type="button" id="showSettings" onclick="if (settings.style.display == 'none') settings.style.display = 'inline'; else settings.style.display = 'none'" name="button">mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)</button>
<!-- <button type="button" onclick="buttonStateChanged('rightRotation')" id="rightRotationB" style="position: fixed; left:483px;" name="button">drehe rechts</button>
<button type="button" onclick="buttonStateChanged('leftRotation');" id="leftRotationB" style="position: fixed;" name="button">drehe links</button>
<button type="button" onclick="buttonStateChanged('scrollable');" id="scrollableB" style="position: fixed; left: 700px" name="button">scrollable</button> -->
<p2 style="position: fixed; top: -7px; left: 377px; background-color: rgba(205, 218, 199, 0.77); font-size: 55px; padding-bottom: 15px; border-radius: 5px;" id="mobileControls">
  <p id="rotateControls" style="display: none;">
    <input class="mobileControlsCheckbox" type="checkbox" oninput="rotatesRight.checked = false;" name="rotateB" id="rotatesLeft" name="button">drehe links
    <input class="mobileControlsCheckbox" type="checkbox" oninput="rotatesLeft.checked = false;" name="rotateB" id="rotatesRight"  name="button">drehe rechts
  </p>
    <input class="mobileControlsCheckbox" type="checkbox" id="scrollable" name="button">scroll
</p2>
<style>
  .mobileControlsCheckbox {
    width: 44;
    height: 44;
    top: 7px;
    position: relative;
  }
</style>
<div id="settings">
  <br>
  <br>
  <select onchange="modeSelected(value);" id="modeSelection">
    <option value="traditional">traditionell</option>
    <option value="exchange">austauschen</option>
    <option value="schieben">nur schieben</option>
  </select>
  <br>
  <div id="traditionalSettings">
    <p style="margin-bottom: 6px;" id="rotateTilesP">
    <input id="rotateTiles" checked="true" onchange="if (checked) screenIsMaxP.style.display = 'inline'; else screenIsMaxP.style.display = 'none';" type="checkbox"> drehe Teile
  </p>
    <p id="screenIsMaxP"><input id="screenIsMax" checked="true" type="checkbox"> maximum size of picture: screen size</p>
    <br>
    <input id="markWrong" type="checkbox" > markiere nicht passende
    <br>
    <p id="scrollOnBlancP" style="display: none;"><input id="scrollOnBlanc" type="checkbox"> scrollen auf leerem Hintergrund erlauben</p>
  </div>
  <div id="exchangeSettings">
  <p id="swipeSteuerungP"><input type="checkbox"  id="swipeSteuerung"> beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen</p>
  </div>
  <p id="schiebenSettings">
    <br>
    <strong style="font-size:15px;">mit der Anzahl der Schiebevorgänge, die der PC vornimmt, kann die Schwierigkeit am leichtesten kontrolliert werden</strong>
    <br>
    <input type="text" id="anzahlVerschieben" placeholder="Male PC verschieben">
    <br>
    <input type="checkbox" onchange="if (checked) {anzahlVerschieben.style.display = 'none'; innerHTML.replace('_', ''); } else {anzahlVerschieben.style.display = 'inline'; innerHTML += '__'}" id="richtigeCheck"> verschieben, bis höchstens<input type="text" style="width:25px;" id="anzahlRichtige" value="10"> an origineller Stelle
    <br>
    <input type="checkbox" id="zurrückVermeiden" onchange="if (checked) anzahlVerboten.style.display = 'inline'; else anzahlVerboten.style.display = 'none';" checked="true"> <font size="5">leeres Feld 2 Mal an selber Stelle verboten (einfacher, weil immer direkt nebeneinander)</font>
    <br>
    <input type="text" id="anzahlVerboten" value="3" placeholder="Male bevor verboten">
    <!-- <input type="checkbox" id="difficultSchieben"> niemals eine verschiebng rückgängig machen (schwierig, weil immer viel verändert wird) -->
  </p>
  <br>
  <br>
  <br>
  <input type="checkbox" onchange="layout(true); if (checked) rightMarkerSettings.style.display = 'inline'; else rightMarkerSettings.style.display = 'none';" id="richtigPlazierte" checked="true"> markiere richtig plazierte
  <!-- <h3>general</h3> -->
  <p id="rightMarkerSettings">
  <input type="range" step="0.01" value="1" oninput="layout(true);" min="0.01" max="1" id="rightMarkerRadius"> radius von Mitte (in %)
  <br>
  <input min="0.01" max="1" step="0.01" value="0.3" oninput="layout(true)" id="rightMarkerTransparence" type="range"> Transparenz (in %)
</p>
  <br>
  <input type="checkbox" id="raender" onchange="if (checked) randSettings.style.display = 'inline'; else randSettings.style.display = 'none'; if (preview.src != '') layout();"> <font size="5"> zeige Ränder</font>
  <p id="randSettings">
    <br>
    <input type="range" min="1" value="13" oninput="randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - value; layout();" id="breiteRand"> Breite des Randes
    <br>
    <input type="range" min="0" value="0" oninput="layout();" id="randPosition"> Position des Randes
  </p>
  <br>
  <!-- <input type="checkbox" onchange="if (checked == true) {schiebenSettings.style.display = 'inline'; swipeSteuerungP.style.display = 'none';} else {schiebenSettings.style.display = 'none'; swipeSteuerungP.style.display = 'inline';}" id="schieben"> <font size="5">nur schieben</font> -->
  <br>
  <input id="reloadWhenFinished" onchange="localStorage.setItem('reloadWhenFinished', checked)" type="checkbox">Lade die Seite automatisch neu, kurz nachdem das Puzzle fertig ist
  <br>
  <br>
  <button type="button" id="aufgebenId" onclick="aufgeben(modeSelection.value);" name="button">vorläufige bzw. beste Ergebnis ansehen</button>
</div>
<br>
<button type="button" id="removeTilesFinishedB" style="display: none; font-size: 33px" onclick="shufflePuzzle();" name="button">finished</button>
<br>
<br>
<canvas onmousedown="mouseDown(true);" onmouseup="mouseUp();" id="textur" width="1" onclick="canvasClicked('elm');" height="1"></canvas>
<p id="showOriginalP" style="display:none">
  <input id="showOriginal"  onchange="originalDisplayChanged(checked)" type="checkbox"> Original anzeigen
  <br>
  <img style="display: none;" id="preview">
</p>
<script>
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
  } else {
    var gerät = "PC"
    console.log("PC");
    swipeSteuerungP.style.display = "none";
    scrollOnBlancP.style.display = "none";
  }
  mobileControls.style.display = 'none';
  reloadWhenFinished.checked = JSON.parse(localStorage.getItem("reloadWhenFinished"));
  anzahlVerschieben.value = anzahl.value*anzahl.value;
  settings.style.display = "none";
  aufgebenId.style.display = "none";
  // schiebenSettings.style.display  = "inline"
  randSettings.style.display = "none";
  schiebenSettings.style.display = "none";
  größeAnpassenX.max = window.innerWidth
  größeAnpassenY.max = window.innerHeight
  var canvas = textur.getContext('2d');
  function aufgeben(mode) {
    if (mode != "traditional") {
      alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen");
    }
    else alert(`Ihre vorläufigen Daten: Sie haben ${stats.turns} mal Teile verbunden und ${stats.unclipped} mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} mal ein Teil gedreht.`);
    if (mode == "exchange" && stats.preOrdered) alert(`Bedenken Sie jedoch, dass Sie von den ${stats.highestRight.right} Richtigen von Anfang an ${stats.preOrdered} Teile von den insgesamt ${positions.wrong.length} Teilen an der richtigen Position hatten!`);
    alert(`Zudem haben Sie bis jetzt ${stats.lookedAtOriginal.times} mal für insgesamt ${stats.lookedAtOriginal.time} (Milli-) Sekunden auf das Originalbild geguckt.`.replace('undefined', '0'));
  }
  function zuBildschirmgröße() {
    größeAnpassenX.value = window.innerWidth;
    größeAnpassenY.value = window.innerHeight;
    zeigeGröße();
  }
  function zuAngepassterBildschirmgröße(noShowing) {
    var referenceSize = originalSize;
    if (noShowing) {
      referenceSize = {width: window.innerWidth + 1, height: window.innerHeight + 1};
      if (!screenIsMax.checked) referenceSize = {width: JSON.parse(JSON.stringify(größeAnpassenX.value)), height: größeAnpassenY.value};
    }
    if (window.innerWidth < referenceSize.width && window.innerHeight < referenceSize.height) {
      größeAnpassenX.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
    }
    else {
      größeAnpassenX.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
    }
    if (!noShowing) zeigeGröße();
    else if (screenIsMax.checked) preventAutomaticZoom.content = `width=${größeAnpassenX.value}, height=${größeAnpassenY.value}, initial-scale=1.0, maximum-scale=1.0, user-scalable=0`;
  }
  function zuOptimalerBildschirmgröße() {
    größeAnpassenX.value = preview.width;
    größeAnpassenY.value = preview.height;
    while (größeAnpassenX.value > window.innerWidth || größeAnpassenY.value > window.innerHeight) {
      größeAnpassenX.value--;
      größeAnpassenY.value--;
    }
    zeigeGröße();
  }
  function zeigeGröße() {
    textur.width = größeAnpassenX.value;
    textur.height = größeAnpassenY.value
    // canvas.clearRect(0, 0, textur.width, textur.height);
    if (preview.src == "") {
    canvas.fillStyle = "blue";
    canvas.fillRect(0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  else {
    canvas.drawImage(document.getElementById('preview'), 0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  }
  function modeSelected(value) {
    traditionalSettings.style.display = 'none';
    exchangeSettings.style.display = 'none';
    schiebenSettings.style.display = 'none';
    document.getElementById(value + 'Settings').style.display = 'inline';
  }
  var originalSize = {width: 0, height: 0};
  function originalDisplayChanged(checked) {
    startPause();
    if (checked) stats.lookedAtOriginal.times++;
    if (checked) {
      preview.style.display = "inline";
      showOriginal.scrollIntoView();
    }
    else preview.style.display = "none";
  }
  function create() {
    //finished = false;
    // if (swipeSteuerung.checked) textur.style.touchAction = 'none';
    /*if (swipeSteuerung.checked) {
      alert("Please zoom out as far as possible! You have 5 sec. for that!");
      // textur.style.touchAction = '';
      setTimeout(function () {
        textur.style.touchAction = 'none';
        create2();
      }, 5000);
    }
    else */create2();
  }
  function create2() {
    if (screenIsMax.checked && rotateTiles.checked) preventAutomaticZoom.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
    positions = {right: [], wrong: []};
    if (modeSelection.value == "traditional") {
      if (rotateTiles.checked) zuAngepassterBildschirmgröße(true);
      positions.layoutOrder = new Array(document.getElementById('anzahl').value*document.getElementById('anzahl').value);
      for (var i = 0; i < positions.layoutOrder.length; i++) {
        positions.layoutOrder[i] = i;
      }
    }
    removeTilesFinishedB.style.display = 'inline';
    showSettings.innerHTML = "Einstellungsmöglichkeiten und Möglichkeit Aufzugeben";
    imageSettings.style.display = "none";
    modeSelection.style.display = "none";
    schiebenSettings.style.display = "none";
    rotateTilesP.style.display = "none";
    missing = [];
    settings.style.display = 'none';
    mobileControls.style.display = "inline";
    originalSize.width = preview.width;
    originalSize.height = preview.height;
    preview.width = größeAnpassenX.value;
    preview.height = größeAnpassenY.value;
    textur.width = preview.width// + 111;
    textur.height = preview.height// + 111;
    var anzahl = document.getElementById('anzahl').value;
    if (sourceIsPicture.checked) lengthPerTeil = {original: {x: Math.round(originalSize.width/anzahl), y: Math.round(originalSize.height/anzahl)}, edit: {x: Math.round(preview.width/anzahl), y: Math.round(preview.height/anzahl)}};
    else lengthPerTeil = {original: {x: Math.round(video.videoWidth/anzahl), y: Math.round(video.videoHeight/anzahl)}, edit: {x: Math.round(preview.width/anzahl), y: Math.round(preview.height/anzahl)}};
    breiteRand.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3;
    randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - breiteRand.value;
    for (var i = 0; i < anzahl; i++) {
      for (var i1 = 0; i1 < anzahl; i1++) {
        if (modeSelection.value == "traditional") {
          var newTile = {original: {x: lengthPerTeil.original.x*i, y: lengthPerTeil.original.y*i1, degree: 0}, edit: {x: lengthPerTeil.edit.x*i, y: lengthPerTeil.edit.y*i1, degree: 0}};
          if (i) newTile.original.left = {x: positions.right[i*anzahl + i1 - anzahl]?.original.x, y: positions.right[i*anzahl + i1 - anzahl]?.original.y};
          if (i1) newTile.original.top = {x: positions.right[i*anzahl + i1 - 1]?.original.x, y: positions.right[i*anzahl + i1 - 1]?.original.y};
          positions.right.push(newTile);
          if (i1) positions.right[i*anzahl + i1 - 1].original.bottom = {x: newTile.original.x, y: newTile.original.y};
          if (i) positions.right[i*anzahl + i1 - anzahl].original.right = {x: newTile.original.x, y: newTile.original.y};
        }
        else {
          positions.right.push({original: {x: lengthPerTeil.original.x*i, y: lengthPerTeil.original.y*i1}, edit: {x: lengthPerTeil.edit.x*i, y: lengthPerTeil.edit.y*i1}})
        }
        positions.right[positions.right.length - 1].border = [];
        if (i == 0) positions.right[positions.right.length - 1].border.push("left");
        if (i == anzahl - 1) positions.right[positions.right.length - 1].border.push("right");
        if (i1 == 0) positions.right[positions.right.length - 1].border.push("up");
        if (i1 == anzahl - 1) positions.right[positions.right.length - 1].border.push("down");
      }
    }
    positions.wrong = JSON.parse(JSON.stringify(positions.right));
    //canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/200, /*yFromPicture*/200, 200, 200, /*xFromPlacement*/0, /*yFromPlacement*/0, 200, 200);
    window.scroll(0, /*96 50*/32);
    if (modeSelection.value == "schieben") {
      alert("Bitte wählen Sie ein Teilstück aus, das entfernt wird. Im besten Fall ist es ein unwichtiger Teil des Bildes!");
      layout(true);
    }
    else removeTile(true);
    // else layout();
    if (sourceIsVideo.checked) canvas.clearRect(0, 0, textur.width, textur.height);
    showSettings.scrollIntoView();
    textur.style.touchAction = "none";
    window.scroll(0, 0);
    texturTop = textur.getBoundingClientRect().top;
  }

  function shufflePuzzle() {
    if (modeSelection.value == "schieben" && !selected.tiles.length) alert("Sie müssen mindestens ein Teil ausgeählt haben, das wegfällt, damit Sie schieben können!");
    else {
    for (var i of selected.tiles) {
      missing.push(JSON.parse(JSON.stringify(positions.wrong[i].edit.x + ' - ' + positions.wrong[i].edit.y)));
      positions.wrong.forEach((position, i1) => {
        for (var direc of ['top', 'right', 'bottom', 'left']) {
          if (position.original[direc]) {
            position.original[direc].degree = 0;// position.edit.degree;
            if (angular.equals(position.original[direc], {x: positions.wrong[i].original.x, y: positions.wrong[i].original.y, degree: 0})) {
              delete position.original[direc].degree;
              delete positions.right[i1].original[direc]
              // delete position.original[direc];
            }
            else delete position.original[direc].degree;
          }
        }
      });
    }
    if (modeSelection.value != "exchange") {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (selected.objTiles.includes(JSON.stringify(positions.wrong[i].edit))) {
          positions.wrong.splice(i, 1);
          positions.right.splice(i, 1);
          if (modeSelection.value == "traditional") {
            positions.layoutOrder.splice(i, 1);
            for (var i1 = i; i1 < positions.layoutOrder.length; i1++) {
              positions.layoutOrder[i1]--;
            }
          }
          i--;
        }
      }
    }
    else doNotChange = selected.tiles;
    selected.tiles = [];
    removeTilesFinishedB.style.display = 'none';
    state.removeTile = false;
    if (modeSelection.value == "schieben") verschiebenPC();
    else {
    if (modeSelection.value == "traditional") {
      textur.width += 500;
      textur.height += 500;
    for (var position of positions.wrong) {
      position.edit = {x: Math.round(Math.random()*(textur.width - lengthPerTeil.edit.x)), y: Math.round(Math.random()*(textur.height - lengthPerTeil.edit.y))};
      position.original = {x: position.original.x, y: position.original.y, degree: [0, 90, 180, 270][Math.round(Math.random()*3)]};
      if (!rotateTiles.checked) position.original.degree = 0;
    }
  }
  // var possible = new Array(positions.wrong.length).fill(0)
  // for (var i = 0; i < possible.length; i++) {
  //   possible[i] += i;
  //   if (doNotChange.includes(i)) possible.splice(i, 1);
  // }
  // possible = possible.filter(x => x);
  // for (i = possible.length - 1; modeSelection.value == "exchange" && i > 0; i--) {
  //   j = possible[Math.floor(Math.random() * (i + 1))];
  //   x = positions.wrong[possible[i]].edit;
  //   positions.wrong[i].edit = positions.wrong[j].edit;
  //   positions.wrong[j].edit = x;
  // }
    for (i = positions.wrong.length - 1; modeSelection.value == "exchange" && i > 0; i--) {
      do {
        j = Math.floor(Math.random() * (i + 1));
      } while (doNotChange.includes(j) && j != i && doNotChange.length != positions.wrong.length);
      x = positions.wrong[i].edit;
      if (!doNotChange.includes(i)) {
      positions.wrong[i].edit = positions.wrong[j].edit;
      positions.wrong[j].edit = x;
    }
    }
    stats.preOrdered = doNotChange.length;
    doNotChange = [];
    layout();
  }
  }
  aufgebenId.style.display = "inline";
  showOriginalP.style.display = 'inline';
  textur.style.touchAction = "none";
  if (gerät == "Handy") mobileControls.style.display = 'inline';
  selected.boolean = false;
  if (gerät == "Handy") rotateControls.style.display = "inline";
  preventAutomaticZoom.content = "";
  scrollDownInt = setInterval(scrollDownFunction, 10);
  scrollRightInt = setInterval(scrollRightFunction, 10);
  window.scroll(0, 0);
  var texturTop = textur.getBoundingClientRect().top;
  }
  function readImg(input) {
    var reader = new FileReader();
    reader.onload = function (e) {
      if (sourceIsPicture.checked) document.getElementById('preview').setAttribute("src", e.target.result);
      else {
        video.setAttribute("src", e.target.result);
        startVideo();
        setTimeout(function () {
          loadImage(video.videoWidth, video.videoHeight);
        }, 1000);
      }
    };
    reader.readAsDataURL(input.files[0]);
    if (input.files[0].type.includes('video')) sourceIsVideo.checked = true;
    else sourceIsPicture.checked = true;
    loadImage();
  }
  var video = document.createElement("video");
  function useURL() {
    if (sourceURL.value.includes('.mp4') || sourceURL.value.includes('.move')) sourceIsVideo.checked = true;
    if (sourceURL.value.includes('.png') || sourceURL.value.includes('.jpg') || sourceURL.value.includes('.jpeg')) sourceIsPicture.checked = true;
    if (sourceIsPicture.checked) {
    preview.src = sourceURL.value;
    loadImage();
  }
  else {
    video.src = sourceURL.value;
    setTimeout(function () {
    loadImage(video.videoWidth, video.videoHeight);
  }, 100);
    startVideo();
  }
  }

function startVideo() {
  video.play();  // start playing
  updateVideo(); //Start rendering
}

function updateVideo(){
  canvas.clearRect(0, 0, textur.width, textur.height);
  for (var i = 0; aufgebenId.style.display == "inline" && i < positions.wrong?.length; i++) {
    drawPictureSegment(positions.wrong[i], positions.right[i], false, i);
  }
  if (aufgebenId.style.display != "inline") canvas.drawImage(video,0,0, größeAnpassenX.value, größeAnpassenY.value);
  for (var tile of selected.tiles) {
    canvas.fillStyle = "rgba(255, 0, 0, 0.3)";
    canvas.save();
    if (state.removeTile/* && modeSelection.value != "schieben"*/) canvas.translate(positions.wrong[tile].edit.x + lengthPerTeil.edit.x/2, positions.wrong[tile].edit.y + lengthPerTeil.edit.y/2);
    else canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
    canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
    canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.restore();
  }
  if (video.ended) {
    video.currentTime = 0;
    video.play();
  }
  requestAnimationFrame(updateVideo); // wait for the browser to be ready to present another animation fram.
}
var originalSize = {};
  function loadImage(width, height) {
    setTimeout(function () {
      if (!width) {
        width = preview.width;
        height = preview.height;
      }
      originalSize = {width: width, height: height};
       canvas.drawImage(document.getElementById('preview'), 0, 0);
       textur.width = width// + 111;
       textur.height = height// + 111;
       if (window.innerWidth > width) größeAnpassenX.max = window.innerWidth;
       else größeAnpassenX.max = width;
       if (window.innerHeight > height) größeAnpassenY.max = window.innerHeight;
       else größeAnpassenY.max = height;
       größeAnpassenX.value = width;
       größeAnpassenY.value = height;
       zeigeGröße();
    }, 500);
  }
  var lengthPerTeil = {};
  var positions = {right: []};
  var finished = false;
  var missing = [];
  function convertDirection(direc, degr) {
    var directions = ['top', 'right', 'bottom', 'left'];
    var direcObj = {top: 0, right: 1, bottom: 2, left: 3};
    while (degr > 0) {
      direc = directions[direcObj[direc] + 1];
      if (!direc) direc = directions[0];
      degr -= 90;
    }
    return direc;
  }
  function layout(withoutAlert, clear, pReturn, removeTilesScreen) {
    if (state.removeTile) removeTilesScreen = true;
    if (clear && (aufgebenId.style.display == 'inline' || state.removeTile)) canvas.clearRect(0, 0, 10000, 10000);
    richtige = 0;
    for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
      var i = i1;
      if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
      drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i);
    }
    for (var clip of selected.clip) {
      canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
      if (markWrong.checked && (JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) canvas.fillStyle = 'rgba(255, 0, 0, 0.83)';
      canvas.save();
      canvas.translate(clip.x, clip.y);
      // canvas.rotate((positions.wrong[clip.sI].original.degree + 180)*Math.PI/180);
      canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), clip.width, clip.height);
      canvas.restore();
    }
    for (var tile of selected.tiles) {
      canvas.fillStyle = "rgba(255, 0, 0, 0.3)";
      canvas.save();
      if (state.removeTile/* && modeSelection.value != "schieben"*/) canvas.translate(positions.wrong[tile].edit.x + lengthPerTeil.edit.x/2, positions.wrong[tile].edit.y + lengthPerTeil.edit.y/2);
      else canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
      canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
      canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
      canvas.restore();
    }
    if (stats.highestRight.right < richtige && !withoutAlert) {
      stats.highestRight = {right: richtige, turns: stats.turns};
    }
    if (richtige == positions.wrong?.length && !removeTilesScreen) {
      richtige = 0;
      finished = true;
      layout(true);
      finished = false;
      if(!withoutAlert) {
        if (pReturn) return "noChange!";
        if (modeSelection.value == "schieben") alert("Sie haben es in " + stats.turns + " Zügen geschafft! Zum Umschieben vom Originalbild hat der Computer " + movement.positions.length + " Züge benötigt, um es zu zerwuseln. Ob Sie darauf jetzt stolz sein können, müssen Sie selber entscheiden ;)");
        if (modeSelection.value == "exchange") alert(`Sie haben es in ${stats.turns} Zügen geschafft! Dabei haben Sie von Anfang an von den insgesamt ${positions.wrong.length} Teilen ${stats.preOrdered} Teile an der richtigen Position gehabt.`);
        if (modeSelection.value == "traditional") alert(`Super! Sie haben das Puzzle geschafft! Sie haben ${stats.turns} mal Teile verbunden und ${stats.unclipped} mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} mal ein Teil gedreht.`);
        alert(`Zudem haben Sie ${stats.lookedAtOriginal.times} mal für insgesamt ${stats.lookedAtOriginal.time} (Milli-) Sekunden auf das Originalbild geguckt.`.replace('undefined', '0'));
        if (reloadWhenFinished.checked) {
          setTimeout(function () {
            window.location.reload(false);
          }, 3000);
        }
        else alert("Bitte laden Sie die Seite neu, wenn Sie ein weiteres Puzzle erstellen wollen!");
    }
  }
}
  var richtige = 0;
  function drawPictureSegment(position, segmentPosition, removeTilesScreen, i) {
    canvas.save();
    if (modeSelection.value == "traditional" && !removeTilesScreen) canvas.translate(position.edit.x, position.edit.y);
    else canvas.translate(position.edit.x + lengthPerTeil.edit.x/2, position.edit.y + lengthPerTeil.edit.y/2);
    canvas.rotate(position.original.degree*Math.PI/180);
    if (sourceIsPicture.checked) canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    else canvas.drawImage(video, /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // canvas.restore();
    if ((((modeSelection.value != "traditional" && position.edit.x == segmentPosition.edit.x && position.edit.y == segmentPosition.edit.y) || (modeSelection.value == "traditional" && angular.equals(position.original, segmentPosition.original))) && !removeTilesScreen && !finished)) {
      canvas.fillStyle = "rgba(0, 255, 0, " + rightMarkerTransparence.value + ")";
      if (richtigPlazierte.checked) {
        // canvas.fillRect(position.edit.x + lengthPerTeil.edit.x/2 - (lengthPerTeil.edit.x*rightMarkerRadius.value)/2, position.edit.y + lengthPerTeil.edit.y/2 - (lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
        // canvas.save();
        // canvas.translate(position.edit.x, position.edit.y);
        // canvas.rotate(position.original.degree*Math.PI/180);
        canvas.fillRect(-(lengthPerTeil.edit.x*rightMarkerRadius.value)/2, -(lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
      }
      richtige++;
    }
    canvas.restore();
    canvas.fillStyle = "rgba(0, 0, 255, 0.35)";
    if (raender.checked) {
      canvas.save();
      canvas.translate(position.edit.x, position.edit.y);
      canvas.rotate((position.original.degree)*Math.PI/180);
      // if (position.borderincludes("right")) canvas.fillRect(position.edit.x - JSON.parse(breiteRand.value) + lengthPerTeil.edit.x - JSON.parse(randPosition.value) - ((lengthPerTeil.edit.x)/2), position.edit.y - ((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y, position.original.degree);
      // if (position.borderincludes("left")) canvas.fillRect(position.edit.x + JSON.parse(randPosition.value) - ((lengthPerTeil.edit.x)/2), position.edit.y - ((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y, position.original.degree);
      // if (position.borderincludes("up")) canvas.fillRect(position.edit.x - ((lengthPerTeil.edit.x)/2), position.edit.y + JSON.parse(randPosition.value) - ((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, JSON.parse(breiteRand.value), position.original.degree);
      // if (position.borderincludes("down")) canvas.fillRect(position.edit.x - ((lengthPerTeil.edit.x)/2), position.edit.y - JSON.parse(breiteRand.value) + lengthPerTeil.edit.y - JSON.parse(randPosition.value) - ((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, JSON.parse(breiteRand.value), position.original.degree);
      if (position.border.includes("right")) canvas.fillRect((lengthPerTeil.edit.x)/2 - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("left")) canvas.fillRect(-((lengthPerTeil.edit.x)/2) + JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("up")) canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2) + JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      if (position.border.includes("down")) canvas.fillRect(-((lengthPerTeil.edit.x)/2), ((lengthPerTeil.edit.y)/2) - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      canvas.restore();
    }
  }
  var selected = {boolean: false, position: {x: 0, y: 0}, tiles: [], objTiles: [], clip: []};
  var lastCoord;
  function canvasClicked(calledBy) {
    if (aufgebenId.style.display == "inline") settings.style.display = "none"
    if (checkSelected() && selected.boolean && modeSelection.value == "exchange" && !state.removeTile) {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
          for (var i1 = 0; i1 < positions.wrong.length; i1++) {
            if (positions.wrong[i1].edit.x/lengthPerTeil.edit.x == selected.position.x && positions.wrong[i1].edit.y/lengthPerTeil.edit.y == selected.position.y) {
              console.log("vertausche " + checkSelected().x + "-" + checkSelected().y + " mit " + selected.position.x + "-" + selected.position.y);
              stats.turns++;
              vertauscheZwei(i, i1);
              i = positions.wrong.length;
              i1 = positions.wrong.length;
            }
          }
        }
      }
      selected.boolean = false;
    }
    else if (modeSelection.value == "schieben" && checkSelected()/* && selected.boolean*/ && missing.length && !state.removeTile) {
      for (var i1 = 0; i1 < missing.length; i1++) {
        pMissing = missing[i1];
        if (possibleMissing.length && pMissing == (checkSelected().x)*lengthPerTeil.edit.x + ' - ' + checkSelected().y*lengthPerTeil.edit.y) {
          moveTile(possibleMissing.filter(x => x.i1 == i1)[0].i, i1);
        }
        else {
        if ((pMissing == (checkSelected().x + 1)*lengthPerTeil.edit.x + ' - ' + checkSelected().y*lengthPerTeil.edit.y) /*right*/ || (pMissing ==(checkSelected().x - 1)*lengthPerTeil.edit.x + ' - ' + checkSelected().y*lengthPerTeil.edit.y)/*left*/ || (pMissing == checkSelected().x*lengthPerTeil.edit.x + ' - ' + (checkSelected().y + 1)*lengthPerTeil.edit.y)/*down*/ || (pMissing == (checkSelected().x*lengthPerTeil.edit.x + ' - ' + (checkSelected().y - 1)*lengthPerTeil.edit.y)/*up*/)) {
          for (var i = 0; i < positions.wrong.length; i++) {
            if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
              possibleMissing.push({i: i, i1: i1});
            }
          }
        }
        // canvas.clearRect(0, 0, 10000, 10000);
        // layout();
      }
  }
  if (possibleMissing.length == 1) moveTile(possibleMissing[0].i, possibleMissing[0].i1);
}
    else if (checkSelected() && (modeSelection.value != "schieben"/* || missing*/)) {
      selected.position = {x: checkSelected().x, y: checkSelected().y};
      selected.boolean = true;
    }
    if (checkSelected() && ((!missing.length && modeSelection.value == "schieben") || state.removeTile) && (!lastCoord || JSON.stringify(lastCoord) != JSON.stringify(checkSelected()) || (((state.mouse == "up" && calledBy != "elm") || calledBy == "mouseDown") && JSON.stringify(state.coord) == JSON.stringify(checkSelected())))) {
      removeTile(null, calledBy);
      lastCoord = checkSelected();
    }
    else {
      if (aufgebenId.style.display == "none") layout(true, true);
      else layout(false, true);
    }
  }
  function moveTile(i, i1) {
    console.log("schiebe...");
    possibleMissing = [];
    pMissing = missing[i1];
    stats.turns++;
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i]));
    positions.wrong[i].edit = {x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1])};//.splice(side, 1);
    missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
    selected.boolean = false;
  }
  var doNotChange = [];
  var possibleMissing = [];
  function removeTile(first, calledBy) {
    if (!first && (!state.tileRemoved || calledBy == "touchmove" || calledBy == "mousemove")) {
      state.tileRemoved = true;
      setTimeout(function () {
        state.tileRemoved = false;
      }, 133);
    positions.wrong.forEach((position, i) => {
      if (position.edit.x/lengthPerTeil.edit.x == checkSelected().x && position.edit.y/lengthPerTeil.edit.y == checkSelected().y) {
        if (!selected.tiles.includes(i)) {
          selected.tiles.push(i);
          selected.objTiles.push(JSON.stringify(position.edit));
        }
        else {
          for (var i1 = 0; i1 < selected.tiles.length; i1++) {
            if (selected.tiles[i1] == i) {
              selected.tiles.splice(i1, 1);
              selected.objTiles.splice(i1, 1);
            }
          }
        }
      }
    });
  }
  if (first && modeSelection.value != "schieben") alert("Hier können Sie nun auf die Teile klicken, die Sie nicht im Puzzle haben wollen! Sie können gedrückt halten, um mehrere gleichzeitig anzuwählen!");
    layout(true, true, undefined, true);
    state.removeTile = true;
  }
  function verschiebenPC() {
    var missingArray = [];
    var workingNumbers = [];
    var maleZurrück = {number: 0, normalSlide: 0};
    for (var i = 0; i < positions.wrong.length; i++) {
      workingNumbers.push(i);
    }
    var counter = 0;
    for (var i = 0; (i < /*positions.wrong.length + */JSON.parse(anzahlVerschieben.value) || (richtigeCheck.checked && richtige > anzahlRichtige.value)) && (!zurrückVermeiden.checked || counter < 100000 || counter < anzahlVerschieben.value); i++) {
      var side = workingNumbers[Math.round(Math.random()*(workingNumbers.length - 1))];
      if (!workingNumbers.length) break;
      missing.forEach((pMissing, i1) => {
      try {
      if (((zurrückVermeiden.checked && ((missingArray.length < 1 || workingNumbers.length == 0/*positions.wrong[side].edit.x != missingBefore.data.edit.x && positions.wrong[side].edit.y != missingBefore.data.edit.y*/) || ((maleZurrück.number < anzahlVerboten.value && !((maleZurrück.normalSlide/5 + "").includes("."))) || !(missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y)/*missingBefore.data.edit.x != missing.data.edit.x && missingBefore.data.edit.y != missing.data.edit.y*/)))) || !zurrückVermeiden.checked) && ((pMissing == (positions.wrong[side].edit.x + lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y) /*right*/ || (pMissing ==
      (positions.wrong[side].edit.x - lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y)/*left*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y + lengthPerTeil.edit.y))/*down*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y - lengthPerTeil.edit.y))/*up*/)) {
      if (zurrückVermeiden.checked && (missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y))) {
        maleZurrück.number++;
      }
      else maleZurrück.normalSlide++;
      missingArray.push(pMissing);
      //console.log(missingArray);
      movement.positions.unshift(JSON.parse(JSON.stringify(positions)));
      movement.missing.unshift(JSON.parse(JSON.stringify(pMissing)));
      var ablage = JSON.parse(JSON.stringify(positions.wrong[side]));
      positions.wrong[side].edit = JSON.parse(JSON.stringify({x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1])}));//.splice(side, 1);
      textur.width = textur.width;
      layout(true);
      // for (var i1 = 0; difficultSchieben.checked && i1 < movement.positions.length; i1++) {
      //   if (angular.equals(positions, movement.positions[i1])/* && angular.equals(missing, movement.missing[i1])*/) {
      //     positions = JSON.parse(JSON.stringify(movement.positions[1]));
      //     missing = JSON.parse(JSON.stringify(movement.missing[1]));
      //     movement.positions.splice(0, 1);
      //     movement.missing.splice(0, 1);
      //     maleZurrück.number++;
      //     i1 = movement.positions.length;
      //     i--;
      //     for (var i2 = 0; i2 < workingNumbers.length; i2++) {
      //       if (workingNumbers[i2] == side) workingNumbers.splice(i2, 1);
      //     }
      //   }
      // }
      // if (i1 != movement.positions.length + 1) {
          missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
          workingNumbers = [];
          for (var i1 = 0; i1 < positions.wrong.length; i1++) {
            workingNumbers.push(i1);
          }
      // }
    }
      else {
        i--;
        for (var i1 = 0; i1 < workingNumbers.length; i1++) {
          if (workingNumbers[i1] == side) workingNumbers.splice(i1, 1);
        }
      }
    } catch (e) {
      //console.log("ein Error bei der if Abfrage!!! + (" + e + ")");
      i = positions.wrong.length;
    }
  });
    counter++;
    }
    if (layout(undefined, true, true) != undefined) verschiebenPC();
  }
  var movement = {missing: [], positions: []};
  var mausx;
  var mausy;
  var stats = {turns: 0, highestRight: {turns: 0, right: 0}, rotated: 0, unclipped: 0, wrongClipped: 0, lookedAtOriginal: {times: 0}};
  document.onmousemove = readMouseMove
  function readMouseMove(e) {
    mausx = e.clientX + scrollX;
    mausy = e.clientY + scrollY - texturTop;
    // /*96*/32// - 43;
    // if (scrollY > 32) mausy += 32;
    folgenMouseMove("mousemove");
  }
  window.scroll(0, 0);
  var texturTop = textur.getBoundingClientRect().top;
  var state = {mouse: "up", shift: false, newTileSelected: false, buttons: {}, coord: {x: 0, y: 0}};
  function mouseDown(elmCalled, touchStart) {
    state.mouse = "down";
    state.coord = checkSelected();
    if (modeSelection.value == "traditional") {
      // selected.tiles = [];
      selected.position = {x: mausx, y: mausy};
      for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
        var i = positions.layoutOrder[i1];
        var coord = positions.wrong[i].edit;
        var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
        if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
        if (!state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
          selected.tiles.push(i);
          positions.layoutOrder = positions.layoutOrder.filter(x => x != i);
          positions.layoutOrder.push(i);
          if (!elmCalled && !touchStart) {
            if (rotatesRight.checked) rotateSelected(90);
            if (rotatesLeft.checked) rotateSelected(-90);
          }
          layout(true);
          state.newTileSelected = true;
        }
      }
      folgenMouseMove("mouseDown");
    }
  }
  function folgenMouseMove(calledBy) {
    if (state.mouse == "down" && state.removeTile) canvasClicked(calledBy);
    if (state.mouse == "down" && !state.removeTile && modeSelection.value == "traditional") {
      // select clipped
      for (var tile of selected.tiles) {
        var objTile = positions.wrong[tile];
        if (gerät == "PC") {
        if (objTile.edit.x + lengthPerTeil.edit.x > textur.width) textur.width += lengthPerTeil.edit.x;
        if (objTile.edit.y + lengthPerTeil.edit.y > textur.height) textur.height += lengthPerTeil.edit.y;
      }
        for (var clipp of clipped) {
          var newTile = clipp.split(' - ').filter(x => !selected.tiles.includes(JSON.parse(x)))[0];
          if (!state.shift && clipp.split(' - ').includes(tile + "") && newTile) {
            selected.tiles.push(JSON.parse(newTile));
            positions.layoutOrder = positions.layoutOrder.filter(x => x != JSON.parse(newTile));
            positions.layoutOrder.push(JSON.parse(newTile));
          }
        }
        // unclipp
        if (state.shift) {
          objTile.original = {x: objTile.original.x, y: objTile.original.y, degree: objTile.original.degree};
          var unclipped = false;
          clipped.forEach((clipp, i) => {
            if (clipp.split(' - ').includes(tile + "")) {
              clipped.splice(i, 1);
              unclipped = true;
            }
          });
          if (unclipped) stats.unclipped++;
        }
        // positions.wrong.forEach((position, i) => {
        //   if (((objTile.original?.left?.x == position.original?.x && objTile.original?.left?.x != undefined && objTile.original?.left?.y == position.original?.y) || (objTile.original?.top?.x == position.original?.x && objTile.original?.top?.x != undefined && objTile.original?.top?.y == position.original?.y) || (objTile.original?.wrong?.x == position.original?.x && objTile.original?.wrong?.x != undefined && objTile.original?.wrong?.y == position.original?.y) || (objTile.original?.bottom?.x == position.original?.x && objTile.original?.bottom?.x != undefined && objTile.original?.bottom?.y == position.original?.y)) && !selected.tiles.includes(i)) {
        //     selected.tiles.push(i);
        //   }
        // });
      }
      if (selected.tiles.length) {
        positions.wrong.forEach((pos, i) => {
          if (selected.tiles.includes(i)) {
            pos.edit.x += mausx - selected.position.x;
            pos.edit.y += mausy - selected.position.y;
          }
        });
        // check clicking
        selected.clip = [];
        for (var tile of selected.tiles) {
          checkPossibleClipping(tile);
        }
        selected.position = {x: mausx, y: mausy};
        layout(false, true);
      }
    }
  }
  function checkPossibleClipping(tile) {
    var nearest = {left: {area: 1000}, top: {area: 1000}, right: {area: 1000}, bottom: {area: 1000}};
    positions.wrong.forEach((pos, i) => {
      var obj = {all: pos.edit, slc: positions.wrong[tile].edit};
      // canvas.fillStyle = "yellow";
      // canvas.fillRect(obj.all.x + lengthPerTeil.edit.x, obj.all.y, 10, lengthPerTeil.edit.y);
      // canvas.fillStyle = "orange";
      // canvas.fillRect(obj.slc.x - 10, obj.slc.y, 10, lengthPerTeil.edit.y);
      var selectedObj = {
        right: {x: obj.slc.x - 10, y: obj.slc.y + 1, width: 10, height: lengthPerTeil.edit.y - 2},
        left: {x: obj.slc.x + lengthPerTeil.edit.x, y: obj.slc.y + 1, width: 10, height: lengthPerTeil.edit.y - 2},
        bottom: {x: obj.slc.x + 1, y: obj.slc.y - 10, width: lengthPerTeil.edit.x - 2, height: 10},
        top: {x: obj.slc.x + 1, y: obj.slc.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x - 2, height: 10}
      };
      if (!clipped.includes(i + ' - ' + tile) && !clipped.includes(tile + ' - ' + i)) {
        var nearTile = {
          right: collides(selectedObj.right, {x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y + 1, width: 10, height: lengthPerTeil.edit.y - 2}),
          left: collides(selectedObj.left, {x: obj.all.x - 10, y: obj.all.y + 1, width: 10, height: lengthPerTeil.edit.y - 2}),
          bottom: collides(selectedObj.bottom, {x: obj.all.x + 1, y: obj.all.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x - 2, height: 10}),
          top: collides(selectedObj.top, {x: obj.all.x + 1, y: obj.all.y - 10, width: lengthPerTeil.edit.x - 2, height: 10})
        };
        for (var side of Object.keys(nearTile)) {
          if (nearTile[side].boolean && nearTile[side].area < nearest[side].area) {
            nearest[side] = {area: nearTile[side].area, i: i};
          }
        }
      }
    });
    var screenObj = {x: scrollX, y: scrollY, width: window.innerWidth - 22, height: window.innerHeight};
    var clipLength = selected.clip.length;
    var obj = {all: positions.wrong[nearest?.right.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.left) {
      selected.clip.push({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y, selected: {x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y}});;
    }
    obj = {all: positions.wrong[nearest?.left.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.right) {
      selected.clip.push({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y, selected: {x: obj.all.x - lengthPerTeil.edit.x, y: obj.all.y}});
    }
    obj = {all: positions.wrong[nearest?.bottom.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.top) {
      selected.clip.push({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x, y: obj.all.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x, height: 10, selected: { x: obj.all.x, y: obj.all.y + lengthPerTeil.edit.y}});
    }
    obj = {all: positions.wrong[nearest?.top.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.bottom) {
      selected.clip.push({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x, y: obj.all.y - 10, width: lengthPerTeil.edit.x, height: 10, selected: {x: obj.all.x, y: obj.all.y - lengthPerTeil.edit.y}});
    }
    if (selected.clip.length > clipLength && (selectedCollidesOthers(selected.clip[selected.clip.length - 1], tile) || !collides(addTolerance(selected.clip[selected.clip.length - 1], 3), screenObj).boolean)) selected.clip.pop();
  }
  function selectedCollidesOthers(pClip, tile) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (collides(transformToObj(i), addTolerance(pClip, 3)).boolean && !selected.tiles.includes(i) && tile != i) return true;
    }
  }
  var clipped = [];
  function mouseUp() {
    state.mouse = "up";
    if (modeSelection.value == "traditional") {
      state.newTileSelected = false;
      if (selected.clip.length > 0) {
        new Audio('https://adi.nicolaiweitkemper.de/Sounds/helpTheTrain/weiche.mp3').play();
        console.log("clipping...");
        stats.turns++;
      }
      for (var clip of selected.clip) {
        if ((JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) stats.wrongClipped++;
        var directionOpposite = {left: 'right', top: 'bottom', right: 'left', bottom: 'top'};
        positions.wrong[clip.i].original[clip.direction] = {x: positions.right[clip.sI].original.x, y: positions.right[clip.sI].original.y};
        positions.wrong[clip.sI].original[directionOpposite[clip.direction]] = {x: positions.right[clip.i].original.x, y: positions.right[clip.i].original.y};
        var differ = {x: (clip.selected.x - positions.wrong[clip.sI].edit.x), y: (clip.selected.y - positions.wrong[clip.sI].edit.y)};
        for (var tile of selected.tiles) {
          positions.wrong[tile].edit.x += differ.x;
          positions.wrong[tile].edit.y += differ.y;
        }
        clipped.push(clip.i + ' - ' + clip.sI);
        // do more clipping if needed
        checkPossibleClipping(clip.sI);
    }
    selected.clip = [];
    if (selected.tiles.length && !state.shift && !state.removeTile) selected.tiles = [];
    }
  }
  function collides(a, b) {
    try {
      return {boolean: !(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        ), area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)};

    } catch (e) {
      console.log('err: ' + e);
    }
  }
  function selectedCollides(potentiallySelected) {
    for (var tile of selected.tiles) {
      // if (collides({x: positions.wrong[tile].edit.x, y: positions.wrong[tile].edit.y, width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y}, potentiallySelected)
      if (collides(transformToObj(tile), transformToObj(potentiallySelected)).boolean) return tile;
    }
  }
  function transformToObj(i, tolerance) {
    var obj =  positions.wrong[i].edit;
    if (!tolerance) tolerance = 0;
    return {x: obj.x + tolerance, y: obj.y + tolerance, width: lengthPerTeil.edit.x - tolerance*2, height: lengthPerTeil.edit.y - tolerance*2};
  }
  function addTolerance(obj, tolerance) {
    return {...obj, x: obj.x + tolerance, y: obj.y + tolerance, width: obj.width - tolerance*2, height: obj.height - tolerance*2};
  }
  // if (gerät == "Handy") {
    document.addEventListener('touchmove', touch);
    document.addEventListener('touchstart', touch);
    document.addEventListener('touchend', touch);
  // }
  document.onkeydown = function(event) {
    if (event.shiftKey) {
      state.shift = true;
    }
    if (event.key == "ArrowRight") rotateSelected(90);
    if (event.key == "ArrowLeft") rotateSelected(-90);
    if (event.key.includes("Arrow")) layout(true);
    if ((event.key == "ArrowRight" || event.key == "ArrowLeft") && modeSelection.value == "traditional" && selected.tiles.length && rotateTiles.checked) return false;
  }
  function rotateSelected(direction) {
    if (!state.removeTile) {
      stats.rotated++;
      for (var tile of selected.tiles) {
        positions.wrong[tile].original.degree += direction;
        if (positions.wrong[tile].original.degree < 0) positions.wrong[tile].original.degree = 270;
        else if (positions.wrong[tile].original.degree >= 360) positions.wrong[tile].original.degree = 0;
      }
    }
  }
  document.onkeyup = function(event) {
    if (!event.shiftKey && state.shift) {
      state.shift = false;
      selected.tiles = [];
    }
  }
  function touch(ev) {
    if ((aufgebenId.style.display == "inline" || removeTilesFinishedB.style.display == "inline") && (!ev.touches[0] || (ev.touches[0] && !collides({x: ev.touches[0]["pageX"] - scrollX, y: ev.touches[0]["pageY"] - scrollY, width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean))) {
    if (ev.touches[2]) {
      textur.style.touchAction = '';
    }
    else if (ev.type == "touchmove" && !scrollable.checked && (!scrollOnBlanc.checked || selected.tiles.length)) {
      textur.style.touchAction = 'none';
    }
    if (ev.touches[1] && aufgebenId.style.display == "inline") {
      state.shift = true;
      selected.tiles = [];
    }
    else if (ev.type == "touchmove") state.shift = false;
    if ((ev.type == "touchend" && swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && (textur.style.touchAction == 'none') && (swipeSteuerung.checked ))) {
      // textur.style.touchAction = '';
      canvasClicked();
    }
    else if ((state.removeTile || ((swipeSteuerung.checked || modeSelection.value == "traditional") && modeSelection.value != "schieben")) && ev.touches[0]) {
      mausx = ev.touches[0]["pageX"]// + scrollX;
      mausy = ev.touches[0]["pageY"] - texturTop;// - 32// + scrollY;
    }
    if (!scrollable.checked) {
      // if (aufgebenId.style.display == "inline") textur.style.touchAction = 'none';
    if (ev.type == "touchstart") {
      mouseDown(null, ev.touches[0] == undefined && collides({x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"], width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean);
    }
    if (ev.type == "touchend") {
      mouseUp();
      layout(true, true);
    }
    if (ev.type == "touchmove" && (modeSelection.value == "traditional" || state.removeTile)) {
      folgenMouseMove("touchmove");
    }
  }
    if (!ev.touches[0]) {
      console.log(":((()))");
    }
      if (ev.type == "touchstart" && swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && ev.touches[0]) {
        if (textur.style.touchAction != 'none') {
        setTimeout(function () {
          window.scroll(0, /*96 50*/32);
          textur.style.touchAction = 'none';
          selected.position = {x: checkSelected().x, y: checkSelected().y};
          selected.boolean = true;
        }, 3000);
      }
      else {
        selected.position = {x: checkSelected().x, y: checkSelected().y};
        selected.boolean = true;
      }

      }
      if (scrollable.checked) textur.style.touchAction = '';
    }
    else {
      console.log("clicked control element");
    }
    if (!selected.tiles.length && ev.type == "touchmove" && scrollOnBlanc.checked) textur.style.touchAction = '';
  }
  function vertauscheZwei(i, i1) {
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i].edit));
    positions.wrong[i].edit = JSON.parse(JSON.stringify(positions.wrong[i1].edit));
    positions.wrong[i1].edit = JSON.parse(JSON.stringify(ablage));
    if (positions.wrong[i1].edit == undefined) positions.wrong.splice(i1, 1);
  }
  function checkSelected() {
    try {
    for (var i = 0; i < anzahl.value; i++) {
      for (var i1 = 0; i1 < anzahl.value; i1++) {
        if (mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1)) return {x: i, y: i1};
      }
    }
  } catch (e) {
    console.log("pleaseDebug :)");
  }
  }
  function scrollDownFunction(tile) {
    // selected.tiles.forEach((tile, i) => {
      if (!scrollable.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.y + lengthPerTeil.edit.y/2 > window.innerHeight + scrollY + texturTop) || (modeSelection.value != "traditional" && !i && mausy - scrollY > window.innerHeight - 10))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        window.scroll(scrollX, scrollY + 3);
        mausy += 3;
      }
    // });
  }
scrollUpInt = setInterval(function () {
  if (!scrollable.checked && aufgebenId.style.display == "inline" && (mausy - scrollY < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    window.scroll(scrollX, scrollY - 3);
    mausy -= 3;
}
}, 10);
  function scrollRightFunction() {
    // selected.tiles.forEach((tile, i) => {
      if (!scrollable.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x + lengthPerTeil.edit.y/2 > window.innerWidth + scrollX) || (modeSelection.value != "traditional" && !i && mausx - scrollX > window.innerWidth - 10))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        window.scroll(scrollX + 3, scrollY);
        mausx += 3;
      }
    // });
  }
scrollLeftInt = setInterval(function () {
  if (!scrollable.checked && aufgebenId.style.display == "inline" && (mausx - scrollX < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    window.scroll(scrollX - 3, scrollY);
    mausx -= 3;
}
}, 10);

// stop clock:
var time = 0;
var running = 0;

function startPause() {
if (running == 0) {
  running = 1;
  // time = 0;
  increment();
}
else {
  running = 0;
}
}
function reset() {
running = 0;
timer = 0;
}
function increment() {
if (running == 1) {
setTimeout(function () {
  time++;
  var mins = Math.floor(time/10/60);
  var secs = Math.floor(time/10);
      secs += 60*mins;
  var tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  stats.lookedAtOriginal.time = mins + ":" + secs + ":" + "0" + tenths;
  increment();
}, 100);
}
}
</script>
