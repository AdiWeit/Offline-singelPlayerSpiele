<meta charset="utf-8">
<meta name="viewport" id="preventAutomaticZoom">
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<p id="imageSettings">
<input type="text" value="4" id="anzahlX" onchange="anzahlVerschieben.value = value*anzahlY.value" placeholder="Puzzle Teile je x-Achse">
<br>
<input type="text" value="4" id="anzahlY" onchange="anzahlVerschieben.value = anzahlX.value*value" placeholder="Puzzle Teile je y-Achse">
<br>
<input type="file" onchange="readImg(this);">
<br>
<input type="text" style="height: 50px;" height="100px" placeholder="URL (drag and drop möglich)" id="sourceURL">
<button type="button" onclick="useURL();" name="button">nutzen (als Quelle)</button>
<br>
<select id="cameraSelection" onchange="changeCamera(value);"></select>
<button id="useLiveCam" onclick="changeCamera(cameraSelection.value);">nutze live Kamera</button>
<a style="display: none;" id="sourceCheckboxes">
<br>
  <input id="sourceIsPicture" checked="true" name="mediaType" type="radio">Bild
  <input id="sourceIsVideo" name="mediaType" type="radio">Video
</a>
<br>
<input id="mirrorInput" onclick="mirrorCanvas(checked);" type="checkbox"> Input spiegeln
<br>
<input type="range" onchange="adaptTileAmount();" oninput="zeigeGröße(true);" placeholder="Pixelanzahl x achse" id="größeAnpassenX"> Breite des Bildes
<br>
<input type="range" onchange="adaptTileAmount();" max="window.innerHeight" oninput="zeigeGröße(true);" placeholder="Pixelanzahl y achse" id="größeAnpassenY"> Höhe des Bildes
<br>
<button type="button" onclick="zuBildschirmgröße();" name="button">Größe auf Bildschirmgröße anpassen</button>
<button type="button" onclick="zuAngepassterBildschirmgröße();" name="button">Größenverhältnis angleichen</button>
<button type="button" onclick="zuOptimalerBildschirmgröße();" name="button">Größenverhältnis optimieren</button>
<br>
<p1 id="screenIsMaxP"><input id="screenIsMax" onchange="changeAdaptedSizeMax(originalSize.width, originalSize.height);" checked="true" type="checkbox"> maximale Größe des Bildes: Bildschirmgröße</p1>
<br>
<button type="button" style="font-size: 33px;" onclick="create();" name="button">erstelle Puzzle</button>
</p>
<button type="button" id="showSettings" onclick="changeSettingsVis();" name="button">mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)</button>
<br>
<button style="position: fixed; display: none;" id="selectBackToBarB" onclick="generalBackToBar(this);">zurück in Leiste</button>
<p2 style="position: fixed; top: -7px; left: 377px; background-color: rgba(205, 218, 199, 0.77); font-size: 5vh; padding-bottom: 15px; border-radius: 5px; z-index: 2;" id="mobileControls">
  <p id="rotateControls" style="display: none;">
    <a style="display: none;" id="traditionalModeMobileControls">
      <input class="mobileControlsElm" type="checkbox" oninput="rotatesRight.checked = false;" name="rotateB" id="rotatesLeft" name="button"><a1 onclick="showTitle(id, style.display);" id="rotateLeftSymbol">⟲</a1>
      <input class="mobileControlsElm" type="checkbox" oninput="rotatesLeft.checked = false;" name="rotateB" id="rotatesRight"  name="button"><a1 onclick="showTitle(id, style.display);" id="rotateRightSymbol">⟳</a1>
      <!-- <button class="mobileControlsElm" onclick="state.shift = true;"><==></button> -->
      <input type="checkbox" id="selectMultiple" class="mobileControlsElm" onchange="state.shift = true;"><a1 onclick="showTitle(id, style.display);" id="selectMultipleSymbol">⇧</a1>
    </a>
  </p>
    <input class="mobileControlsElm" type="checkbox" id="scrollable" name="button"><a onclick="showTitle(id, style.display);" id="swipeSymbol">scroll</a>
</p2>
<div id="tileElements">
  <div id="rotateLeftTitle" style="left: -143px; top: 30px; display: none;" class="speech top">
    Teil pro klick um 90° nach links verschieben 
  </div>
  <div id="rotateRightTitle" style="left: 1px; top: 30px; display: none;" class="speech top">
    Teil pro klick um 90° nach rechts verschieben 
  </div>
  <div id="selectMultipleTitle" style="left: 102px; top: 30px; display: none;" class="speech top">
    Mehrfachauswahl durch Klicken auf Teile und Teile abtrennen durch Bewegen eines der ausgewählen Teile
  </div>
  <div id="swipeTitle" style="left: 102px; top: 30px; display: none;" class="speech top">
    Scrollen nach einmal swipen ermöglichen (bis nicht mehr aktiviert und einmal geswiped)
  </div>
</div>
<style>
  .mobileControlsElm {
    width: 44;
    height: 44;
    top: 7px;
  }
</style>
<div id="settings" style="display: none;">
  <h2 id="modeHeadline">Modus: </h2>
  <select onchange="modeSelected(value);" id="modeSelection">
    <option value="traditional">traditionell</option>
    <option value="exchange">austauschen</option>
    <option value="schieben">nur schieben</option>
  </select>
  <br>
  <b style="font-size: 25px;" id="modeSettingsHeading">modusspezifische Einstellungen: </b>
  <div id="traditionalSettings">
    <br>
    <input id="clipOptionsSound" checked="true" type="checkbox"> akustisches Feedback (Audio bei Verbindungsmöglichkeiten)
    <a id="vibrateA">
      <br>
      <input id="vibrate" type="checkbox"> haptisches Feedback (bei neuer Verbindungsmöglichkeit vibrieren)
    </a>
    <br>
    <input id="automaticTileSelectionReset" checked="true" type="checkbox"> automatisch Teile abwählen
    <br>
    <p style="margin-bottom: 6px;" id="rotateTilesP">
    <input id="rotateTiles" onchange="if (checked) rotateTilesAdaptionSettings.style.display = 'none'; else {rotateTilesAdaptionSettings.style.display = 'inline'; größeAnpassenX.value = sizeBefore.x; größeAnpassenY.value = sizeBefore.y}" checked="true" type="checkbox"> drehe Teile
    <a id="rotateTilesAdaptionSettings">
      <br>
      <input type="radio" id="bAdaptAmount" onchange="if (checked) adaptTileAmount(true);" name="adaptionStyle"> Anzahl Puzzleteile anpassen
      <a style="display: none;" id="adaptAmountSettings">
        <br>
        <input id="minTileAmount" oninput="adaptTileAmount();" value="16" placeholder="min. Anzahl" type="text">
        <br>
      </a>
      <br>
      <input type="radio" id="adaptImgSize" onchange="if (checked) zuAngepassterBildschirmgröße(false, true);" checked="true" name="adaptionStyle"> Größe Bild anpassen
    </a>
    </p>
    <input id="markWrong" style="accent-color: red;" type="checkbox" > markiere nicht passende
    <br>
    Art der Verteilung der Teile: 
    <select onchange="shuffleStyleVisibilities(value);";  id="shuffleStyle">
      <option value="overlapTiles">Teile verstreuen und überlappen lassen</option>
      <option value="listTiles">Teile nebeneinander auflisten</option>
      <option value="nextToEachOther">Teile mit Abstand nebeneinander legen</option>
    </select>
    <br>
    <br>
    <h2 id="shuffleHeadline">Einstellungen zu der Verteilung der Teile:</h2>
    <a style="display: none" id="aEmptyTileBar">
      <br>
      <input id="emptyTileBar" onchange="if (checked) emptyTileBarSettings.style.display = 'inline'; else emptyTileBarSettings.style.display = 'none';" type="checkbox">mit leerer Liste starten
      <a style="display: none;" id="emptyTileBarSettings">
        <br>
        dabei folgendermaßen die Teile mischen: 
        <br>
        <select onchange="if (value == 'nextToEachOther') tilesGapS.style.display = 'inline'; else tilesGapS.style.display = 'none';" id="shuffleStyleBar">
          <option value="overlapTiles">Teile verstreuen und überlappen lassen</option>
          <option value="nextToEachOther">Teile mit Abstand nebeneinander legen</option>
        </select>
      </a>
      <br>
      <a>
    <div style="display: none;" id="listTilesS">
      <br>
      <br>
      <input type="checkbox" checked="true" onchange="backToBarVis(checked)"; id="BackToBarB"> Buttons für Zurückführung der Teile in die Leiste unten
      <br>
      <div id="backToBarBSize">
        <input id="backToBarBWidth" oninput="changeBackToBarB('width', value)" type="range"> Breite der Buttons
        <br>
        <input id="backToBarBHeight" oninput="changeBackToBarB('height', value)" type="range"> Höhe der Buttons
      </div>
      <br>
      <input type="range" oninput="changeTileBarHeight(value);" min="25" id="tileBarHeight"> <a id="tileBarHeightText">Höhe der Leiste</a>
      <button onclick="changeTileBarHeight(lengthPerTeil.edit.y + 10);" id="resetBarSize">reset</button>
      <div id="autoSelectTileBarP">
        <input type="checkbox" checked=""true id="autoSelectTileBar"> automatisch nächstes Element in Auflistung anwählen
      </div>
    </div>
    <div id="tilesGapS" style="display: none;">
      <br>
      <input id="tilesGap" oninput="gapSizeChanged(value);" value="55" type="text">
      <br>
      <br>
      <canvas id="gapCanvas"></canvas>
      <br>
      <input id="fillScreenTileGap" onchange="if (checked) aScrollXTileGap.style.display = 'none'; else aScrollXTileGap.style.display = 'inline';" checked="true" type="checkbox"> Bildschirm füllen
      <br>
      <a style="display: none" id="aScrollXTileGap">
        <input id="tilesXTileGap" placeholder="Teile nebeneinander" type="text">
        <br>
      </a>
    </div>
    <p id="scrollOnBlancP"><input id="scrollOnBlanc" type="checkbox"> scrollen auf leerem Hintergrund erlauben</p>
  </div>
  <div id="exchangeSettings" style="display: none">
  <p id="swipeSteuerungP"><input type="checkbox"  id="swipeSteuerung"> beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen</p>
  </div>
  <p id="schiebenSettings">
    <br>
    <strong style="font-size:15px;">mit der Anzahl der Schiebevorgänge, die der PC vornimmt, kann die Schwierigkeit am leichtesten kontrolliert werden</strong>
    <br>
    <input type="text" id="anzahlVerschieben" placeholder="Male PC verschieben">
    <br>
    <input type="checkbox" onchange="if (checked) {anzahlVerschieben.style.display = 'none'; innerHTML.replace('_', ''); } else {anzahlVerschieben.style.display = 'inline'; innerHTML += '__'}" id="richtigeCheck"> verschieben, bis höchstens<input type="text" style="width:25px;" id="anzahlRichtige" value="10"> an origineller Stelle
    <br>
    <input type="checkbox" id="zurrückVermeiden" onchange="if (checked) anzahlVerboten.style.display = 'inline'; else anzahlVerboten.style.display = 'none';" checked="true"> <font size="5">leeres Feld 2 Mal an selber Stelle nach <input type="text" id="anzahlVerboten" value="3" style="width: 25px;"> Malen verboten (einfacher, weil immer direkt nebeneinander)</font>
    <!-- <input type="checkbox" id="difficultSchieben"> niemals eine verschiebng rückgängig machen (schwierig, weil immer viel verändert wird) -->
  </p>
  <a style="display: none;" id="turnsHistoryS">
    <br>
    <div id="movementPlayer" style="display: none;">
      <input onchange="changeMovementPlayerVis(checked);" type="checkbox"><b>Züge des PCs ansehen</b>
      <div id="innerMovementPlayer" style="display: none;">
        <br>
        <input id="distinctMovement" onchange="movementStepsChanged(checked);" checked="true" onchange="" type="checkbox"> kürzeste Lösung
        <br>
        <button id="movementDirectionLeft" onclick="changeMovementDirection(-1);"><<</button>
        <button onclick="playMovementPos(objMovementPlayer.position - 1);"><</button>
        <button id="movementPlayButton" onclick="playPauseMovement();">play</button>
        <button onclick="playMovementPos(0);">⟲</button>
        <button onclick="playMovementPos(objMovementPlayer.position + 1);">></button>
        <button id="movementDirectionRight" style="background-color: hsla(180, 100%, 50%, 1);" onclick="changeMovementDirection(1);">>></button>
        <br>
        <input id="movementPosition" oninput="playMovementPos(value);" min="0" type="range"> Position
        <button onclick="playMovementPos(getPlayerPosition());">zu Ihrer Positionierung (falls vorhanden)</button>
        <br>
        <b>Geschwindigkeit</b>
        <br>
        schnell <input min="155" value="500" max="1000" id="movementPlayerSpeed" type="range"> langsam
        <button onclick="movementPlayerSpeed.value = 500;">zurücksetzen</button>
        <br>
        <canvas id="movementPlayerTextur"></canvas>
      </div>
      <br>
    </div>
    <input onchange="if (checked) {userMovementPlayer.style.display = 'inline'; generalSettings.style.display = 'none';} else {userMovementPlayer.style.display = 'none'; generalSettings.style.display = 'inline';}" type="checkbox"> <b>zu vorherigen Zug zurückkehren:</b>
    <a style="display: none;" id="userMovementPlayer">
      <br>
      <button onclick="if (userMovement.index - 1 >= 0) {userMovement.index--; playMovementPos(userMovement.index, null, null, userMovement.moves);}"><</button>
      <input id="playerMovementSlider" oninput="playMovementPos(value, null, null, userMovement.moves);" min="0" max="0" type="range">
      <button onclick="if (userMovement.index < userMovement.moves.length) {userMovement.index++; playMovementPos(userMovement.index, null, null, userMovement.moves);}">></button>
      <br>
      <input id="goBackAsTurns" type="checkbox"> als extra Züge werten
    </a>
  </a>
  <a2 id="generalSettings">
  <h2>allgemeine Einstellungen: </h2>
    <input type="checkbox" onchange="if (checked) rightMarkerSettings.style.display = 'inline'; else rightMarkerSettings.style.display = 'none'; layout(true);" id="richtigPlazierte" style="accent-color: green;" checked="true"> markiere richtig plazierte
    <!-- <h3>general</h3> -->
    <a id="rightMarkerSettings">
      <br>
      <input type="range" step="0.01" value="1" oninput="layout(true);" min="0.01" max="1" id="rightMarkerRadius"> radius von Mitte (in %)
      <br>
  <input min="0.01" max="1" step="0.01" value="0.3" oninput="layout(true)" id="rightMarkerTransparence" type="range"> Transparenz (in %)
  </a>
  <br>
  <input type="checkbox" id="raender" onchange="if (checked) randSettings.style.display = 'inline'; else randSettings.style.display = 'none'; if (preview.src != '') layout(true, true);"> <font size="5"> zeige Ränder</font>
  <p id="randSettings">
    <br>
    <input type="range" min="1" value="13" oninput="randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - value; layout();" id="breiteRand"> Breite des Randes
    <br>
    <input type="range" min="0" value="0" oninput="layout();" id="randPosition"> Position des Randes
  </p>
  <br>
  <!-- <input type="checkbox" onchange="if (checked == true) {schiebenSettings.style.display = 'inline'; swipeSteuerungP.style.display = 'none';} else {schiebenSettings.style.display = 'none'; swipeSteuerungP.style.display = 'inline';}" id="schieben"> <font size="5">nur schieben</font> -->
  <br>
  <input id="reloadWhenFinished" onchange="localStorage.setItem('reloadWhenFinished', checked)" type="checkbox">Lade die Seite automatisch neu, kurz nachdem das Puzzle fertig ist
  <br>
  <button type="button" id="aufgebenId" onclick="showCurrentStats(modeSelection.value);" name="button">vorläufige bzw. beste Ergebnis ansehen</button>
  <br>
  <div style="display: none;" id="videoControls">
    <h3>video controls</h3>
    <div id="timeChangeDiv">
    <input id="loop" checked="true" onchange="if (checked) stopAtEndP.style.display = 'none'; else stopAtEndP.style.display = 'inline'; playPauseVideo('play');" type="checkbox"> Wiederholen
    <a id="stopAtEndP"><input id="stopAtEnd" type="checkbox"> am Ende stoppen</a>
    <br>
    beginne bei <input type="text" id="loopBeginning"> <button onclick="loopBeginning.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100);">nimm aktuelle Zeit</button> und ende bei <input id="loopEnding" type="text"> <button onclick="loopEnding.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100);">nimm aktuelle Zeit</button>
    <br>
    <button onclick="video.currentTime -= 10;"><<</button>
    </div>
    <button onclick="playPauseVideo(innerHTML);" id="playVideo">pause</button>
    <div id="timeChangeDiv">
    <button onclick="video.currentTime += 10;">>></button>
    <input oninput="video.currentTime = value; playPauseVideo('pause');" step="0.01" type="range" id="videoPosition" min="0">
    <a id="timeText"></a>
  </div>
</div>
<p id="showOriginalP" style="display:none">
  <input id="showOriginal"  onchange="originalDisplayChanged(checked)" type="checkbox"> Original anzeigen
  <br>
  <img style="display: none;" id="preview">
  <canvas style="display: none;" id="videoPreview"></canvas>
</p>
</a2>
</div>
<br>
<button type="button" id="removeTilesFinishedB" style="display: none; font-size: 33px" onclick="shufflePuzzle();" name="button">Fertig</button>
<a id="tileStatusOptions" style="display: none; position: fixed; background-color: rgba(205, 218, 199, 0.77); border-radius: 5px;">
<input type="radio" id="pRemoveTile" checked="true" style="accent-color: red;" name="tileStatus"> Teil löschen
<input type="radio" id="doNotMoveTile" style="accent-color: blue;" name="tileStatus"> Teil beim Mischen nicht bewegen
</a>
<br>
<br>
<button onclick="expandSide('top');" style="height: 3vw;" class="expandButtons" id="expandTop">+</button>
<canvas onmousedown="mouseDown(true);" onmouseup="mouseUp();" style="border-width: 3px; border-style: solid;" id="textur" width="1" onclick="canvasClicked('elm');" height="1"></canvas>
<button onclick="expandSide('right');" style="width: 3vw;" class="expandButtons" id="expandRight">+</button>
<button onclick="expandSide('left');" style="width: 3vw;" class="expandButtons" id="expandLeft">+</button>
<br>
<button class="expandButtons" style="height: 3vw;" onclick="expandSide('bottom');" id="expandBottom">+</button>
<canvas id="tileSelectionCanvas" onmousedown="mouseDown(true);" onmouseup="mouseUp();" width="1" height="1"></canvas>
<div class="expandButtons" id="backToBarButtons">
</div>
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.3'" id="scrollTileSelectionRight" onclick="scrollTileSelection(1);">
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.3'" id="scrollTileSelectionLeft" onclick="scrollTileSelection(-1);">
<style>
  #tileSelectionCanvas {
    /* position: -webkit-sticky; */
    position: fixed;
    bottom: 0px;
    overflow: hidden;
    background-color: hsla(0, 0%, 64%, 0.77);
    touch-action: none;
  }
  #scrollTileSelectionRight {
    position: fixed;
    right: 0px;
    opacity: 0.3;
    display: none;
  }
  #scrollTileSelectionLeft {
    position: fixed;
    left: 0px;
    opacity: 0.3;
    transform: rotate(180deg);
    display: none;
  }

  .backToTileB {
    position: fixed;
  }
  .expandButtons {
    display: none;
    font-size: 55px;
    position: absolute;
  }
</style>
<style name="bubbleStyle">
  /* (A) SPEECH BOX */
  .speech {
    /* (A1) FONT */
    font-family: arial, sans-serif;
    /* font-size: 0.5em; */
    /* font-size: 0.7em; */
    /* font-size: 1vw; */
    font-size: 25px;
  
    /* (A2) COLORS */
    color: #fff;
    background: blue;
  
    /* (A3) DIMENSIONS + POSITION */
    position: absolute;
    padding: 20px;
    border-radius: 10px;
    max-width: 320px;
    z-index: 2;
  }
  
  /* (B) ADD SPEECH "CALLOUT TAIL" */
  /* (B1) USE ::AFTER TO CREATE THE "TAIL" */
  .speech::after {
    /* (B1-1) ATTACH TRANSPARENT BORDERS */
    content: "";
    border: 20px solid transparent;
  
    /* (B1-2) NECESSARY TO POSITION THE "TAIL" */
    position: absolute;
  }
  
  /* (B2) BOTTOM "CALLOUT TAIL" */
  .bottom.speech::after {
    /* (B2-1) DOWN TRIANGLE */
    border-top-color: blue;
    border-bottom: 0;
  
    /* (B2-2) POSITION AT BOTTOM */
    bottom: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C) DIFFERENT TAIL POSITIONS */
  /* (C1) TOP */
  .top.speech::after {
    /* (C1-1) UP TRIANGLE */
    border-bottom-color: blue;
    border-top: 0;
  
    /* (C1-2) POSITION AT TOP */
    top: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C2) LEFT */
  .left.speech::after {
    /* (C2-1) LEFT TRIANGLE */
    border-right-color: blue;
    border-left: 0;
  
    /* (C2-2) POSITION AT LEFT */
    left: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (C3) RIGHT */
  .right.speech::after {
    /* (C3-1) RIGHT TRIANGLE */
    border-left-color: blue;
    border-right: 0;
  
    /* (C3-2) POSITION AT RIGHT */
    right: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (X) DOES NOT MATTER - SPACERS */
  /* .speech, .circular { margin: 50px 0 0 50px; } */
  body { padding-bottom: 100px; }
  
  </style>
<script>
    window.onbeforeunload = function(){
    console.log("Leave Website");
      return 'Are you sure you want to leave?';
  };
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
    // tileSelectionCanvas.style.position = "fixed";
  } else {
    var gerät = "PC"
    console.log("PC");
    swipeSteuerungP.style.display = "none";
    scrollOnBlancP.style.display = "none";
    vibrateA.style.display = "none";
  }
  gapSizeChanged(tilesGap.value);
  mobileControls.style.display = 'none';
  reloadWhenFinished.checked = JSON.parse(localStorage.getItem("reloadWhenFinished"));
  anzahlVerschieben.value = anzahlX.value*anzahlY.value;
  aufgebenId.style.display = "none";
  // schiebenSettings.style.display  = "inline"
  randSettings.style.display = "none";
  schiebenSettings.style.display = "none";
  größeAnpassenX.max = window.innerWidth
  größeAnpassenY.max = window.innerHeight
  var canvas = textur.getContext('2d');
  // section 1: mainly change element syle and visibility
  function shuffleStyleVisibilities(value) {
    if (value == 'nextToEachOther') tilesGapS.style.display = 'inline'; 
    else tilesGapS.style.display = 'none';
    if (value == "listTiles") aEmptyTileBar.style.display = "inline";
    else aEmptyTileBar.style.display = "none";
  }
  function backToBarVis(checked) {
    if (checked) {
      backToBarButtons.style.display = 'inline';
      backToBarBSize.style.display = 'inline';
    }
    else {
      backToBarButtons.style.display = 'none';
      backToBarBSize.style.display = 'none';
    }
  }
  function showTitle(id, display) {
    id = id.replace('Symbol', 'Title');
    if (document.getElementById(id).style.display == "inline") document.getElementById(id).style.display = "none";
    else {
      document.getElementById(id).style.display = "inline";
      setTimeout(function () {
        document.getElementById(id).style.display = "none";
      }, 5000);
    }
  }
  function changeSettingsVis(vis) {
    if ((settings.style.display == 'none' || vis == "inline") && vis != "none") {
      settings.style.display = 'inline'; 
      wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
    }
    else {
      settings.style.display = 'none';
      canvas = textur.getContext('2d');
      if (wrongPosition && !state.changedPos) positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
      state.changedPos = false; 
    }
    texturTop = textur.getBoundingClientRect().top;
  }
  function mirrorCanvas(checked) {
    if (checked) textur.style = "-webkit-transform: scaleX(-1); transform: scaleX(-1);";
    else {
      textur.style.transform = "";
      textur.style.webkitTransform = "";
    }
  }
  // change visibility of player of PC movement in schieben mode
  function changeMovementPlayerVis(checked) {
    if (checked) {
      innerMovementPlayer.style.display = 'inline'; 
      playMovementPos(getPlayerPosition(true));
      texturTop = textur.getBoundingClientRect().top;
      movementPlayer.scrollIntoView();
      window.scroll(0, scrollY);
    }
    else {
      innerMovementPlayer.style.display = 'none';
      texturTop = textur.getBoundingClientRect().top;
      canvas = textur.getContext('2d');
    }
  }
  // change size of + buttons for backToBar
  function changeBackToBarB(side, value) {
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var button = document.getElementsByClassName('backToTileB')[i];
      button.style[side] = value + 'px';
      button.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2 + 'px';
      button.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(button.style.width)/2 + 'px';
    }
  }
  // change play direction of movement player (player which shows the moves the PC did in schieben mode)
  function changeMovementDirection(direc) {
    objMovementPlayer.direc = direc;
    movementDirectionLeft.style.backgroundColor = '';
    movementDirectionRight.style.backgroundColor = '';
    if (direc == -1) movementDirectionLeft.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
    else movementDirectionRight.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
  }
  function changeTileBarHeight(value) {
    tileSelectionCanvas.style.height = JSON.parse(value) + 'px';
    // TODO: handle sides seperately
    tileSelectionBar.pictureSize = {width: JSON.parse(value - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)};
    lengthPerTeil.sizeAdapted = {x: tileSelectionBar.pictureSize.width, y: tileSelectionBar.pictureSize.height};
    tileSelectionCanvas.width = 10000;
    layout();
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
      backToBarBWidth.value = lengthPerTeil.sizeAdapted.x/7;
      backToBarBHeight.value = lengthPerTeil.sizeAdapted.y/7;
      elm.style.width = backToBarBWidth.value;
      elm.style.height = backToBarBHeight.value;
      elm.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2;
      elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
    }
    backToBarBWidth.max = lengthPerTeil.sizeAdapted.x;
    backToBarBHeight.max = lengthPerTeil.sizeAdapted.y;
    scrollTileSelectionRight.style.bottom = lengthPerTeil.sizeAdapted.y/4 + "px";
    scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/4 + "px";
    scrollTileSelectionLeft.height = lengthPerTeil.sizeAdapted.y/2;
    scrollTileSelectionRight.height = lengthPerTeil.sizeAdapted.y/2;
    if (gerät == "Handy") {
      scrollTileSelectionRight.style.bottom = lengthPerTeil.sizeAdapted.y/2 + "px";
      scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 + "px";
    }
  }
  function originalDisplayChanged(checked) {
    startPause('viewOriginal');
    if (checked) stats.viewOriginal.times++;
    if (checked) {
      if (sourceIsPicture.checked) preview.style.display = "inline";
      else videoPreview.style.display = "inline";
      showOriginal.scrollIntoView();
    }
    else {
      if (sourceIsPicture.checked) preview.style.display = "none";
      else videoPreview.style.display = "none";
    }
  }
  // section 2: actions followed by element change/user input
  function changeAdaptedSizeMax(width, height) {
    textur.width = width// + 111;
    textur.height = height// + 111;
    if (window.innerWidth > width || screenIsMax.checked) größeAnpassenX.max = window.innerWidth;
    else größeAnpassenX.max = width;
    if (window.innerHeight > height || screenIsMax.checked) größeAnpassenY.max = window.innerHeight;
    else größeAnpassenY.max = height;
    größeAnpassenX.value = width;
    größeAnpassenY.value = height;
    zeigeGröße();
  }
    // back to bar to the right of the selected tile in the tileBar
    function generalBackToBar(elm) {
    if (tileSelectionBar.tiles.length != anzahlX.value*anzahlY.value) {
      state.backToBar = tileSelectionBar.selectedTile.i + 1; 
      elm.style.backgroundColor = 'red';
      tileSelectionBar.selectedTile = undefined;
    }
  }
  function expandSide(side) {
    // if (!state.sideExpanded && aufgebenId.style.display == 'inline') {
    if (['right', 'left'].includes(side)) textur.width += lengthPerTeil.edit.x*3;
    if (['bottom', 'top'].includes(side)) textur.height += lengthPerTeil.edit.y*3;
    expandRight.style.left = textur.getBoundingClientRect().right + scrollX + 'px';
    expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY; + 'px';
    expandBottom.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandTop.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandRight.style.height = textur.height + 6; 
    expandLeft.style.height = textur.height + 6; 
    if (['top', 'left'].includes(side)) {
      var moveDirection = "x";
      if (side == "top") moveDirection = "y";
      for (const position of positions.wrong) {
        position.edit[moveDirection] += lengthPerTeil.edit[moveDirection]*3;
      }
    }
    layout(true, true);
  //   setTimeout(() => {
  //     state.sideExpanded = false;
  //   }, 1000);
  // }
  //   state.sideExpanded = true;
  }
  function showCurrentStats(mode) {
    if (mode == "traditional") alert(`Ihre vorläufigen Daten: Sie haben ${stats.turns} mal Teile verbunden (es ist mit mindestens ${anzahlX.value*anzahlY.value - 1} Malen möglich) und ${stats.unclipped} mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} mal ein Teil gedreht.`);
    if (mode == "exchange") alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen (Es ist mit " + (positions.wrong.length - stats.preOrdered) + "Zügen möglich! Werden Sie es wohl schaffen?)");
    if (mode == "schieben") alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen (Es ist mit " + distinctMoves.length + "Zügen oder weniger möglich! Werden Sie es wohl schaffen?)");
    if (mode != "traditional" && stats.preOrdered) alert(`Bedenken Sie jedoch, dass Sie von den ${stats.highestRight.right} Richtigen von Anfang an ${stats.preOrdered} Teile von den insgesamt ${positions.wrong.length} Teilen an der richtigen Position hatten!`);
    alert(`Zudem haben Sie bis jetzt ${stats.viewOriginal.times} mal für insgesamt ${stats.viewOriginal.time} (Milli-) Sekunden auf das Originalbild geguckt und bis jetzt insgesant ${stats.completionTime} mit diesem Puzzle verbracht.`.replace('undefined', '0'));
  }
  function zuBildschirmgröße() {
    größeAnpassenX.value = window.innerWidth;
    größeAnpassenY.value = window.innerHeight;
    zeigeGröße();
  }
  // Seitenverhältnisse des Bildes anpassen
  function zuAngepassterBildschirmgröße(noShowing, storeBefore) {
    if (storeBefore) {
      sizeBefore = {x: größeAnpassenX.value, y: größeAnpassenY.value};
      anzahlX.value = amountBefore.x; 
      anzahlY.value = amountBefore.y;
      adaptAmountSettings.style.display = 'none';
    }
    var referenceSize = originalSize;
    if (!screenIsMax.checked) referenceSize = {width: JSON.parse(JSON.stringify(größeAnpassenX.value)), height: größeAnpassenY.value};
    else referenceSize = {width: window.innerWidth + 1, height: window.innerHeight + 1};
    if (window.innerWidth < referenceSize.width && window.innerHeight < referenceSize.height) {
      größeAnpassenX.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
    }
    else {
      größeAnpassenX.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
    }
    if (!noShowing || noShowing == "repeat") zeigeGröße(true);
    if (screenIsMax.checked) {
      preventAutomaticZoom.content = `width=${größeAnpassenX.value}, height=${größeAnpassenY.value}, initial-scale=1.0, maximum-scale=1.0, user-scalable=0`;
      if (!noShowing) zuAngepassterBildschirmgröße("repeat");
    }
  }
  function zuOptimalerBildschirmgröße() {
    größeAnpassenX.value = preview.width;
    größeAnpassenY.value = preview.height;
    while (größeAnpassenX.value > window.innerWidth || größeAnpassenY.value > window.innerHeight) {
      größeAnpassenX.value--;
      größeAnpassenY.value--;
    }
    zeigeGröße();
  }
  function zeigeGröße(adapted, onInput) {
    if (größeAnpassenX.value != größeAnpassenY.value && !state.loadImage) bAdaptAmount.checked = true;
    if (state.loadImage && !adapted) zuAngepassterBildschirmgröße();
    delete state.loadImage;
    if (bAdaptAmount.checked && !adapted && !onInput) {
      adaptTileAmount();
      if (!getSizeTileAmoutAdaption()) adaptImgSize.checked = true;
    }
    textur.width = größeAnpassenX.value;
    textur.height = größeAnpassenY.value
    // canvas.clearRect(0, 0, textur.width, textur.height);
    if (preview.src == "") {
    canvas.fillStyle = "blue";
    canvas.fillRect(0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  else {
    canvas.drawImage(document.getElementById('preview'), 0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  }
  function playPauseVideo(innerHTML) {
    if (innerHTML == "play") {
      video.play();
      playVideo.innerHTML = 'pause';
    } 
    else {
      video.pause();
      playVideo.innerHTML = 'play';
    }
  }
  function modeSelected(value) {
    if (value == "traditional") zeigeGröße();
    if (value == "exchange") modeSettingsHeading.style.display = 'none';
    else modeSettingsHeading.style.display = 'inline';
    traditionalSettings.style.display = 'none';
    exchangeSettings.style.display = 'none';
    schiebenSettings.style.display = 'none';
    document.getElementById(value + 'Settings').style.display = 'inline';
  }
  var originalSize = {width: 0, height: 0};
  function gapSizeChanged(value) {
    gapCanvas.width = 100 + JSON.parse(tilesGap.value);
    gapCanvas.height = 100;
    var gCanvas = gapCanvas.getContext('2d');
    gCanvas.clearRect(0, 0, gCanvas.width, gCanvas.height);
    gCanvas.fillStyle = 'red';
    gCanvas.fillRect(0, 0, 50, 50);
    gCanvas.fillRect(50 + JSON.parse(tilesGap.value), 0, 50, 50);
  }
    // create the puzzle
    function create() {
    if (document.getElementById('preview').src == '' && video.src == '' && !pMediaStream) alert('Bitte laden Sie ein Bild oder ein Video bevor Sie auf diesen Button klicken um ein Puzzel zu erstellen!') 
    else {
      if (modeSelection.value != "traditional") shuffleStyle.value = "none";
      if (modeSelection.value == "exchange") doNotMoveTile.checked = true;
      if (screenIsMax.checked) preventAutomaticZoom.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
      positions = {right: [], wrong: []};
      if (modeSelection.value == "traditional") {
        positions.layoutOrder = new Array(anzahlX.value*anzahlY.value);
        for (var i = 0; i < positions.layoutOrder.length; i++) {
          positions.layoutOrder[i] = i;
        }
      }
      removeTilesFinishedB.style.display = 'inline';
      if (modeSelection.value == "schieben") tileStatusOptions.style.display = 'inline';
      showSettings.innerHTML = "Einstellungsmöglichkeiten und Möglichkeit aufzugeben";
      imageSettings.style.display = "none";
      modeSelection.style.display = "none";
      schiebenSettings.style.display = "none";
      rotateTilesP.style.display = "none";
      missing = [];
      if (gerät == "Handy") mobileControls.style.display = "inline";
      if (sourceIsVideo.checked) {
        videoControls.style.display = 'inline';
        videoPosition.max = video.duration;
        settings.style.display = 'inline';
        videoPosition.style.width = window.innerWidth;
        while (timeText.getBoundingClientRect().x < videoPosition.getBoundingClientRect().x + convertStyle(videoPosition.style.width)) {
          videoPosition.style.width = (convertStyle(videoPosition.style.width) - 1) + 'px';
        }
        videoPosition.style.width = (convertStyle(videoPosition.style.width) - 15) + 'px';
        playVideo.style.width = playVideo.getBoundingClientRect().width;
        settings.style.display = 'none';
        if (video.srcObject) {
          for (const elm of timeChangeDiv) {
            elm.style.display = 'none';
          }
        }
      }
      originalSize.width = preview.width;
      originalSize.height = preview.height;
      preview.width = größeAnpassenX.value;
      preview.height = größeAnpassenY.value;
      textur.width = preview.width// + 111;
      textur.height = preview.height// + 111;
      videoPreview.width = größeAnpassenX.value;
      videoPreview.height = größeAnpassenY.value;
      var pAnzahlX = anzahlX.value;
      var pAnzahlY = anzahlY.value;
      if (sourceIsPicture.checked) lengthPerTeil = {original: {x: Math.round(originalSize.width/pAnzahlX), y: Math.round(originalSize.height/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
      else lengthPerTeil = {original: {x: Math.round(video.videoWidth/pAnzahlX), y: Math.round(video.videoHeight/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
      breiteRand.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3;
      randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - breiteRand.value;
      for (var i = 0; i < pAnzahlY; i++) {
        for (var i1 = 0; i1 < pAnzahlX; i1++) {
          if (modeSelection.value == "traditional") {
            var newTile = {original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}};
            if (i1) newTile.original.left = {x: positions.right[i*pAnzahlX + i1 - 1]?.original.x, y: positions.right[i*pAnzahlX + i1 - 1]?.original.y};
            if (i) newTile.original.top = {x: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.x, y: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.y};
            positions.right.push(newTile);
            if (i) positions.right[i*pAnzahlX + i1 - pAnzahlX].original.bottom = {x: newTile.original.x, y: newTile.original.y};
            if (i1) positions.right[i*pAnzahlX + i1 - 1].original.right = {x: newTile.original.x, y: newTile.original.y};
          }
          else {
            positions.right.push({original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}})
          }
          positions.right[positions.right.length - 1].border = [];
          if (i1 == 0) positions.right[positions.right.length - 1].border.push("left");
          if (i1 == pAnzahlX - 1) positions.right[positions.right.length - 1].border.push("right");
          if (i == 0) positions.right[positions.right.length - 1].border.push("top");
          if (i == pAnzahlY - 1) positions.right[positions.right.length - 1].border.push("bottom");
        }
      }
      positions.wrong = JSON.parse(JSON.stringify(positions.right));
      //canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/200, /*yFromPicture*/200, 200, 200, /*xFromPlacement*/0, /*yFromPlacement*/0, 200, 200);
      window.scroll(0, /*96 50*/32);
      if (modeSelection.value == "schieben") {
        alert("Bitte wählen Sie ein Teilstück aus, das entfernt wird. Im besten Fall ist es ein unwichtiger Teil des Bildes!");
        layout(true);
      }
      else removeTile(true);
      // else layout();
      if (sourceIsVideo.checked) canvas.clearRect(0, 0, textur.width, textur.height);
      showSettings.scrollIntoView();
      textur.style.touchAction = "none";
      window.scroll(0, 0);
      changeSettingsVis('none');
    }
    autoScroll = setInterval(function () {
  // up
  if (!scrollable.checked && aufgebenId.style.display == "inline" && (mausy - scrollY < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    window.scroll(scrollX, scrollY - 3);
    mausy -= 3;
}
// right 
if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX + lengthPerTeil.edit.x/2 > window.innerWidth && selected.tiles?.length) {
      window.scroll(scrollX + 3, scrollY);
    }
      if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x + lengthPerTeil.edit.y/2 > window.innerWidth + scrollX) || (modeSelection.value != "traditional" && mausx - scrollX > window.innerWidth - 10))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        window.scroll(scrollX + 3, scrollY);
        mausx += 3;
      }
      // left
      if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX - lengthPerTeil.edit?.x/2 < 0 && selected.tiles.length) {
      window.scroll(scrollX - 3, scrollY);
    }
  if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && (mausx - scrollX < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    window.scroll(scrollX - 3, scrollY);
    mausx -= 3;
}
// down
var pScrollY = scrollY;
    if (shuffleStyle.value == "listTiles") pScrollY -= tileSelectionCanvas.getBoundingClientRect().height;// lengthPerTeil.edit.y - 10;
      if (!scrollable.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.y + lengthPerTeil.edit.y/2 > window.innerHeight + pScrollY - texturTop) || (modeSelection.value != "traditional" && mausy - pScrollY > window.innerHeight - 10))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        window.scroll(scrollX, scrollY + 3);
        mausy += 3;
      }
});
swipeTitle.style.display = "inline";
swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + 20;
swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
swipeTitle.style.display = "none";
modeHeadline.style.display = 'none';
  shuffleHeadline.style.display = 'none';
  }
  function shufflePuzzle() {
    var shuffleStyleBefore = shuffleStyle.value;
    if (emptyTileBar.checked) {
      shuffleStyle.value = shuffleStyleBar.value;
      autoSelectTileBar.checked = false;
    }
    if (modeSelection.value == "schieben" && !selected.tiles.length) alert("Sie müssen mindestens ein Teil ausgeählt haben, das wegfällt, damit Sie schieben können!");
    else {
      var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
      for (var i of selected.tiles) {
        missing.push(JSON.parse(JSON.stringify(positions.wrong[i].edit.x + ' - ' + positions.wrong[i].edit.y)));
        positions.wrong.forEach((position, i1) => {
          for (var direc of ['top', 'right', 'bottom', 'left']) {
            if (positions.wrong[i].border.includes(directionConverter[direc]) && positions.wrong[i].original[direc] && !i1/* && !selected.tiles.includes(getTile(positions.wrong[i].original[direc]))*/) {
              positions.wrong[getTile(positions.wrong[i].original[direc])].border.push(directionConverter[direc]);
            }
            if (position.original[direc]) {
            position.original[direc].degree = 0;// position.edit.degree;
            if (angular.equals(position.original[direc], {x: positions.wrong[i].original.x, y: positions.wrong[i].original.y, degree: 0})) {
              delete position.original[direc].degree;
              delete positions.right[i1].original[direc];
              // delete position.original[direc];
            }
            else delete position.original[direc].degree;
          }
          }
        });
      }
      if (modeSelection.value != "exchange") {
        for (var i = 0; i < positions.wrong.length; i++) {
          if (selected.objTiles.includes(JSON.stringify(positions.wrong[i].edit))) {
            positions.wrong.splice(i, 1);
            positions.right.splice(i, 1);
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
              if (doNotChange[i1] > i) doNotChange[i1]--;
            }
            if (modeSelection.value == "traditional") {
              positions.layoutOrder.splice(i, 1);
              for (var i1 = i; i1 < positions.layoutOrder.length; i1++) {
                positions.layoutOrder[i1]--;
              }
            }
            i--;
          }
        }
      }
      selected.tiles = [];
      removeTilesFinishedB.style.display = 'none';
      state.removeTile = false;
      if (modeSelection.value == "schieben") {
        movement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
        verschiebenPC();
        wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
        setTimeout(function () {
          // create misstingDistinct
          distinctMoves = JSON.parse(JSON.stringify(movement.move));
          var distinctPositions = [];
          var change;
          var firstRunThrough = true;
          playerMovement = movement.move;
          do {
            change = false;
            var leftBeginning = 1;
            for (let i = 0; i < movement.move.length; i++) {
              var move = JSON.stringify(playMovementPos(i, true, true));
            if (distinctPositions.includes(move) || JSON.stringify(movement.startPosition) == move) {
              for (let i1 = leftBeginning; i1 < /*movement.move.length*/i; i1++) {
                if (JSON.stringify(playMovementPos(i1, true, true)) == move && distinctMoves[i1] != undefined && distinctMoves[i] != undefined) {
                  distinctPositions.splice(i1, (i - i1));
                  // distinctMoves.splice(i1, (i - i1));
                  // console.log('lösche ' + i1 + ' bis ' + (i-1));
                  distinctMoves.fill(undefined, i1, i);
                  leftBeginning = i1 + (i - i1);
                  // i1 = i1 + (i - i1);
                  change = true;
                  break;
                }
              }
              }
              if (firstRunThrough) distinctPositions.push(move);
            }
            firstRunThrough = false;
          } while (change)
          distinctMoves = distinctMoves.filter(x => x != undefined);
          if ((Math.abs(distinctMoves[0].x) == Math.abs(distinctMoves[1].x) || Math.abs(distinctMoves[0].y) == Math.abs(distinctMoves[1].y)) && distinctMoves[0].tile == distinctMoves[1].tile) distinctMoves.splice(0, 2);
          positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
          movementStepsChanged(distinctMovement.checked);
          state.redoI1 = undefined;
        }, 500);
        movementPlayer.style.display = 'inline';
        movementPlayerTextur.width = textur.width;
        movementPlayerTextur.height = textur.height;
      }
      else {
      if (modeSelection.value == "traditional") {
        textur.width += 500;
        textur.height += 500;
        positions.wrong.forEach((position, i) => {
          if (shuffleStyle.value != "listTiles" || emptyTileBar.checked) {
            position.edit = {x: Math.round(Math.random()*(textur.width - lengthPerTeil.edit.x)), y: Math.round(Math.random()*(textur.height - lengthPerTeil.edit.y)), degree: 0};
            if (emptyTileBar.checked) tileSelectionBar.tiles.push(i);
          }
          else {
            position.edit = {x: i*(lengthPerTeil.edit.x + 5) + lengthPerTeil.edit.x/2, y: 5 + lengthPerTeil.edit.y/2, degree: 0};
            tileSelectionBar.tiles.push(i);
          }
          position.original = {x: position.original.x, y: position.original.y, degree: [0, 90, 180, -90][Math.round(Math.random()*3)]};
          stats.minimumRotations += Math.abs(position.original.degree/90);
          if (!rotateTiles.checked) position.original.degree = 0;
      });
      if (emptyTileBar.checked) {
        state.modelEmptybar = true;
        setTimeout(function () {
          tileSelectionBar.tiles = [];
          state.modelEmptybar = false;
          layout();
        }, 100);  
      }
    }
    if (shuffleStyle.value == "nextToEachOther") {
        if (isNaN(tilesGap.value) || tilesGap.value == '') tilesGap.value = 55;
        if (isNaN(tilesXTileGap.value) || tilesXTileGap.value == '') tilesXTileGap.value = anzahlX.value;
        var pos = {x: lengthPerTeil.edit.x/2, y: lengthPerTeil.edit.y/2};
        for (let i = 0; i < positions.wrong.length; i++) {
          positions.wrong[i].edit = {x: pos.x, y: pos.y, degree: 0};
          pos.x += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
          if ((pos.x + lengthPerTeil.edit.x/2 > window.innerWidth && fillScreenTileGap.checked) || (!fillScreenTileGap.checked && pos.x > lengthPerTeil.edit.x + (lengthPerTeil.edit.x + JSON.parse(tilesGap.value))*(parseInt(tilesXTileGap.value) - 1))) {
            pos.x = lengthPerTeil.edit.x/2;
            if (pos.x + lengthPerTeil.edit.x/2 > textur.width) textur.width += lengthPerTeil.edit.x + parseInt(tilesGap.value);
            pos.y += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
            if (pos.y + lengthPerTeil.edit.y/2 > textur.height) textur.height += lengthPerTeil.edit.y + parseInt(tilesGap.value);
          }
        }
      }
      for (i = positions.wrong.length - 1; (modeSelection.value == "exchange" || shuffleStyle.value != "overlapTiles") && i > 0; i--) {
        do {
          j = Math.floor(Math.random() * (i + 1));
        } while (doNotChange.includes(j) && j != i && doNotChange.length != positions.wrong.length);
        x = positions.wrong[i].edit;
        if (!doNotChange.includes(i)) {
          positions.wrong[i].edit = positions.wrong[j].edit;
          positions.wrong[j].edit = x;
        }
      }
      stats.preOrdered = "pending";
    }
    if (shuffleStyle.value == "nextToEachOther") tilesGapS.style.display = "none";
    shuffleStyle.value = shuffleStyleBefore;
    doNotChange = [];
    aufgebenId.style.display = "inline";
  showOriginalP.style.display = 'inline';
  shuffleStyle.style.display = 'none';
  tileStatusOptions.style.display = 'none';
  textur.style.touchAction = "none";
  if (modeSelection.value == "schieben") turnsHistoryS.style.display = 'inline';
  // expand textur buttons
  if (modeSelection.value == "traditional") { 
  textur.style.position = "absolute";
  expandBottom.style.width = textur.width + 6; 
  expandTop.style.width = textur.width + 6;  
  // expandTop.style.position = "static";  
  for (const elm of document.getElementsByClassName('expandButtons')) {
    elm.style.display = 'inline';
  }
  textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY + 'px';
  texturTop = textur.getBoundingClientRect().top + scrollY;
  expandLeft.style.left = '0px';
  expandLeft.style.height = textur.height + 6;  
  expandLeft.style.top = textur.getBoundingClientRect().top + scrollY// texturTop;
  textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
  expandTop.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandBottom.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandRight.style.top = texturTop;
  expandRight.style.height = textur.height + 6;  
  expandRight.style.left = textur.getBoundingClientRect().right + scrollX// textur.getBoundingClientRect().x + scrollX + textur.width + 6 + 'px';
  expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY;// texturTop + scrollY + textur.height + 6 + 'px'; 
}
  texturLeft = textur.getBoundingClientRect().left + scrollX;
  if (gerät == "Handy") autoSelectTileBar.checked = false;
  tileSelectionBar.height = lengthPerTeil.edit.y + 10;
  tileBarHeight.max = window.innerHeight - texturTop - lengthPerTeil.edit.y;
  changeTileBarHeight(lengthPerTeil.edit.y + 10);
  tileSelectionCanvas.height = lengthPerTeil.edit.y + 10;
  backToBarBWidth.max = lengthPerTeil.edit.x;
  backToBarBHeight.max = lengthPerTeil.edit.y;
  backToBarBWidth.value = lengthPerTeil.edit.x/7;
  backToBarBHeight.value = lengthPerTeil.edit.y/7;
  if (shuffleStyle.value == "listTiles") {
    selectBackToBarB.style.display = 'inline';
    listTilesS.style.display = 'inline';
    settings.style.display = 'inline';
    tileBarHeight.style.width = window.innerWidth - tileBarHeightText.getBoundingClientRect().width - resetBarSize.getBoundingClientRect().width - 100;
    settings.style.display = 'none';
  }
  else tileSelectionCanvas.style.display = "none";
  scrollTileSelectionRight.style.bottom = lengthPerTeil.edit.y/4 + "px";
  scrollTileSelectionLeft.style.bottom = lengthPerTeil.edit.y/4 + "px";
  if (gerät == "Handy") {
    scrollTileSelectionRight.style.bottom = lengthPerTeil.edit.y/2 + "px";
    scrollTileSelectionLeft.style.bottom = lengthPerTeil.edit.y/2 + "px";
    selectBackToBarB.style.fontSize = '5vh';
    if (shuffleStyle.value == "listTiles") alert('bitte aktivieren Sie "scroll" und zoomen Sie komplett raus, damit das Layout funktioniert wie gedacht.');
    else alert('Sie können durch aktivieren von "scroll" wahrscheinlich noch weiter rauszoomen!');
  }
  if (shuffleStyle.value == "listTiles") {
    scrollTileSelection(0);
    for (var i = 0; i < tileSelectionBar.tiles.length + 1; i++) {
      addElement({class: "backToTileB", innerText: '+', style: `width: ${backToBarBWidth.value}px; height: ${backToBarBHeight.value}; bottom: ${(lengthPerTeil.edit.y + 5)/2 - (backToBarBHeight.value)/2}px; left: ${10 + (5 + lengthPerTeil.edit.x)*(i) - (backToBarBWidth.value)/2}px`, onclick: `posInBarSelected(${i});`}, 'button', 'backToBarButtons');
    }
  }
    if (gerät == "Handy") {
    mobileControls.style.display = 'inline';
    rotateControls.style.display = "inline";
  }
  selected.boolean = false;
  preventAutomaticZoom.content = "";
  window.scroll(0, 0);
  }

  rotateLeftTitle.style.top = rotateLeftSymbol.getBoundingClientRect().bottom + 20;
  rotateRightTitle.style.top = rotateRightSymbol.getBoundingClientRect().bottom + 20;
  selectMultipleTitle.style.top = selectMultipleSymbol.getBoundingClientRect().bottom + 20;
  rotateLeftTitle.style.left = rotateLeftSymbol.getBoundingClientRect().left + rotateLeftSymbol.getBoundingClientRect().width/2 - rotateLeftTitle.getBoundingClientRect().width/2;
  rotateRightTitle.style.left = rotateRightSymbol.getBoundingClientRect().left + rotateRightSymbol.getBoundingClientRect().width/2 - rotateRightTitle.getBoundingClientRect().width/2;
  selectMultipleTitle.style.left = selectMultipleSymbol.getBoundingClientRect().left + selectMultipleSymbol.getBoundingClientRect().width/2 - selectMultipleTitle.getBoundingClientRect().width/2;
  rotateLeftTitle.style.display = "none";
  rotateRightTitle.style.display = "none";
  selectMultipleTitle.style.display = "none";
  swipeTitle.style.display = "inline";
  swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + 20;
  swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
  swipeTitle.style.display = "none";
  emptyTileBar.style.display = "none";
  if (modeSelection.value == "traditional") {
    traditionalModeMobileControls.style.display = 'inline';
  }
  canvas = textur.getContext('2d');
  layout(true, true);
  startPause('completionTime');
}
// #importantUserInputs
// select tiles to remove and move tiles or exchange them depending on the mode
function canvasClicked(calledBy) {
    if (aufgebenId.style.display == "inline" && settings.style.display == "inline") changeSettingsVis('none');
    if (checkSelected() && selected.boolean && modeSelection.value == "exchange" && !state.removeTile) {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
          for (var i1 = 0; i1 < positions.wrong.length; i1++) {
            if (positions.wrong[i1].edit.x/lengthPerTeil.edit.x == selected.position.x && positions.wrong[i1].edit.y/lengthPerTeil.edit.y == selected.position.y) {
              console.log("vertausche " + checkSelected().x + "-" + checkSelected().y + " mit " + selected.position.x + "-" + selected.position.y);
              stats.turns++;
              vertauscheZwei(i, i1);
              i = positions.wrong.length;
              i1 = positions.wrong.length;
            }
          }
        }
      }
      selected.boolean = false;
    }
    else if (modeSelection.value == "schieben" && checkSelected()/* && selected.boolean*/ && missing.length && !state.removeTile) {
      for (var i1 = 0; i1 < missing.length; i1++) {
        pMissing = missing[i1];
        if (possibleMissing.length && pMissing == (checkSelected().x)*lengthPerTeil.edit.x + ' - ' + checkSelected().y*lengthPerTeil.edit.y) {
          moveTile(possibleMissing.filter(x => x.i1 == i1)[0].i, i1);
        }
        else {
        if ((pMissing == (checkSelected().x + 1)*lengthPerTeil.edit.x + ' - ' + checkSelected().y*lengthPerTeil.edit.y) /*right*/ || (pMissing ==(checkSelected().x - 1)*lengthPerTeil.edit.x + ' - ' + checkSelected().y*lengthPerTeil.edit.y)/*left*/ || (pMissing == checkSelected().x*lengthPerTeil.edit.x + ' - ' + (checkSelected().y + 1)*lengthPerTeil.edit.y)/*down*/ || (pMissing == (checkSelected().x*lengthPerTeil.edit.x + ' - ' + (checkSelected().y - 1)*lengthPerTeil.edit.y)/*up*/)) {
          for (var i = 0; i < positions.wrong.length; i++) {
            if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
              possibleMissing.push({i: i, i1: i1});
            }
          }
        }
      }
  }
  if (possibleMissing.length == 1) moveTile(possibleMissing[0].i, possibleMissing[0].i1);
}
    else if (checkSelected() && (modeSelection.value != "schieben"/* || missing*/)) {
      selected.position = {x: checkSelected().x, y: checkSelected().y};
      selected.boolean = true;
    }
    if (checkSelected() && ((!missing.length && modeSelection.value == "schieben") || state.removeTile) && (!lastCoord || JSON.stringify(lastCoord) != JSON.stringify(checkSelected()) || (((state.mouse == "up" && calledBy != "elm") || calledBy == "mouseDown") && JSON.stringify(state.coord) == JSON.stringify(checkSelected())))) {
      removeTile(null, calledBy);
      lastCoord = checkSelected();
    }
    else {
      if (aufgebenId.style.display == "none") layout(true, true);
      else layout(false, true);
    }
  }
  // section 2.1: movementPlayer (player of PC movement in schieben mode)
  var userMovement = {index: 0, moves: []};
  function movementStepsChanged(checked, doNotSetChecked) {
    if (!doNotSetChecked)  distinctMovement.checked = checked;
    if (checked) playerMovement = distinctMoves;
    else playerMovement = movement.move;
    movementPosition.max = playerMovement.length;
  }
  function playPauseMovement() {
    if (movementPlayButton.innerHTML == "play") {
      movementPlayButton.innerHTML = "pause";
      playMovementFunction();
    }
    else movementPlayButton.innerHTML = "play";
  }
  var playerMovement = [];
  function playMovementFunction() {
    if (movementPlayButton.innerHTML == "pause") {
      if (JSON.parse(movementPosition.value) < playerMovement.length || JSON.parse(movementPosition.value) + objMovementPlayer.direc < 0) playMovementPos(JSON.parse(movementPosition.value) + objMovementPlayer.direc);
      else movementPlayButton.innerHTML = "play";
      setTimeout(function () {
        playMovementFunction();
      }, JSON.parse(movementPlayerSpeed.value));
    }
  }
  var objMovementPlayer = {pause: false, position: 0, direc: 1};
  function getPlayerPosition(backToBeginningIfNeeded, easySteps) {
    for (let i = 0; i < playerMovement.length; i++) {
      if (JSON.stringify(playMovementPos(i, true, true)) == JSON.stringify(movement.playerPosition)) {
        return i;
      }
    }
    if (easySteps != undefined) {
      movementStepsChanged(easySteps);
    }
    else {
      movementStepsChanged(false, true);
      getPlayerPosition(false, distinctMovement.checked);
    }
    if (backToBeginningIfNeeded) return 0;
    else return JSON.parse(movementPosition.value);
  }
  var wrongPosition;
  function playMovementPos(position, pReturn, doNotChangeVal, pPlayerMovement) {
    var isUserMovement = pPlayerMovement != undefined;
    if (!pPlayerMovement) pPlayerMovement = playerMovement;
    else {
      if (goBackAsTurns.checked) stats.turns += Math.abs(position - playerMovementSlider.value);
      playerMovementSlider.value = position;
      state.changedPos = true;
      userMovement.index = position;
      setTimeout(() => {
        movement.playerPosition = positions.wrong;
      }, 100);
    }
    if (position < 0) position = 0;
    if (position > pPlayerMovement.length) position = pPlayerMovement.length;
    if (!doNotChangeVal) movementPosition.value = position;
    if (!isUserMovement) positions.wrong = JSON.parse(JSON.stringify(movement.startPosition));
    else positions.wrong = JSON.parse(JSON.stringify(userMovement.startPosition));
    for (let i = pPlayerMovement.length - 1; i >= position; i--) {
      if (isUserMovement) missing[pPlayerMovement[i].i1] = positions.wrong[pPlayerMovement[i].tile].edit.x + ' - ' + positions.wrong[pPlayerMovement[i].tile].edit.y;
      positions.wrong[pPlayerMovement[i].tile].edit.x += pPlayerMovement[i].x;
      positions.wrong[pPlayerMovement[i].tile].edit.y += pPlayerMovement[i].y;
    }
    if (pReturn) return positions.wrong;
    // PC movement player
    if (!isUserMovement) {
      canvas = movementPlayerTextur.getContext('2d');
      objMovementPlayer.position = JSON.parse(position);
    }
    layout(true, true);
  }
  // end section 2.1
    // backTobar button clicked
    function posInBarSelected(i) {
    for (const elm of document.getElementsByClassName('backToTileB')) {
      elm.style.backgroundColor = '';
    }
    if (tileSelectionBar.tiles.length != positions.wrong.length) {
      state.backToBar = i; 
      document.getElementsByClassName('backToTileB')[i].style.backgroundColor = 'red';
    }
    tileSelectionBar.selectedTile = undefined;
    layout();
  }
  // section 2.2: handle input data (picture, video, URL)
  // load selected file
  function readImg(input) {
    var reader = new FileReader();
    stopLiveFeed();
    reader.onload = function (e) {
      if (sourceIsPicture.checked) document.getElementById('preview').setAttribute("src", e.target.result);
      else {
        video.setAttribute("src", e.target.result);
        setTimeout(function () {
          loadImage(video.videoWidth, video.videoHeight);
        }, 1000);
      }
    };
    reader.readAsDataURL(input.files[0]);
    if (input.files[0].type.includes('video')) sourceIsVideo.checked = true;
    else sourceIsPicture.checked = true;
    loadImage();
  }
  var video = document.createElement("video");
  function useURL() {
    if (sourceURL.value.includes('.mp4') || sourceURL.value.includes('.move')) sourceIsVideo.checked = true;
    if (sourceURL.value.includes('.png') || sourceURL.value.includes('.jpg') || sourceURL.value.includes('.jpeg')) sourceIsPicture.checked = true;
    stopLiveFeed();
    if (sourceIsPicture.checked) {
    preview.src = sourceURL.value;
    loadImage();
  }
  else {
    video.src = sourceURL.value;
  }
  }
  function startVideo() {
    video.play();  // start playing
    updateVideo(); //Start rendering
  }
  video.addEventListener('loadeddata', function() {
    startVideo();
    loadImage(video.videoWidth, video.videoHeight);
  }, false);
  var originalSize = {};
  function loadImage(width, height) {
    setTimeout(function () {
      // videoPosition.style.width = window.innerWidth - 33 - timeText.getBoundingClientRect().width - 126.234375*2;
      if (!width) {
        width = preview.width;
        height = preview.height;
      }
      originalSize = {width: width, height: height};
       canvas.drawImage(document.getElementById('preview'), 0, 0);
       if (adaptImgSize.checked && modeSelection.value == "traditional" && rotateTiles.checked) state.loadImage = true;
       changeAdaptedSizeMax(width, height);
    }, 500);
  }
  // end section 2
  // section 3: handle videos

  // returns string with UI time
// @param: pTime: total time in seconds
function getTimeString(pTime) {
  pTime = Math.floor(pTime);
  var sec, mins, hours;
  hours = Math.floor(pTime / 60 / 60);
  mins = Math.floor(pTime / 60) - hours*60;
  sec = pTime - mins*60 - hours*60*60;
  if (sec < 10) sec = '0' + sec; 
  if (mins < 10) mins = '0' + mins; 
  if (hours < 10) hours = '0' + hours;
  return `${hours}:${mins}:${sec}`;
}
// converts time string back into time in seconds
// @param: 
  // value: String with UI time layout
  // id: undefined or loopEnding (value then is time stamp of loop ending)
  function convertTime(value, id){
  var time = 0;
  var sec = value.split(':')[2];
  var mins = value.split(':')[1];
  var hours = value.split(':')[0];
  if (sec < 10) sec = sec[1];
  if (mins < 10) mins = mins[1];
  if (hours < 10) hours = hours[1];
  if (value.split(':')[3]) time += JSON.parse(value.split(':')[3])/100;
    try {
      time += JSON.parse(sec);
      time += JSON.parse(mins)*60;
      time += JSON.parse(hours)*60*60;
      if (time > video.duration || time < 0) console.log(abc);
    }
    catch (e) {
      if (id == 'loopEnding') time = video.duration;
      else time = 0;
    }
  return time;
}
// draw changes in the video on the canvas and changes the current position in the video
function updateVideo(){
    videoPosition.value = video.currentTime;
    timeText.innerHTML = getTimeString(video.currentTime) + ' / ' + getTimeString(video.duration);
    canvas.clearRect(0, 0, textur.width, textur.height);
    for (var i1 = 0; aufgebenId.style.display == "inline" && i1 < positions.wrong?.length; i1++) {
      var i = i1;
      if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
      if (shuffleStyle.value == "listTiles" && tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], false, i, tileSelectionBar.canvas);
      else drawPictureSegment(positions.wrong[i], positions.right[i], false, i);
    }
    if (aufgebenId.style.display != "inline") canvas.drawImage(video,0,0, größeAnpassenX.value, größeAnpassenY.value);
    videoPreview.getContext('2d').drawImage(video, 0, 0, größeAnpassenX.value, größeAnpassenY.value);
    showSelected();
    showClippingOptions();
    if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')  && loop.checked) {
      video.currentTime = convertTime(loopBeginning.value);
      video.play();
    }
    else if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')) {
      if (stopAtEnd.checked) playPauseVideo('pause');
      else if(video.currentTime >= video.duration) playVideo.innerHTML = 'play';
    }
    if (sourceIsVideo.checked) requestAnimationFrame(updateVideo); // wait for the browser to be ready to present another animation fram.
    else video.pause();
}
// section 3.1: live camera
// Prefer camera resolution nearest to 1280x720.
var constraints = { /*audio: true, */video: { width: 1280, height: 720 } };
var pMediaStream;
// stop live feed, so another one can start
function stopLiveFeed() {
  if (pMediaStream) {
    pMediaStream.getTracks().forEach(track => {
      track.stop();
    });
    video.srcObject = undefined;
  }
  // pMediaStream = undefined;
}
// changes camera source
async function changeCamera(index) {
  sourceIsVideo.checked = true;
  stopLiveFeed();
  var Test = await navigator.mediaDevices.enumerateDevices();
  constraints.video.deviceId = Test[index].deviceId;
  navigator.mediaDevices.getUserMedia(constraints)
  .then(function(mediaStream) {
    video.srcObject = mediaStream;
    pMediaStream = mediaStream;
  })
}

// gets available cameras
navigator.mediaDevices.enumerateDevices()
.then(function(devices) {
  devices.forEach( (device, i) => {
    console.log(device.kind + ": " + device.label + " id = " + device.deviceId);
    if (device.kind == "videoinput") {
      opt = document.createElement("option");
      document.getElementById("cameraSelection").options.add(opt);
      opt.text = device.label;
      opt.value = i;
    }
  });
  if (cameraSelection.options.length < 2) cameraSelection.style.display = 'none';
  if (!cameraSelection.options.length) useLiveCam.style.display = 'none';
})
// end section 3
  // scroll TileSelectionBar (translate)
  function scrollTileSelection(direc) {
    var screenScrollX = window.visualViewport.width/lengthPerTeil.sizeAdapted.x*lengthPerTeil.edit.x;
    if (screenScrollX/lengthPerTeil.edit.x > positions.wrong.length) screenScrollX = positions.wrong.length*lengthPerTeil.edit.x;
    tileSelectionBar.leftOffScreenTiles += direc;
    var scrollXBefore = tileSelectionBar.scrollX;
    tileSelectionBar.scrollX += (lengthPerTeil.edit.x + 5)*(direc*(-1));
    if (tileSelectionBar.scrollX >= lengthPerTeil.edit.x + 5) {
      tileSelectionBar.offset = 0;
      tileSelectionBar.scrollX = lengthPerTeil.edit.x + 5;
      tileSelectionBar.leftOffScreenTiles = -1;
    }
    if (tileSelectionBar.scrollX >= 0) scrollTileSelectionLeft.style.display = 'none';
    else scrollTileSelectionLeft.style.display = 'inline';
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX) {
      if (!tileSelectionBar.offset) {
        tileSelectionBar.offset = - (scrollXBefore - (-((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX));
        tileSelectionBar.elmleftBefore = document.getElementsByClassName('backToTileB')[0].style.left;
      }
      tileSelectionBar.scrollX = -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX + 1;
      tileSelectionBar.leftOffScreenTiles = tileSelectionBar.tiles.length - Math.ceil(screenScrollX/lengthPerTeil.sizeAdapted.x) + 1;
    }
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length)) + screenScrollX) scrollTileSelectionRight.style.display = 'none';
    else scrollTileSelectionRight.style.display = 'inline';
    layout(true, true);
    positionBackToTileBarButtons();
  }
  var tileSelectionBar = {canvas: tileSelectionCanvas.getContext('2d'), tiles: [], scrollX: 0, height: 0, leftOffScreenTiles: 0, offset: 0};
  tileSelectionBar.collidesMouse = () => {
    var obj = tileSelectionCanvas.getBoundingClientRect();
    return collides({x: mausx, y: mausy - scrollY + texturTop, width: 1, height: 1}, obj).boolean;
  }
  tileSelectionBar.getTilePosition = (generalPosition) => {
    for (const tile of tileSelectionBar.tiles) {
      if (tile == generalPosition) return tile;
    }
  }
  // get amount of tiles on x and y-axis to equal width and height
  function getSizeTileAmoutAdaption() {
    for (let i = 0; i < 1000; i++) {
      for (let i1 = 0; i1 < 1000; i1++) {
        if (i > 1 && i1 > 1 && !Math.abs(Math.abs(Math.round(größeAnpassenX.value/i)) - Math.abs(Math.round(größeAnpassenY.value/i1))) && i*i1 > minTileAmount.value) {
          return {x: i, y: i1};
        }
      }
    }
  }
  var sizeBefore;
  var amountBefore;
  // adapt amount of tiles on x and y-axis to equal width and height
  function adaptTileAmount(adaptionStyleChanged) {
    if (modeSelection.value == 'traditional' && rotateTiles.checked) {
      adaptAmountSettings.style.display = 'inline';
      amountBefore = {x: anzahlX.value, y: anzahlY.value};
      if (sizeBefore && adaptionStyleChanged) {
        größeAnpassenX.value = sizeBefore.x; 
        größeAnpassenY.value = sizeBefore.y;
        zeigeGröße(true);
      }
      var data = getSizeTileAmoutAdaption();
      if (data) {
        anzahlX.value = data.x;
        anzahlY.value = data.y;
      }
    }
  }
  function addElement(attr, elm, childOf, asElement) {
      var newElement = document.createElement(/*'span'*/elm);
      if (childOf && !asElement) document.getElementById(childOf).appendChild(newElement);
      else if (childOf) childOf.appendChild(newElement);
      else tests.appendChild(newElement);
      for (attrNow of Object.keys(attr)) {
        if (attrNow == 'innerText') newElement.innerText = attr[attrNow];
        else newElement.setAttribute(attrNow/*'style'*/, /*'color:' + word[i].colour*/attr[attrNow]);
      }
    }
  var lengthPerTeil = {};
  var positions = {right: []};
  var finished = false;
  var missing = [];
  var distinctMoves = [];
  function convertDirection(direc, degr) {
    var directions = ['top', 'right', 'bottom', 'left'];
    var direcObj = {top: 0, right: 1, bottom: 2, left: 3};
    while (degr > 0) {
      direc = directions[direcObj[direc] + 1];
      if (!direc) direc = directions[0];
      degr -= 90;
    }
    return direc;
  }
  // section 4: layout
  function showSelectedTile(tile, color) {
    canvas.fillStyle = color;
    canvas.save();
    if (state.removeTile/* && modeSelection.value != "schieben"*/) canvas.translate(positions.wrong[tile].edit.x + lengthPerTeil.edit.x/2, positions.wrong[tile].edit.y + lengthPerTeil.edit.y/2);
    else canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
    canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
    canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.restore();
  }
  function showSelected() {
    for (var tile of selected.tiles) {
      showSelectedTile(tile, "rgba(255, 0, 0, 0.3)");
    }
    for (var tile of doNotChange) {
      showSelectedTile(tile, "rgba(0, 76, 255, 0.3)");
    }
  }
  function showClippingOptions(params) {
    for (var clip of selected.clip) {
      canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
      if (markWrong.checked && (JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) canvas.fillStyle = 'rgba(255, 0, 0, 0.83)';
      canvas.save();
      canvas.translate(clip.x, clip.y);
      // canvas.rotate((positions.wrong[clip.sI].original.degree + 180)*Math.PI/180);
      if (!tileSelectionBar.tiles.includes(clip.i)) canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), clip.width, clip.height);
      canvas.restore();
    }
  }
  function layout(withoutAlert, clear, pReturn, removeTilesScreen) {
    if (state.removeTile) removeTilesScreen = true;
    if (clear && (aufgebenId.style.display == 'inline' || state.removeTile)) canvas.clearRect(0, 0, 10000, 10000);
    if (lengthPerTeil.sizeAdapted) tileSelectionCanvas.width = positions.wrong.length*(lengthPerTeil.edit.x*(lengthPerTeil.edit.x/lengthPerTeil.sizeAdapted.x));
    else tileSelectionCanvas.width = positions.wrong.length*lengthPerTeil.edit.x;
    if (lengthPerTeil.sizeAdapted && (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*tileSelectionBar.tiles.length < window.innerWidth) tileSelectionBar.scrollX = 0;
    richtige = 0;
    for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
      var i = i1;
      if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
      if (!tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i);
    }
    for (var i1 = 0; i1 < tileSelectionBar.tiles.length; i1++) {
      var i = tileSelectionBar.tiles[i1];
      drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i, tileSelectionBar.canvas, i1);
    }
    showClippingOptions();
    showSelected();
    if (stats.highestRight.right < richtige && !withoutAlert) {
      stats.highestRight = {right: richtige, turns: stats.turns};
    }
    if (stats.preOrdered == "pending") stats.preOrdered = richtige;
    if (richtige == positions.wrong?.length && !removeTilesScreen) {
      stopClock.completionTime.running = 0;
      richtige = 0;
      finished = true;
      layout(true);
      finished = false;
      if(!withoutAlert) {
        if (pReturn) return "noChange!";
        if (modeSelection.value == "schieben") alert("Sie haben es in " + stats.turns + " Zügen (man hätte es in " + distinctMoves.length + " Zügen oder weniger schaffen können) und insgesamt " + stats.completionTime + " Minuten geschafft! Zum Umschieben vom Originalbild hat der Computer " + movement.move.length + " Züge benötigt, um es zu zerwuseln. Ob Sie darauf jetzt stolz sein können, müssen Sie selber entscheiden ;)");
        if (modeSelection.value == "exchange") alert(`Sie haben es in ${stats.turns} Zügen und insgesamt ${stats.completionTime} Minuten geschafft! (Sie hätten es in ${positions.wrong.length - stats.preOrdered} Zügen schaffen können.) Dabei haben Sie von Anfang an von den insgesamt ${positions.wrong.length} Teilen ${stats.preOrdered} Teile an der richtigen Position gehabt.`);
        if (modeSelection.value == "traditional") alert(`Super! Sie haben das Puzzle in ${stats.completionTime} Minuten geschafft! Sie haben ${stats.turns} mal Teile verbunden (man schafft es mit mindestens ${anzahlX.value*anzahlY.value - 1} Malen) und ${stats.unclipped} mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} mal ein Teil gedreht. Man hätte es mit mindestens ${stats.minimumRotations} mal drehen schaffen können. `);
        alert(`Zudem haben Sie ${stats.viewOriginal.times} mal für insgesamt ${stats.viewOriginal.time} (Milli-) Sekunden auf das Originalbild geguckt.`.replace('undefined', '0'));
        if (reloadWhenFinished.checked) {
          setTimeout(function () {
            window.location.reload(false);
          }, 3000);
        }
        else alert("Bitte laden Sie die Seite neu, wenn Sie ein weiteres Puzzle erstellen wollen!");
    }
  }
}
  var richtige = 0;
  function drawPictureSegment(position, segmentPosition, removeTilesScreen, i, pCanvas, i1) {
    if (i1 == undefined) i1 = tileSelectionBar.getTilePosition(i);
    if (!pCanvas) pCanvas = canvas;
    else if (!state.modelEmptybar) {
      position.edit = {x: 5 + (lengthPerTeil.edit.x + 5)*i1 + lengthPerTeil.edit.x/2,y: 5 + lengthPerTeil.edit.y/2, degree: 0};
    }
    pCanvas.save();
    if (modeSelection.value == "traditional" && !removeTilesScreen) pCanvas.translate(position.edit.x, position.edit.y);
    else pCanvas.translate(position.edit.x + lengthPerTeil.edit.x/2, position.edit.y + lengthPerTeil.edit.y/2);
    if (pCanvas.canvas.id == "tileSelectionCanvas") {
      pCanvas.translate(tileSelectionBar.scrollX, 0);
      tileSelectionBar.canvas.fillStyle = "red";
      if (tileSelectionBar.selectedTile?.tileI == i) tileSelectionBar.canvas.fillRect(-(lengthPerTeil.edit.x/2) - 5, -(lengthPerTeil.edit.y/2) - 5, lengthPerTeil.edit.x + 10, lengthPerTeil.edit.y + 10);
    }
    pCanvas.rotate(position.original.degree*Math.PI/180);
    if (sourceIsPicture.checked) pCanvas.drawImage(document.getElementById('preview'), /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    else pCanvas.drawImage(video, /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // pCanvas.restore();
    if ((((modeSelection.value != "traditional" && position.edit.x == segmentPosition.edit.x && position.edit.y == segmentPosition.edit.y) || (modeSelection.value == "traditional" && angular.equals(position.original, segmentPosition.original))) && !removeTilesScreen && !finished)) {
      pCanvas.fillStyle = "rgba(0, 255, 0, " + rightMarkerTransparence.value + ")";
      if (richtigPlazierte.checked) {
        // pCanvas.fillRect(position.edit.x + lengthPerTeil.edit.x/2 - (lengthPerTeil.edit.x*rightMarkerRadius.value)/2, position.edit.y + lengthPerTeil.edit.y/2 - (lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
        // pCanvas.save();
        // pCanvas.translate(position.edit.x, position.edit.y);
        // pCanvas.rotate(position.original.degree*Math.PI/180);
        pCanvas.fillRect(-(lengthPerTeil.edit.x*rightMarkerRadius.value)/2, -(lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
      }
      richtige++;
    }
    pCanvas.restore();
    pCanvas.fillStyle = "rgba(0, 0, 255, 0.35)";
    if (raender.checked) {
      pCanvas.save();
      if (modeSelection.value == "traditional" && !state.removeTile) pCanvas.translate(position.edit.x, position.edit.y);
      else pCanvas.translate(position.edit.x + (lengthPerTeil.edit.x)/2, position.edit.y + (lengthPerTeil.edit.y)/2);
      pCanvas.rotate((position.original.degree)*Math.PI/180);
      // if (position.borderincludes("right")) pCanvas.fillRect(position.edit.x - JSON.parse(breiteRand.value) + lengthPerTeil.edit.x - JSON.parse(randPosition.value) - ((lengthPerTeil.edit.x)/2), position.edit.y - ((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y, position.original.degree);
      // if (position.borderincludes("left")) pCanvas.fillRect(position.edit.x + JSON.parse(randPosition.value) - ((lengthPerTeil.edit.x)/2), position.edit.y - ((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y, position.original.degree);
      // if (position.borderincludes("top")) pCanvas.fillRect(position.edit.x - ((lengthPerTeil.edit.x)/2), position.edit.y + JSON.parse(randPosition.value) - ((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, JSON.parse(breiteRand.value), position.original.degree);
      // if (position.borderincludes("bottom")) pCanvas.fillRect(position.edit.x - ((lengthPerTeil.edit.x)/2), position.edit.y - JSON.parse(breiteRand.value) + lengthPerTeil.edit.y - JSON.parse(randPosition.value) - ((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, JSON.parse(breiteRand.value), position.original.degree);
      if (position.border.includes("right")) pCanvas.fillRect((lengthPerTeil.edit.x)/2 - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("left")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2) + JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("top")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2) + JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      if (position.border.includes("bottom")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), ((lengthPerTeil.edit.y)/2) - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      pCanvas.restore();
    }
  }
  // end section 4
  var selected = {boolean: false, position: {x: 0, y: 0}, tiles: [], objTiles: [], clip: []};
  var lastCoord;
  function moveTile(i, i1) {
    console.log("schiebe...");
    possibleMissing = [];
    pMissing = missing[i1];
    stats.turns++;
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i]));
    if (userMovement.index < userMovement.moves.length - 1) {
      userMovement.moves.splice(userMovement.index, userMovement.moves.length - userMovement.index);
    }
    userMovement.moves.push({x: -(JSON.parse(pMissing.split(' - ')[0]) - positions.wrong[i].edit.x), y: -(JSON.parse(pMissing.split(' - ')[1]) - positions.wrong[i].edit.y), tile: i, i1: i1});
    userMovement.index++;
    playerMovementSlider.max = userMovement.moves.length;
    playerMovementSlider.value = userMovement.index + 1;
    positions.wrong[i].edit = {x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0};//.splice(side, 1);
    missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
    selected.boolean = false;
    movement.playerPosition = positions.wrong;
    userMovement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
  }
  var doNotChange = [];
  var possibleMissing = [];
  // select tiles to be removed or ignored
  function removeTile(first, calledBy) {
    if (!first && (!state.tileRemoved || calledBy == "touchmove" || calledBy == "mousemove")) {
      state.tileRemoved = true;
      setTimeout(function () {
        state.tileRemoved = false;
      }, 133);
    positions.wrong.forEach((position, i) => {
      if (position.edit.x/lengthPerTeil.edit.x == checkSelected().x && position.edit.y/lengthPerTeil.edit.y == checkSelected().y) {
        if (pRemoveTile.checked && !selected.tiles.includes(i)) {
          selected.tiles.push(i);
          selected.objTiles.push(JSON.stringify(position.edit));
        }
        else if (doNotMoveTile.checked && !doNotChange.includes(i)) doNotChange.push(i);
        else if (pRemoveTile.checked && selected.tiles.includes(i)) {
          for (var i1 = 0; i1 < selected.tiles.length; i1++) {
            if (selected.tiles[i1] == i) {
              selected.tiles.splice(i1, 1);
              selected.objTiles.splice(i1, 1);
              }
            }
          }
          else if (doNotMoveTile.checked && doNotChange.includes(i)) {
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
            if (doNotChange[i1] == i) {
              doNotChange.splice(i1, 1);
              }
            }
          }
        }
    });
  }
  if (first && modeSelection.value != "schieben") alert("Hier können Sie nun auf die Teile klicken, die Sie nicht im Puzzle haben wollen! Sie können gedrückt halten, um mehrere gleichzeitig anzuwählen!");
    layout(true, true, undefined, true);
    state.removeTile = true;
  }
  // lists coordinates of all entered tiles
  function listCoordinates(tiles) {
    var list = [];
    for (const tile of tiles) {
      list.push(positions.wrong[tile].edit.x + ' - ' + positions.wrong[tile].edit.y);
    }
    return list;
  }
  // PC moving the tiles in schieben mode
  function verschiebenPC() {
    var missingArray = [];
    var workingNumbers = [];
    var maleZurrück = {number: 0, normalSlide: 0};
    for (var i = 0; i < positions.wrong.length; i++) {
      if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i);
    }
    var counter = 0;
    for (var i = 0; (i < /*positions.wrong.length + */JSON.parse(anzahlVerschieben.value) || (richtigeCheck.checked && richtige > anzahlRichtige.value)) && (!zurrückVermeiden.checked || counter < 100000 || counter < anzahlVerschieben.value); i++) {
      var side = workingNumbers[Math.round(Math.random()*(workingNumbers.length - 1))];
      if (!workingNumbers.length) break;
      missing.forEach((pMissing, i1) => {
      try {
      if (!listCoordinates(doNotChange).includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y) && (((zurrückVermeiden.checked && ((missingArray.length < 1 || workingNumbers.length == 0/*positions.wrong[side].edit.x != missingBefore.data.edit.x && positions.wrong[side].edit.y != missingBefore.data.edit.y*/) || ((maleZurrück.number < anzahlVerboten.value && !((maleZurrück.normalSlide/5 + "").includes("."))) || !(missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y)/*missingBefore.data.edit.x != missing.data.edit.x && missingBefore.data.edit.y != missing.data.edit.y*/)))) || !zurrückVermeiden.checked) && ((pMissing == (positions.wrong[side].edit.x + lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y) /*right*/ || (pMissing ==
      (positions.wrong[side].edit.x - lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y)/*left*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y + lengthPerTeil.edit.y))/*down*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y - lengthPerTeil.edit.y))/*up*/))) {
      if (zurrückVermeiden.checked && (missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y))) {
        maleZurrück.number++;
      }
      else maleZurrück.normalSlide++;
      missingArray.push(pMissing);
      //console.log(missingArray);
      // movement.positions.unshift(JSON.parse(JSON.stringify(positions)));
      var ablage = JSON.parse(JSON.stringify(positions.wrong[side]));
      movement.move.unshift({x: (pMissing.split(' - ')[0] - ablage.edit.x), y: (pMissing.split(' - ')[1] - ablage.edit.y), tile: side});
      // movement.missing.unshift(JSON.parse(JSON.stringify(missingArray)));
      positions.wrong[side].edit = JSON.parse(JSON.stringify({x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0}));//.splice(side, 1);
      textur.width = textur.width;
      layout(true);
      // for (var i1 = 0; difficultSchieben.checked && i1 < movement.positions.length; i1++) {
        //   if (angular.equals(positions, movement.positions[i1])/* && angular.equals(missing, movement.missing[i1])*/) {
          //     positions = JSON.parse(JSON.stringify(movement.positions[1]));
          //     missing = JSON.parse(JSON.stringify(movement.missing[1]));
          //     movement.positions.splice(0, 1);
          //     movement.missing.splice(0, 1);
          //     maleZurrück.number++;
          //     i1 = movement.positions.length;
          //     i--;
          //     for (var i2 = 0; i2 < workingNumbers.length; i2++) {
            //       if (workingNumbers[i2] == side) workingNumbers.splice(i2, 1);
            //     }
            //   }
            // }
            // if (i1 != movement.positions.length + 1) {
      missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
      workingNumbers = [];
      for (var i1 = 0; i1 < positions.wrong.length; i1++) {
        if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i1);
      }
      // }
    }
      else {
        i--;
        for (var i1 = 0; i1 < workingNumbers.length; i1++) {
          if (workingNumbers[i1] == side) workingNumbers.splice(i1, 1);
        }
      }
    } catch (e) {
      //console.log("ein Error bei der if Abfrage!!! + (" + e + ")");
      i = positions.wrong.length;
    }
  });
    counter++;
    }
    if (layout(undefined, true, true) != undefined) verschiebenPC();
  }
  var movement = {move: [], startPosition: []};
  var mausx;
  var mausy;
  var stats = {turns: 0, highestRight: {turns: 0, right: 0}, rotated: 0, unclipped: 0, wrongClipped: 0, viewOriginal: {times: 0}, minimumRotations: 0};
  document.onmousemove = readMouseMove
  var originalMausX;
  // section 5: most user inputs
  window.addEventListener('scroll',()=>{
    if (scrollY > 10 && scrollY < texturTop - (showSettings.getBoundingClientRect().bottom + scrollY) && settings.style.display == "inline") selectBackToBarB.style.display = 'none';
    else if (aufgebenId.style.display == "inline" && shuffleStyle == "list") selectBackToBarB.style.display = 'inline';
  });
  // #importantUserInputs
  function readMouseMove(e) {
    mausx = e.clientX + scrollX - texturLeft;
    mausy = e.clientY + scrollY - texturTop;
    originalMausX = e.clientX;
    if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width) - mausx; // - scrollX;
    // /*96*/32// - 43;
    // if (scrollY > 32) mausy += 32;
    if (gerät == "PC") folgenMouseMove("mousemove");
  }
  window.scroll(0, 0);
  var texturTop = textur.getBoundingClientRect().top;
  var state = {mouse: "up", shift: false, newTileSelected: false, buttons: {}, coord: {x: 0, y: 0}, backToBar: false};
  var texturLeft = textur.getBoundingClientRect().left;
  // #importantUserInputs
  // if (gerät == "Handy") {
    document.addEventListener('touchmove', touch);
    document.addEventListener('touchstart', touch);
    document.addEventListener('touchend', touch);
    function touch(ev) {
    if ((aufgebenId.style.display == "inline" || removeTilesFinishedB.style.display == "inline") && (!ev.touches[0] || (ev.touches[0] && !collides({x: ev.touches[0]["pageX"] - scrollX, y: ev.touches[0]["pageY"] - scrollY, width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean))) {
    if (ev.touches[2]) {
      textur.style.touchAction = '';
    }
    else if (ev.type == "touchmove" && !scrollable.checked && (!scrollOnBlanc.checked || selected.tiles.length)) {
      textur.style.touchAction = 'none';
    }
    if (ev.touches[1] && aufgebenId.style.display == "inline") {
      state.shift = true;
      state.shiftBySwipe = true;
      selected.tiles = [];
      mouseDown();
    }
    if ((ev.type == "touchend" && swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && (textur.style.touchAction == 'none') && (swipeSteuerung.checked ))) {
      // textur.style.touchAction = '';
      canvasClicked();
    }
    else if ((state.removeTile || ((swipeSteuerung.checked || modeSelection.value == "traditional") && modeSelection.value != "schieben")) && ev.touches[0]) {
      mausx = ev.touches[0]["pageX"] - textur.getBoundingClientRect().left;// + scrollX;
      mausy = ev.touches[0]["pageY"] - texturTop;// - 32// + scrollY;
      if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width + scrollX) - mausx;
    }
    if (!scrollable.checked) {
      // if (aufgebenId.style.display == "inline") textur.style.touchAction = 'none';
    if (ev.type == "touchstart" && !ev.touches[2] && !collides({x: mausx, y: mausy + texturTop, width: 1, height: 1}, selectBackToBarB.getBoundingClientRect()).boolean) {
      mouseDown(null, ev.touches[0] == undefined && collides({x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"], width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean);
    }
    if (ev.type == "touchend") {
      setTimeout(function () {
        mouseUp();
        layout(true, true);
      }, 100);
    }
    if (ev.type == "touchmove" && (modeSelection.value == "traditional" || state.removeTile)) {
      folgenMouseMove("touchmove");
    }
  }
    if (!ev.touches[0]) {
      console.log(":((()))");
    }
      if (ev.type == "touchstart" && swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && ev.touches[0]) {
        if (textur.style.touchAction != 'none') {
        setTimeout(function () {
          window.scroll(0, /*96 50*/32);
          textur.style.touchAction = 'none';
          selected.position = {x: checkSelected().x, y: checkSelected().y};
          selected.boolean = true;
        }, 3000);
      }
      else {
        selected.position = {x: checkSelected().x, y: checkSelected().y};
        selected.boolean = true;
      }

      }
      if (scrollable.checked) textur.style.touchAction = '';
    }
    if (!selected.tiles.length && ev.type == "touchmove" && scrollOnBlanc.checked) textur.style.touchAction = '';
  }
  // }
  function tileSelected() {
    for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
      var i = positions.layoutOrder[i1];
      var coord = positions.wrong[i].edit;
      var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
      if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
      if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
        return true;
      }
    }
  }
  function mouseDown(elmCalled, touchStart) {
    delete state.rorated;
    tileSelectionBar.swipePosition = mausx;
    state.mouse = "down";
    if (gerät == "Handy" && selectMultiple.checked) state.shift = true;
    state.coord = checkSelected();
    if (modeSelection.value == "traditional") {
      if (tileSelectionBar.selectedTile?.tileI != undefined && (tileSelectionBar.selectedTile.byUser || !tileSelected()) && !tileSelectionBar.collidesMouse() && state.backToBar === false) {
        var i = tileSelectionBar.selectedTile;
        selected.tiles.push(i.tileI);
        positions.layoutOrder = positions.layoutOrder.filter(x => x != i.tileI);
        positions.layoutOrder.push(i.tileI);
        tileSelectionBar.tiles.splice(i.i, 1);
        // tileSelectionBar.tiles = tileSelectionBar.tiles.filter(x => x != undefined);
        if (!autoSelectTileBar.checked) tileSelectionBar.selectedTile = undefined;
          else {
          if (!tileSelectionBar.tiles.length) tileSelectionBar.selectedTile = undefined;
          else {
            setTimeout(function () {
              tileSelectionBar.selectedTile.byUser = false;
              tileSelectionBar.selectedTile.tileI++;
              if (!positions.wrong[tileSelectionBar.selectedTile.tileI] || positions.wrong[tileSelectionBar.selectedTile.tileI].edit.y != 5 + lengthPerTeil.edit.y/2) tileSelectionBar.selectedTile.i--;
              while (tileSelectionBar.selectedTile.tileI >= 0 && tileSelectionBar.tiles.length > 0 && (!positions.wrong[tileSelectionBar.selectedTile.tileI] || positions.wrong[tileSelectionBar.selectedTile.tileI].edit.y != 5 + lengthPerTeil.edit.y/2)) {
                tileSelectionBar.selectedTile.tileI--;
              }
              layout();
            }, 10);
          }
        }
          positions.wrong[i.tileI].edit = {x: mausx, y: mausy, degree: 0};
        state.placeTile = true;
        scrollTileSelection(0);
      }
      // selected.tiles = [];
      selected.position = {x: mausx, y: mausy};
      for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
        var i = positions.layoutOrder[i1];
        var coord = positions.wrong[i].edit;
        var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
        if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
        if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height) {
          state.oldTileSelected = true;
        }
        if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
          if (!state.placeTile) {
            selected.tiles.push(i);
            positions.layoutOrder = positions.layoutOrder.filter(x => x != i);
            positions.layoutOrder.push(i);
            if (!elmCalled && !touchStart) {
              if (rotatesRight.checked) rotateSelected(90);
              if (rotatesLeft.checked) rotateSelected(-90);
            }
          }
          if (state.backToBar !== false) {
            // tileSelectionBar.tiles.push(i);
            tileSelectionBar.tiles.splice(state.backToBar, 0, i);
            if (autoSelectTileBar.checked && tileSelectionBar.tiles.length == 1) {
              state.setSelected = {i: state.backToBar, tileI: i};
              setTimeout(function() {
                tileSelectionBar.selectedTile = state.setSelected;
              }, 10);
            }
            document.getElementsByClassName('backToTileB')[state.backToBar].style.backgroundColor = '';
            selectBackToBarB.style.backgroundColor = '';
            state.backToBar = false;
            unclipp(i);
            mouseDown();
          }
          layout(true);
          state.newTileSelected = true;
        }
      }
      if (!state.newTileSelected && !state.oldTileSelected && !automaticTileSelectionReset.checked) selected.tiles = [];
      state.placeTile = false;
      tileSelectionBar.tiles.forEach((tileI, i) => {
        var tile = positions.wrong[tileI];
        if (mausx > (5 + lengthPerTeil.sizeAdapted.x)*i + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && mausx < (5 + lengthPerTeil.sizeAdapted.x)*(i + 1) + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && tileSelectionBar.collidesMouse()) {
          tileSelectionBar.selectedTile = {i: i, tileI: tileI, byUser: true};
          layout();
        }
      });
      folgenMouseMove("mouseDown");
    }
    else if (state.removeTile) folgenMouseMove("mouseDown");
  }
  // #importantUserInput
  function folgenMouseMove(calledBy) {
    if (state.mouse == "down" && state.removeTile) canvasClicked(calledBy);
    positionBackToTileBarButtons(true);
    if (state.mouse == "down" && !state.removeTile && modeSelection.value == "traditional") {
      if (calledBy != "mouseDown") selectMultiple.checked = false;
      // select clipped
      for (var tile of selected.tiles) {
        var objTile = positions.wrong[tile];
        if (gerät == "PC") {
        if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX - lengthPerTeil.edit.x/2 < 0 && selected.tiles.length) expandSide('right');// textur.width += 15;
        if (!mirrorInput.checked && objTile.edit.x + lengthPerTeil.edit.x > textur.width) expandSide('right'); // textur.width += lengthPerTeil.edit.x;
        if (objTile.edit.y + lengthPerTeil.edit.y > textur.height) expandSide('bottom'); // textur.height += lengthPerTeil.edit.y;
      }
        for (var clipp of clipped) {
          var newTile = clipp.split(' - ').filter(x => !selected.tiles.includes(JSON.parse(x)))[0];
          if (!state.shift && clipp.split(' - ').includes(tile + "") && newTile) {
            selected.tiles.push(JSON.parse(newTile));
            positions.layoutOrder = positions.layoutOrder.filter(x => x != JSON.parse(newTile));
            positions.layoutOrder.push(JSON.parse(newTile));
          }
        }
        // unclipp
        if (state.shift && calledBy != "mouseDown") {
          unclipp(tile);
          state.shiftBySwipe = false;
        }
        // positions.wrong.forEach((position, i) => {
        //   if (((objTile.original?.left?.x == position.original?.x && objTile.original?.left?.x != undefined && objTile.original?.left?.y == position.original?.y) || (objTile.original?.top?.x == position.original?.x && objTile.original?.top?.x != undefined && objTile.original?.top?.y == position.original?.y) || (objTile.original?.wrong?.x == position.original?.x && objTile.original?.wrong?.x != undefined && objTile.original?.wrong?.y == position.original?.y) || (objTile.original?.bottom?.x == position.original?.x && objTile.original?.bottom?.x != undefined && objTile.original?.bottom?.y == position.original?.y)) && !selected.tiles.includes(i)) {
        //     selected.tiles.push(i);
        //   }
        // });
      }
      if (selected.tiles.length) {
        positions.wrong.forEach((pos, i) => {
          if (selected.tiles.includes(i)) {
            pos.edit.x += mausx - selected.position.x;
            pos.edit.y += mausy - selected.position.y;
          }
        });
        // check clicking
        selected.clip = [];
        for (var tile of selected.tiles) {
          checkPossibleClipping(tile);
        }
        deleteFurtherClipOptions();
        playClippingSound();
        selected.position = {x: mausx, y: mausy};
        layout(false, true);
      }
    }
  }
  // deletes clip options that apply to the same tile but are further away
  function deleteFurtherClipOptions() {
    nearestTile = {};
    if (selected.clip.length > 1) {
      console.log('debug');
    }
    selected.clip.forEach((clip, i1) => {
      if (!nearestTile[clip.i] || clip.distance < nearestTile[clip.i].clip.distance) {
        if (nearestTile[clip.i]) selected.clip.splice(nearestTile[clip.i].i, 1);
        nearestTile[clip.i] = {clip: clip, i: i1};
      }
      else if (clip.distance > nearestTile[clip.i].clip.distance) {
        selected.clip.splice(i1, 1);
      }
      // sI
      if (!nearestTile[clip.sI] || clip.distance < nearestTile[clip.sI].clip.distance) {
        if (nearestTile[clip.sI]) selected.clip.splice(nearestTile[clip.sI].i, 1);
        nearestTile[clip.sI] = {clip: clip, i: i1};
      }
      else if (clip.distance > nearestTile[clip.sI].clip.distance) {
        selected.clip.splice(i1, 1);
      }
    });
  }
  var nearestTile = {};
  // #importantUserImput
  function mouseUp() {
    state.mouse = "up";
    if (gerät == "Handy" && !selectMultiple.checked && !state.shiftBySwipe) state.shift = false;
    if (modeSelection.value == "traditional" && !state.rotated) {
      state.newTileSelected = false;
      state.oldTileSelected = false;
      var bClipped = false;
      for (var clip of selected.clip) {
        if (!tileSelectionBar.tiles.includes(clip.i)) {
        if ((JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) stats.wrongClipped++;
        var directionOpposite = {left: 'right', top: 'bottom', right: 'left', bottom: 'top'};
        positions.wrong[clip.i].original[clip.direction] = {x: positions.right[clip.sI].original.x, y: positions.right[clip.sI].original.y};
        positions.wrong[clip.sI].original[directionOpposite[clip.direction]] = {x: positions.right[clip.i].original.x, y: positions.right[clip.i].original.y};
        var differ = {x: (clip.selected.x - positions.wrong[clip.sI].edit.x), y: (clip.selected.y - positions.wrong[clip.sI].edit.y)};
        for (var tile of selected.tiles) {
          positions.wrong[tile].edit.x += differ.x;
          positions.wrong[tile].edit.y += differ.y;
        }
        clipped.push(clip.i + ' - ' + clip.sI);
        // do more clipping if needed
        checkPossibleClipping(clip.sI, true);
        deleteFurtherClipOptions();
        bClipped = true;
      }
    }
    if (selected.clip.length && bClipped) {
      new Audio('https://adi.nicolaiweitkemper.de/Sounds/helpTheTrain/weiche.mp3').play();
      console.log("clipping...");
      stats.turns++;
      // selectMultiple.checked = false;
      state.shift = false;
      selected.tiles = [];
    }
    selected.clip = [];
    if (selected.tiles.length && !state.shift && !state.removeTile && automaticTileSelectionReset.checked) selected.tiles = [];
    }
    delete state.rotated;
  }
    // #importantUserInputs
  document.onkeydown = function(event) {
    if (event.shiftKey) {
      state.shift = true;
      selected.tiles = [];
    }
    var collidesTilesBar = tileSelectionBar.collidesMouse();
    if (event.key == "ArrowRight") {
      if (collidesTilesBar) scrollTileSelection(1);
      else rotateSelected(90);
    }
    if (event.key == "ArrowLeft") {
      if (collidesTilesBar) scrollTileSelection(-1);
      else rotateSelected(-90);
    }
    if (event.key?.includes("Arrow")) layout(true);
    if ((event.key == "ArrowRight" || event.key == "ArrowLeft") && modeSelection.value == "traditional" && ((selected.tiles.length && rotateTiles.checked) || collidesTilesBar)) return false;
  }
  function rotateSelected(direction) {
    if (!state.removeTile) {
      state.rotated = [];
      rotateAround(selected.tiles[0], direction);
      layout(true, true);
    }
  }
  function rotateTile(tile, direction) {
    if (mirrorInput.checked) direction *= -1;
    positions.wrong[tile].original.degree += direction;
    if (positions.wrong[tile].original.degree < -90) positions.wrong[tile].original.degree = 180;
    else if (positions.wrong[tile].original.degree >= 270) positions.wrong[tile].original.degree = -90;
    stats.rotated++;
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  document.onkeyup = function(event) {
    if (!event.shiftKey && state.shift) {
      state.shift = false;
      if (automaticTileSelectionReset.checked) selected.tiles = [];
    }
  }
  // end section 5
  // section 6: rotate tile(s)
    // #importantUserInputs
    document.onkeydown = function(event) {
    if (event.shiftKey) {
      state.shift = true;
      selected.tiles = [];
    }
    var collidesTilesBar = tileSelectionBar.collidesMouse();
    if (event.key == "ArrowRight") {
      if (collidesTilesBar) scrollTileSelection(1);
      else rotateSelected(90);
    }
    if (event.key == "ArrowLeft") {
      if (collidesTilesBar) scrollTileSelection(-1);
      else rotateSelected(-90);
    }
    if (event.key?.includes("Arrow")) layout(true);
    if ((event.key == "ArrowRight" || event.key == "ArrowLeft") && modeSelection.value == "traditional" && ((selected.tiles.length && rotateTiles.checked) || collidesTilesBar)) return false;
  }
  function rotateSelected(direction) {
    if (!state.removeTile) {
      state.rotated = [];
      rotateAround(selected.tiles[0], direction);
      layout(true, true);
    }
  }
  function rotateTile(tile, direction) {
    if (mirrorInput.checked) direction *= -1;
    positions.wrong[tile].original.degree += direction;
    if (positions.wrong[tile].original.degree < -90) positions.wrong[tile].original.degree = 180;
    else if (positions.wrong[tile].original.degree >= 270) positions.wrong[tile].original.degree = -90;
    stats.rotated++;
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  // end section 6
  // returns pixel as a number
  function convertStyle(value) {
    return JSON.parse(value.replace('px', ''));
  }
  // adapts the position of the backToTileBarButtons
  function positionBackToTileBarButtons(calledByMouseDown) {
    if (!calledByMouseDown || (aufgebenId.style.display == "inline" && shuffleStyle.value == "listTiles" && state.mouse == "down" && tileSelectionBar.collidesMouse() && !selected.tiles.length)) {
      if (calledByMouseDown) tileSelectionBar.scrollX += (mausx - tileSelectionBar.swipePosition);
      tileSelectionBar.leftOffScreenTiles = - (Math.floor(tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5)));
      if (((tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5)) tileSelectionBar.offset = - (JSON.parse("0." + (tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5));
      else tileSelectionBar.offset = 0;
      if (tileSelectionBar.scrollX >= 0) tileSelectionBar.offset = -(tileSelectionBar.offset);
      else tileSelectionBar.leftOffScreenTiles--;
      for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
        elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
      }
      tileSelectionBar.swipePosition = mausx;
      if (calledByMouseDown) scrollTileSelection(0);
    }
  }
  function unclipp(tile) {
    var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
    var objTile = positions.wrong[tile];
    for (const direc of ['left', 'top', 'right', 'bottom']) {
      if (objTile.original[direc] && !selected.tiles.includes(getTile(objTile.original[direc]))) {
        delete positions.wrong[getTile(objTile.original[direc])].original[directionConverter[direc]];
        delete objTile.original[direc];
      }
    }
    var unclipped = false;
    for (let i = 0; i < clipped.length; i++) {
      if (clipped[i].split(' - ').includes(tile + "") && (!selected.tiles.includes(parseInt(clipped[i].split(' - ')[0])) || !selected.tiles.includes(parseInt(clipped[i].split(' - ')[1])))) {
        clipped.splice(i, 1);
        unclipped = true;
        i--;
      }
    }
    if (unclipped) stats.unclipped++;
  }
  function checkPossibleClipping(tile, afterClipping) {
    var nearest = {left: {area: 1000}, top: {area: 1000}, right: {area: 1000}, bottom: {area: 1000}, overAll: {area: 1000, i: -1}};
    positions.wrong.forEach((pos, i) => {
      var obj = {all: pos.edit, slc: positions.wrong[tile].edit};
      var selectedObj = {
        right: {x: obj.slc.x - 10, y: obj.slc.y + 1, width: 10, height: lengthPerTeil.edit.y - 2},
        left: {x: obj.slc.x + lengthPerTeil.edit.x, y: obj.slc.y + 1, width: 10, height: lengthPerTeil.edit.y - 2},
        bottom: {x: obj.slc.x + 1, y: obj.slc.y - 10, width: lengthPerTeil.edit.x - 2, height: 10},
        top: {x: obj.slc.x + 1, y: obj.slc.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x - 2, height: 10}
      };
      if (!clipped.includes(i + ' - ' + tile) && !clipped.includes(tile + ' - ' + i)) {
        var nearTile = {
          right: collides(selectedObj.right, {x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y + 1, width: 10, height: lengthPerTeil.edit.y - 2}),
          left: collides(selectedObj.left, {x: obj.all.x - 10, y: obj.all.y + 1, width: 10, height: lengthPerTeil.edit.y - 2}),
          bottom: collides(selectedObj.bottom, {x: obj.all.x + 1, y: obj.all.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x - 2, height: 10}),
          top: collides(selectedObj.top, {x: obj.all.x + 1, y: obj.all.y - 10, width: lengthPerTeil.edit.x - 2, height: 10})
        };
        for (var side of Object.keys(nearTile)) {
          if (nearTile[side].boolean && nearTile[side].area < nearest[side].area) {
            nearest[side] = {area: nearTile[side].area, i: i};
          }
        }
      }
    });
    if (nearest) {
      // console.log("new check");
      for (const near of Object.values(nearest)) {
        // console.log(near.area);
        if (near.area < nearest.overAll.area) {
          nearest.overAll = {area: near.area, i: near.i};
        }
      }
    }
    var acceptedI = getConnectedTiles(nearest.overAll.i, true);
    var screenObj = {x: scrollX, y: scrollY, width: window.visualViewport.width - 22, height: window.visualViewport.height};
    if (mirrorInput.checked) screenObj = {x: textur.width - scrollX - window.innerWidth, y: scrollY, width: window.innerWidth - 22, height: window.innerHeight};
    canvas.fillStyle = "blue";
    // canvas.fillRect(textur.width - scrollX - window.innerWidth, scrollY, window.innerWidth, window.innerHeight);
    var clipLength = selected.clip.length;
    var obj = {all: positions.wrong[nearest?.right.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.left) {
      selected.clip.push({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y, selected: {x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.right.area});
    }
    obj = {all: positions.wrong[nearest?.left.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.right) {
      selected.clip.push({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y, selected: {x: obj.all.x - lengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.left.area});
    }
    obj = {all: positions.wrong[nearest?.bottom.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.top) {
      selected.clip.push({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x, y: obj.all.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x, height: 10, selected: { x: obj.all.x, y: obj.all.y + lengthPerTeil.edit.y}, distance: nearest.bottom.area});
    }
    obj = {all: positions.wrong[nearest?.top.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.bottom) {
      selected.clip.push({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x, y: obj.all.y - 10, width: lengthPerTeil.edit.x, height: 10, selected: {x: obj.all.x, y: obj.all.y - lengthPerTeil.edit.y}, distance: nearest.top.area});
    }
    checkedTiles = [];
    for (var i = 0; i < selected.clip.length - clipLength; i++) {
      if (selected.clip.length > clipLength && (tileSelectionBar.tiles.includes(selected.clip[selected.clip.length - 1 - i].i) || ((selectedCollidesOthers(selected.clip[selected.clip.length - 1 - i], tile) || !collides(addTolerance(selected.clip[selected.clip.length - 1 - i], 3), screenObj).boolean || selectedCollideOther(selected.clip[selected.clip.length - 1 - i].i) || !acceptedI.includes(selected.clip[selected.clip.length - 1 - i].i)) && !afterClipping))) {
        selected.clip.pop();
        i--;
      }
    }
  }
  // returns a list with the indizes (plural index) of all tiles the entered tile ('tile') is connected to
  function getConnectedTiles(tile, firstCall, connectedTiles) {
    if (!connectedTiles) connectedTiles = [];
    connectedTiles.push(tile);
    var tileObj = positions.wrong[tile];
    for (const side of ['left', 'top', 'right', 'bottom']) {
      if (tileObj && tileObj.original[side] && !connectedTiles.includes(getTile(tileObj.original[side]))) getConnectedTiles(getTile(tileObj.original[side]), false, connectedTiles);
    };
    if (firstCall) return connectedTiles;
  }
  function playClippingSound() {
    for (const option of selected.clip) {
      // new option
      if (!clipOptionsBefore || !JSON.stringify(clipOptionsBefore).includes(JSON.stringify(filterSI([option])[0]))) {
        if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseDown%20(click)_V3.mp3').play();
        clipOptionsBefore = (filterSI(selected.clip));
        if (vibrate.checked) window.navigator.vibrate(33);
      }
    }
    if (clipOptionsBefore) {
      for (const option of clipOptionsBefore) {
        if (!JSON.stringify(filterSI(selected.clip)).includes(JSON.stringify(option))) {
          if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseUp%20(click).mp3').play();
          clipOptionsBefore = (filterSI(selected.clip));
          if (vibrate.checked) {
            setTimeout(function () {
              window.navigator.vibrate(27);
            }, 100);
          }
        }
      }
    }
  }
  // remove sI out of the entered obj
  function filterSI(clipOptions) {
    var stored = JSON.parse(JSON.stringify(clipOptions));
    for (const elm of stored) {
      delete elm.sI;
      delete elm.distance;
    }
    return stored;
  }
  var clipOptionsBefore;
  // checks collision of tiles with the clip options marker
  function selectedCollidesOthers(pClip,  tile) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (collides(transformToObj(i), addTolerance(pClip, 3)).boolean && !tileSelectionBar.tiles.includes(i) && !selected.tiles.includes(i) && tile != i) {
        return true;
      }
    }
  }
  var checkedTiles = [];
  // checks if selected tiles collide tiles which are (connected to) tiles you want to clip to
  function selectedCollideOther(pClipIndex) {
    var connected = getConnectedTiles(pClipIndex, true);
    for (const clipIndex of connected) {
      for (const tile of selected.tiles) {
        if (collides(transformToObj(clipIndex, 3), transformToObj(tile, 3)).boolean) {
          return true;
        }
      }
    }
  }
  var clipped = [];
  function collides(a, b) {
    try {
      return {boolean: !(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        ), area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)};

    } catch (e) {
      console.log('err: ' + e);
    }
  }
  // checks if potentiallySelected collides with any other tile (not used anymore due to more advanced collision detection (TODO: optional?))
  function selectedCollides(potentiallySelected) {
    for (var tile of selected.tiles) {
      if (collides(transformToObj(tile), transformToObj(potentiallySelected)).boolean) return tile;
    }
  }
  // transforms index of tile into an obj that can be used for collision checks (tolerance can be added)
  function transformToObj(i, tolerance) {
    var obj =  positions.wrong[i].edit;
    if (!tolerance) tolerance = 0;
    return {x: obj.x + tolerance, y: obj.y + tolerance, width: lengthPerTeil.edit.x - tolerance*2, height: lengthPerTeil.edit.y - tolerance*2};
  }
  // adds tolerance by decreacing the size of the entered hitbox (obj)
  function addTolerance(obj, tolerance) {
    return {...obj, x: obj.x + tolerance, y: obj.y + tolerance, width: obj.width - tolerance*2, height: obj.height - tolerance*2};
  }
  // returns the index of the tile which has the entered original coordinates
  function getTile(originalCoord) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (positions.wrong[i].original.x == originalCoord.x && positions.wrong[i].original.y == originalCoord.y) return i;
    };
  }
  // exchanges two tiles (positions)
  function vertauscheZwei(i, i1) {
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i].edit));
    positions.wrong[i].edit = JSON.parse(JSON.stringify(positions.wrong[i1].edit));
    positions.wrong[i1].edit = JSON.parse(JSON.stringify(ablage));
    if (positions.wrong[i1].edit == undefined) positions.wrong.splice(i1, 1);
  }
  // returns the coordinates of a selected tile (schieben and exchange mode)
  function checkSelected() {
    try {
    for (var i = 0; i < anzahlX.value; i++) {
      for (var i1 = 0; i1 < anzahlY.value; i1++) {
        if (mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1)) return {x: i, y: i1};
      }
    }
  } catch (e) {
    console.log("pleaseDebug :)");
  }
  }

// section 7: stop clock:
var stopClock = {viewOriginal: {time: 0, running: 0}, completionTime: {time: 0, running: 0}};
var time = 0;
var running = 0;

function startPause(type) {
if (stopClock[type].running == 0) {
  stopClock[type].running = 1;
  // time = 0;
  increment(type);
}
else {
  stopClock[type].running = 0;
}
}
function reset(type) {
running = 0;
timer = 0;
}
function increment(type) {
if (stopClock[type].running == 1) {
setTimeout(function () {
  stopClock[type].time++;
  var time = stopClock[type].time;
  var mins = Math.floor(time/10/60);
  var secs = Math.floor(time/10);
      secs -= 60*mins;
  var tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  if (type == "viewOriginal") stats[type].time = mins + ":" + secs + ":" + "0" + tenths;
  else stats[type] = mins + ":" + secs + ":" + "0" + tenths;
  increment(type);
}, 100);
}
}
// end section 7
</script>
