<meta charset="utf-8">
<meta name="viewport" id="preventAutomaticZoom">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<img id="puzzleManagerIcon" class="button" onclick="if (puzzleManager.style.display != 'none') puzzleManager.style.display = 'none'; else puzzleManager.style.display = 'block';" draggable="false" title="manage saved puzzles" src="https://adi.nicolaiweitkemper.de/Bilder/puzzleCreator/save_and_load.png">
<div style="display: none" id="puzzleManager" class="card cardGeneral">
  <h3>manage saved puzzles</h3>
  <img src="https://adi.nicolaiweitkemper.de/Bilder/database_import_icon.png" title="Bereits erstellte Puzzle fortfahren" draggable="false" >
  <li id="puzzleSelection"></li>
  <img src="https://adi.nicolaiweitkemper.de/Bilder/saveicon.png" title="im Folgenden erstellte Puzzle speichern" draggable="false" >
  <div style="display: none;" onmouseout="checkOut();"  class="dropdown-content" id="editPuzzleManager">
    <a onclick="restorePuzzleSource(selected.puzzle);">open/continue</a>
    <a onclick="editPuzzleName();">edit name</a>
    <a onclick="deletePuzzle();">delete</a>
    <a onclick="showInformation();">more information</a>
  </div>
  <br>
  <a id="storePuzzleManager">
    <input id="doStorePuzzle" type="checkbox"> save the puzzle I will create as 
    <input oninput="if (Object.keys(puzzles).includes(value)) puzzleNameWarning.style.display = 'inline'; else puzzleNameWarning.style.display = 'none'; doStorePuzzle.checked = true;" id="puzzleName" type="text"> 
    automatically
    <br>
  </a>
  <p id="puzzleNameWarning" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
    You have already stored a puzzle with this name. Please choose another name! If you don't, the older puzzle with this name will be overwritten with the current one!!!
  </p>
</div>
<div id="imageSettings">
<div class="card cardGeneral">
<h1 id="selectSourceHeader" style="color: red;">select source (image or video)</h1>
<br>
<input type="file" accept="image/*,video/*" onchange="readImg(this);" style="position: absolute; left: -10000px;" id="fileB">
<input id="sourceIsFile" onclick="fileB.click();" style="font-size: 55px;" type="radio" name="source"><a onclick="fileB.click(); sourceIsFile.checked = true;">choose file (image or video)</a></input>
<br>
<input onchange="useURL();" id="useURLCheck" type="radio" name="source">
<input type="text" style="height: 50px;" oninput="useURL();" height="100px" placeholder="Link (drag and drop möglich)" id="sourceURL">
<br>
<p id="URLInfo" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
  The URL has to directly point to the image/video! Please rightclick on the wished image and click on "copy image adress", to copy the right adress/url. Also, Youtube videos are not supported. 
  <br>
  Alternatively, you can drag-and-drop the image in the text filed above. 
  <br>
</p>
<a style="display: none; border-radius: 3px; border-style: double; background-color: darkorange; width: max-content; height: max-content;" id="sourceCheckboxes">
  <input id="sourceIsPicture" onchange="state.userSource = 'Picture';" checked="true" name="mediaType" type="radio">image
  <input id="sourceIsVideo" onchange="state.userSource = 'Video';" name="mediaType" type="radio">video
  <br>
</a>
<input id="useLiveCam" type="radio" name="source" onchange="changeCamera(cameraSelection.value);"><a onclick="useLiveCam.checked = true; changeCamera(cameraSelection.value);">use connected or built in (live) camera</a></button>
<select id="cameraSelection" onchange="changeCamera(value);"></select>
</div>
<img onclick="if (tilesSizeDiv.style.display != 'none') tilesSizeDiv.style.display = 'none'; else {tilesSizeDiv.style.display = 'block';}" class="button" title="Anzahl der Puzzleteile" style=" outline-width: 2px; outline-color: black" draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/puzzleCreator/pieceAmount_V2.png">
<div style="display: none;" id="tilesSizeDiv" onmouseover="tilesSizeDiv.appendChild(textur);" class="card cardGeneral">
  <h3>amount of puzzle pieces</h3>
  <input type="number" min="0" value="4" style="width: 44px;" id="amountX" onchange="anzahlVerschieben.value = value*anzahlY.value; anzahlRichtige.max = value*anzahlY.value - 2; drawTileGrid();"> pieces x-axis
  <br>
  <input type="number" min="0" value="4" style="width: 44px;" id="anzahlY" onchange="anzahlVerschieben.value = amountX.value*value; anzahlRichtige.max = amountX.value*value - 2; drawTileGrid();"> pieces y-axis
  <br>
  <br>
  <a id="rotateTilesAdaptionSettings">
    <button type="radio" id="bAdaptAmount" onclick="if (checked) adaptTileAmount(true); drawTileGrid();" name="adaptionStyle"> Adapt amount of pieces, so width and height of each piece are equal (quadratic pieces)</button>
      and in total at least <input id="minTileAmount" oninput="adaptTileAmount();" style="width: 45px;" value="16" min="2" type="number"> pieces are created.
    <br>
  </a>
</div>
<br>
<img onclick="if (editCanvasDiv.style.display != 'none') editCanvasDiv.style.display = 'none'; else {editCanvasDiv.style.display = 'block'; editCanvasDiv.insertBefore(textur, videoControls)}" src="https://adi.nicolaiweitkemper.de/Bilder/puzzleCreator/edit_image.png" title="edit image" class="button" draggable="false" width="50px" height="50px">
<br>
<div style="display: none" id="editCanvasDiv" onmouseover="editCanvasDiv.appendChild(textur); editCanvasDiv.insertBefore(textur, videoControls);" class="card cardGeneral">
<h3>edit image/video</h3>
<input id="mirrorInput" onclick="mirrorCanvas(checked);" type="checkbox"> mirror image/video
<br>
<p1 id="screenIsMaxP"><input id="screenIsMax" onchange="changeAdaptedSizeMax(originalSize.width, originalSize.height);" checked="true" type="checkbox"> max. image/video size: screen size</p1>
<br>
<input id="percentSizeAdaption" oninput="größeAnpassenX.value = größeAnpassenX.max*value; größeAnpassenY.value = größeAnpassenY.max*value; zeigeGröße(true);" min="0.01" step="0.01" max="1" type="range"> change width and height the same amount
<br>
<input type="range" oninput="zeigeGröße(true);" placeholder="Pixelanzahl x achse" id="größeAnpassenX"> image/video width
<br>
<input type="range" max="window.innerHeight" oninput="zeigeGröße(true);" placeholder="Pixelanzahl y achse" id="größeAnpassenY"> image/video height
<br>
<button type="button" onclick="resetImageSize();" name="button">⟲ original size</button>
<button type="button" onclick="zuBildschirmgröße();" name="button">image/video screen size</button>
<button type="button" onclick="zuAngepassterBildschirmgröße();" name="button"> adjust size ratio Größenverhältnis angleichen (square pieces)</button>
<button type="button" onclick="zuOptimalerBildschirmgröße();" title="verkelinert sowohl Höhe als auch Breite des Bildes solange, bis beides auf den Bildschirm passt. " name="button">optimize size ratio</button>
<br>
<canvas onmousedown="mouseDown(true);" onmouseup="mouseUp();" style="border-width: 3px; border-style: solid; touch-action: manipulation;" id="textur" width="1" onclick="canvasClicked('elm');" height="1"></canvas>
<br>
<div style="display: none;" class="card cardGeneral" id="videoControls">
  <h3>video controls</h3>
  <a id="timeChangeDiv">
  <!-- TODO: stoppt automatisch, kann also weg? -->
  <input id="loop" checked="true" onchange="playPauseVideo('play');" type="checkbox"> ⟲ repeat
  <br>
  <input type="checkbox" onclick="video.muted = checked;">mute</input>
  <!-- TODO: stoppt automatisch, kann also weg? -->
  <!-- <a id="stopAtEndP" style="display: none;"><input id="stopAtEnd" type="checkbox"> am Ende stoppen</a> -->
  <br>
 start at <input type="text" oninput="if (value > loopEnding.value) {playPauseVideo('pause'); timeSlotWarning.style.display = 'inline';} else timeSlotWarning.style.display = 'none';" id="loopBeginning"> 
  <button onclick="if (timeText.innerHTML.split(' / ')[0] < loopEnding.value || loopEnding.value == '') {loopBeginning.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100); timeSlotWarning.style.display = 'none';} else timeSlotWarning.style.display = 'block';">take current time</button> 
  and end at <input id="loopEnding" oninput="if (value < loopBeginning.value) {playPauseVideo('pause'); timeSlotWarning.style.display = 'inline';} else timeSlotWarning.style.display = 'none';" type="text">
   <button onclick="if (timeText.innerHTML.split(' / ')[0] > loopBeginning.value || loopBeginning.value == '') {loopEnding.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100); timeSlotWarning.style.display = 'none';} else timeSlotWarning.style.display = 'block';">take current time</button>
  <br>
  <p id="timeSlotWarning" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
    The timestamp to end at is before the timestamp to begin at! Please move the startingpoint Please set the start point further forward or the end point further back so that your change is accepted.
    <br>
  </p>
  <button onclick="video.currentTime -= 10;"><<</button>
  </a>
  <button onclick="playPauseVideo(innerHTML);" id="playVideo">pause</button>
  <a id="timeChangeDiv">
  <button onclick="video.currentTime += 10;">>></button>
  <!-- Stoppen nach Springen im Video eher hindelrich -->
  <input oninput="video.currentTime = value;" step="0.01" type="range" id="videoPosition" min="0">
  <a id="timeText"></a>
  </a>
</div>
</div>
<button type="button" style="font-size: 33px;color: white; background-color: red; border: 10px;border-style: double;" onclick="create();" id="createPuzzleButton" name="button">create puzzle</button>
</div>
<!-- <button type="button" id="showSettings" onclick="changeSettingsVis();" name="button">mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)</button> -->
<button id="showTutorialB" style="display: none;" onclick="document.onkeydown({key: 'F1'});">help (show control instructions)</button>
<br>
<img src="https://adi.nicolaiweitkemper.de/Bilder/settings.png" id="showSettings" class="button" title="mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)" onmouseup="changeSettingsVis();"  draggable="false" >
<button id="showMobileControls" onclick="style.display = 'none'; mobileControls.style.display = 'inline'; localStorage.setItem('tileListVisHybridDevice', 'inline');" style="display: none; font-size: x-large;">show control pannel for mobile devices</button>
<br>
<button style="position: fixed; display: none; z-index: 3;" id="selectBackToBarB" onclick="generalBackToBar(this);">back to piece list</button>
<p2 style="position: fixed; top: -7px; left: 377px; background-color: rgba(205, 218, 199, 0.77); font-size: 5vh; padding-bottom: 15px; border-radius: 5px; z-index: 2;" id="mobileControls">
  <p id="rotateControls" style="display: none;">
    <a style="display: none;" id="traditionalModeMobileControls">
      <input class="mobileControlsElm" type="radio" onclick="rotateLeftModeChanged();" name="rotateB" id="rotatesLeft" name="button"><a1 onclick="showTitle(id, style.display);" id="rotateLeftSymbol">⟲</a1>
      <input class="mobileControlsElm" type="radio" onclick="rotateRightModeChanged();" name="rotateB" id="rotatesRight"  name="button"><a1 onclick="showTitle(id, style.display);" id="rotateRightSymbol">⟳</a1>
      <!-- <button class="mobileControlsElm" onclick="state.shift = true;"><==></button> -->
      <input type="checkbox" id="selectMultiple" class="mobileControlsElm" onchange="state.shift = true; if (['pressShiftMobileUnclippTutorial', 'pressShiftMobileMultipleUnclippTutorial'].includes(tutorial.state)) {goTutorialSteps(1);} if (['selectTileMobileShiftUnclippTutorial', 'selectTileMobileShiftMultipleUnclippTutorial'].includes(tutorial.state) && !checked) goTutorialSteps(-1);"><a1 onclick="showTitle(id, style.display);" id="selectMultipleSymbol">⇧</a1>
    </a>
  </p>
    <input class="mobileControlsElm" type="checkbox" id="scrollable" onclick=" if ((tutorial.state == 'selectScrollScrollingTutorial' && checked) || (tutorial.state == 'unselectScrollScrollingTutorial' && !checked)) goTutorialSteps(1); if (tutorial.state == 'scrollMobileScrollingTutorial' && !checked) goTutorialSteps(-1); if (tutorial.state == 'zoomInTutorial' && !checked) goTutorialSteps(-2); if (tutorial.state == 'zoomOutTutorial' && !checked) goTutorialSteps(-3);" name="button"><a onclick="showTitle(id, style.display);" id="swipeSymbol">scroll</a>
  <button style="width:10px; margin-right: 7px;" id="closeMobileControls" onclick="if (mouseSupported) {mobileControls.style.display = 'none'; showMobileControls.style.display = 'inline'; localStorage.setItem('tileListVisHybridDevice', 'none')}">X</button>
</p2>
<div id="tileElements">
  <div id="rotateLeftTitle" style="display: none;" class="speech top">
    rotate piece by 90° per click to the left 
  </div>
  <div id="rotateRightTitle" style="display: none;" class="speech top">
    rotate piece by 90° per click to the right 
  </div>
  <div id="selectMultipleTitle" style="display: none;" class="speech top">
    multi-selection by clicking on pieces and detach pieces by moving one of the selected pieces
  </div>
  <div id="swipeTitle" style="display: none;" class="speech top">
    enable scroll and zoom
  </div>
  <div id="scrollTileBarTitle" style="display: none;" class="speech bottom">
    arrow
  </div>
</div>
<div id="unclippPCHelp" style="opacity: 0; z-index: 2; size: 25%; background-color: hsla(0, 0%, 50%, 0.352); position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); border-radius: 10px; padding: 10px; transition: opacity 1s; display: none;">
  <h2>press shift (⇧) to detach pieces</h2>
  <button style="position: relative; left: 50%; transform: translate(-50%, -50%); top: 50%;" onclick="showUnclippTutorial();">see tutorial für details</button>
</div>
<style>
  .button {
    width: 50px; 
    border: 3px solid hsla(0, 0%, 2%, 0.4); 
    border-radius: 10px;
    background: rgb(200, 200, 200);
  }
  .mobileControlsElm {
    width: 44;
    height: 44;
    top: 7px;
    padding: 100px;
  }
</style>
<div id="settings" style="display: none;" class="card cardGeneral">
  <h2 id="modeHeadline">mode: </h2>
  <div id="modeDiv" class="card cardGeneral">
  <select onchange="modeSelected(value);" id="modeSelection">
    <option value="traditional">traditionel</option>
    <option value="exchange">exchange</option>
    <option value="schieben">sliding</option>
  </select>
  <br>
  <p id="traditionalDescription">The pieces are spread out. It is your task to put them back together to form the image/video you put in! 
    <br>
    It doesn't matter where you put them back together, but you might have to rotate them. 
    <div id="startTutorialButton">
      <br>
      <button onclick="setupTutorial();">tutorial</button>
    </div>
  </p>
  <p style="display: none;" id="exchangeDescription">
    The position of the pieces is shuffles. It is your task to exchange the position of two tiles until the pieces form the original image/video you put in!
  </p>
  <p style="display: none;" id="schiebenDescription">
    At least one puzzle piece has to be deleted. After that, the programm will slide the pieces in a random order.
    <br>
    After that, you can slide the pieces by clicking on the piece you want to move (you may have to click on the position you want it to be) until the pieces form the original image/video you put in!. 
  </p>
  <div id="futureModeSettingsHeader"></div>
  <div class="card cardGeneral" id="traditionalSettings">
    <b style="font-size: 25px;" id="modeSettingsHeading">mode specific settings: <br> </b>
    <br>
    <input id="clipOptionsSound" checked="true" type="checkbox"> acoustic feedback (play audio when an new option to connect puzzle peaces is suggested)
    <a id="vibrateA">
      <br>
      <input id="vibrate" type="checkbox"> haptic Feedback (vibrate when an new option to connect puzzle peaces is suggested)
    </a>
    <br>
    <input id="automaticTileSelectionReset" onclick=" tutorial.state = ''; document.onkeydown({key: 'F1', changeElement: true}); document.getElementById('tutorial').style.display = 'none'; localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" type="checkbox"> drag and drop control (release pieces when mouse button is released; <b>"alternative"</b>)
    <br>
    <p style="margin-bottom: 6px;" id="rotateTilesP">
    <input id="rotateTiles" onchange="if (checked) rotateTilesAdaptionSettings.style.display = 'none'; else {rotateTilesAdaptionSettings.style.display = 'block';}" checked="true" type="checkbox"> drehe Teile
    </p>
    <input id="markWrong" style="accent-color: red;" type="checkbox" > mark wrong connection suggestions
    <a id="shuffleStyleLable">
      <br>
      type of shuffling: 
    </a>
    <select onchange="shuffleStyleVisibilities(value);";  id="shuffleStyle">
      <option value="overlapTiles">spread pieces and let them overlap</option>
      <option value="listTiles">list pieces next to each other (pieces list)</option>
      <option value="nextToEachOther">put pieces next to each other with some distance</option>
    </select>
    <a id="shuffleHeadline" style="display: none;">
      <br>
      <br>
      <b style="font-size: 25px;">settings to the shuffling of the pieces:</b>
      <br>
    </a>
    <div style="display: none" class="card cardGeneral" id="EmptyTileBarDiv">
      <br>
      <input id="emptyTileBar" onchange="if (checked) emptyTileBarSettings.style.display = 'block'; else emptyTileBarSettings.style.display = 'none'; emptyTileBarShuffleStyleSelected(shuffleStyleBar.value);" type="checkbox">start with empty list
      <div style="display: none;" id="emptyTileBarSettings">
        shuffle the pieces in the following way: 
        <select onchange="emptyTileBarShuffleStyleSelected(value);" id="shuffleStyleBar">
          <option value="overlapTiles">spread pieces and let them overlap</option>
          <option value="nextToEachOther">put pieces next to each other with some distance</option>
        </select>
      </div>
      <div id="emptyTilebarTileGap"></div>
      <div id="tilesGapS" class="card cardGeneral" style="display: none;">
        <br>
        distance (in px): <input min="0" id="tilesGap" oninput="gapSizeChanged(value);" value="55" style="width: 55px;" type="number">
        <br>
        <br>
        <canvas id="gapCanvas"></canvas>
        <br>
        <input id="fillScreenTileGap" onchange="if (checked) aScrollXTileGap.style.display = 'none'; else aScrollXTileGap.style.display = 'inline';" checked="true" type="checkbox"> fill screen
        <br>
        <a style="display: none" id="aScrollXTileGap">
          <input id="tilesXTileGap" min="1" value="4" style="width: 55px;" type="number"> tiles next to each other
          <br>
        </a>
      </div>
      <br>
    </div>
    <div id="shuffleStyleTileGap"></div>
      <a id="hitboxCheckbox" style="display: none;"><input onchange="if (checked) tileColliderSettings.style.display = 'block'; else tileColliderSettings.style.display = 'none'; adaptExpandButtonPosition(); showHitboxes();" type="checkbox"> <b>show setting to edit hitboxes between pieces (to connect them)</b></a>
      <a id="tileColliderSettings" style="display: none;">
        <br>
        <input onchange="if (checked) {showHitboxes(); shortHaltColliderDiv.style.display = 'inline';} else shortHaltColliderDiv.style.display = 'none';" id="doHitboxAnimation" type="checkbox"> animation
        <br>
        <input id="highHitboxVisibility" type="checkbox"> Always display the blue line on the entire piece
        <div id="shortHaltColliderDiv" style="display: none;"><input id="shortHaltCollider" type="checkbox">stop briefly at the start point and end point of the collision</div>
        <br>
        hitbox width: <input type="range" min="1" oninput="showHitboxes();" id="hitboxWidth">
        <br>
        hitbox height: <input type="range" min="1" oninput="showHitboxes();" id="hitboxHeight">
        <br>
        <canvas id="hitboxTextur"></canvas>
      </a>
      <br>
      <input id="collideClip" checked="true" type="checkbox"> Do not allow pieces to attach to covered edges
      <br>
      <input checked="true" onchange="if (checked)  connectableSlightOverlap.value = 10; else connectableSlightOverlap.value = 0;" type="checkbox"> Offer connection options even if the pieces overlap slightly
      <input type="number" id="connectableSlightOverlap" value="10" style="display: none;">
      <p id="scrollOnBlancP"><input id="scrollOnBlanc" checked="true" type="checkbox"> Allow scrolling on empty background</p>
      <a>
        <div style="display: none;" class="card cardGeneral" id="listTilesS">
      <h3>Settings for the pieces list: </h3>
      <input type="checkbox" checked="true" onchange="backToBarVis(checked)"; id="BackToBarB"> buttons to bring pieces back into the list at the bottom
      <br>
      <div id="backToBarBSize">
        <input id="backToBarBWidth" oninput="changeBackToBarB('width', value)" type="range"> width of the buttons
        <br>
        <input id="backToBarBHeight" oninput="changeBackToBarB('height', value)" type="range"> height of the buttons
      </div>
      <br>
      <a id="tileBarHeightText">height of the pieces list</a>
      <button onclick="setDefaultSelectionBarHeight();" id="resetBarSize">reset</button>
      <input type="range" oninput="changeTileBarHeight(value);" min="25" id="tileBarHeight">
      <div id="autoSelectTileBarP">
        <input type="checkbox" checked="true" id="autoSelectTileBar">automatically select next piece in list
      </div>
    </div>
    <br>
    <b>trasparency of pieces</b>
    <br>
    <input type="range" value="1" oninput="layout(true, true);" id="tileTransparencySlider" max="1" min="0.01" step="0.01">
  </div>
  <div id="exchangeSettings" class="card cardGeneral" style="display: none">
  <p id="swipeSteuerungP"><input type="checkbox" onclick="tutorial.state = ''; document.onkeydown({key: 'F1', changeElement: true}); document.getElementById('tutorial').style.display = 'none';" id="swipeSteuerung"> begin swipe at first piece and end it at the second one to exchange their position</p>
  </div>
  <p id="schiebenSettings" class="card cardGeneral">
    <br>
    <strong style="font-size:15px;">the easiest way to control the difficulty is to change the amount of slides the computer does</strong>
    <br>
    let PC slide <input type="number" min="2" style="width: 55px;" id="anzahlVerschieben"> times: 
    <br>
    <input type="checkbox" onchange="if (checked) {anzahlVerschieben.style.display = 'none'; innerHTML.replace('_', ''); } else {anzahlVerschieben.style.display = 'inline'; innerHTML += '__'}" id="richtigeCheck"> slide until at most<input type="number" style="width:55px;" max="14" min="0" id="anzahlRichtige" value="10"> pieces stay at the original position
    <br>
    <input type="checkbox" id="zurrückVermeiden" checked="true"> <font size="5"> empty field 2 times in the same position prohibited after <input type="number" id="anzahlVerboten" value="3" style="width: 42px;"> times (raising this number makes it more difficult))</font>
    <!-- <input type="checkbox" id="difficultSchieben"> niemals eine verschiebng rückgängig machen (schwierig, weil immer viel verändert wird) -->
  </p>
  <a style="display: none;" id="turnsHistoryS">
    <br>
    <div id="movementPlayer" style="display: none;">
      <input onchange="changeMovementPlayerVis(checked);" type="checkbox"><b>look at computer moves</b>
      <div id="innerMovementPlayer" style="display: none;">
        <br>
        <input id="distinctMovement" onchange="movementStepsChanged(checked);" checked="true" onchange="" type="checkbox"> shortest solution the PC knows of
        <br>
        <button id="movementDirectionLeft" onclick="changeMovementDirection(-1);"><<</button>
        <button onclick="playMovementPos(objMovementPlayer.position - 1);"><</button>
        <button id="movementPlayButton" onclick="playPauseMovement();">play</button>
        <button onclick="playMovementPos(0);">⟲</button>
        <button onclick="playMovementPos(objMovementPlayer.position + 1);">></button>
        <button id="movementDirectionRight" style="background-color: hsla(180, 100%, 50%, 1);" onclick="changeMovementDirection(1);">>></button>
        <br>
        <input id="movementPosition" oninput="playMovementPos(value);" min="0" type="range"> position
        <button onclick="playMovementPos(getPlayerPosition());">go to your current position/game state (if existing)</button>
        <br>
        <b>speed</b>
        <br>
        quick <input min="155" value="500" max="1000" id="movementPlayerSpeed" type="range"> slow
        <button onclick="movementPlayerSpeed.value = 500;">reset</button>
        <br>
        <canvas id="movementPlayerTextur"></canvas>
      </div>
      <br>
    </div>
    <input onchange="if (checked) {userMovementPlayer.style.display = 'block'; generalSettings.style.display = 'none';} else {userMovementPlayer.style.display = 'none'; generalsettings.style.display = 'block';}" type="checkbox"> <b>go back to prior move:</b>
    <div class="cardGeneral card" style="display: none;" id="userMovementPlayer">
      <button onclick="if (userMovement.index - 1 >= 0) {userMovement.index--; playMovementPos(userMovement.index, null, null, userMovement.moves);}"><</button>
      <input id="playerMovementSlider" oninput="playMovementPos(value, null, null, userMovement.moves);" min="0" max="0" type="range">
      <button onclick="if (userMovement.index < userMovement.moves.length) {userMovement.index++; playMovementPos(userMovement.index, null, null, userMovement.moves);}">></button>
      <br>
      <input id="goBackAsTurns" type="checkbox"> count as extra move
    </div>
    <br>
    <input id="showRemovedTiles" type="checkbox"> Display deleted pieces as reference points in the correct position (if no piece has been moved to the position)
  </a>
  </div>
  <div id="generalSettings" class="card cardGeneral">
  <h2>general settings: </h2>
    <input type="checkbox" onchange="adaptExpandButtonPosition(); if (checked) rightMarkerSettings.style.display = 'block'; else rightMarkerSettings.style.display = 'none'; layout(true);" id="richtigPlazierte" style="accent-color: green;" checked="true"> mark correctly placed pieces
    <!-- <h3>general</h3> -->
    <div id="rightMarkerSettings" class="card cardGeneral">
      <input type="range" step="0.01" value="1" oninput="layout(true);" min="0.01" max="1" id="rightMarkerRadius"> radius from the middle (in %)
      <br>
  <input min="0.01" max="1" step="0.01" value="0.3" oninput="layout(true)" id="rightMarkerTransparence" type="range"> transparency (in %)
  <br>
  color: <input type="color" oninput="layout();" id="markRightColor" value="#00FF00">
    </div>
    <br>
  <input type="checkbox" id="raender" onchange="adaptExpandButtonPosition(); if (checked) randSettings.style.display = 'block'; else randSettings.style.display = 'none'; if (preview.src != '') layout(true, true);"> <font size="5"> show edges of puzzle</font>
  <div id="randSettings" class="card cardGeneral">
    <input type="range" min="1" value="13" oninput="randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - value; layout();" id="breiteRand"> width of the shown edges
    <br>
    <input type="range" min="0" value="0" oninput="layout();" id="randPosition"> position of the edges
    <br>
    <input type="range" min="0.01" max="1" step="0.01" value="0.35" oninput="layout();" id="borderTransparency"> transparancy of the edges
    <br>
    color: <input type="color" id="borderColor" oninput="layout();" value="#0000FF">
  </div>
  <!-- <input type="checkbox" onchange="if (checked == true) {schiebensettings.style.display = 'block'; swipeSteuerungP.style.display = 'none';} else {schiebenSettings.style.display = 'none'; swipeSteuerungP.style.display = 'inline';}" id="schieben"> <font size="5">nur schieben</font> -->
  <br>
  <input id="reloadWhenFinished" onchange="localStorage.setItem('reloadWhenFinished', checked)" type="checkbox">reload the page automatically shortly after finishing a puzzle
  <br>
  <input id="keepScrolling" checked="true" type="checkbox"> automatic scrolling (scroll in the direction of the edge until the piece is unselected or away from the edge)
  <br>
  <button type="button" id="aufgebenId" onclick="showCurrentStats(modeSelection.value);" name="button">view current statistics</button>
  <br>
  <div id="videoControlsInSettings"></div>
<p id="showOriginalP" style="display:none">
  <input id="showOriginal"  onchange="originalDisplayChanged(checked)" type="checkbox"> view original
  <br>
  <img style="display: none;" id="preview">
  <canvas style="display: none;" id="videoPreview"></canvas>
</p>
<div id="futurePuzzleManager"></div>
</div>
<br>
</div>
<button type="button" id="removeTilesFinishedB" style="display: none; font-size: 33px" onclick="shufflePuzzle();" name="button">done</button>
<a id="tileStatusOptions" style="display: none; position: fixed; background-color: rgba(205, 218, 199, 0.77); border-radius: 5px;">
<input type="radio" id="pRemoveTile" checked="true" style="accent-color: red;" name="tileStatus"> delete piece
<input type="radio" id="doNotMoveTile" style="accent-color: blue;" name="tileStatus"> don't move piece when shuffling
</a>
<div id="futureTexturPosition"></div>
<br>
<br>
<button onclick="expandSide('top');" style="height: 55px;" class="expandButtons" id="expandTop">+</button>
<button onclick="expandSide('right');" style="width: 55px;" class="expandButtons" id="expandRight">+</button>
<button onclick="expandSide('left');" style="width: 55px;" class="expandButtons" id="expandLeft">+</button>
<br>
<button class="expandButtons" style="height: 55px;" onclick="expandSide('bottom');" id="expandBottom">+</button>
<canvas id="tileSelectionCanvas" style="display: none;" onmousedown="mouseDown(true);" onmouseup="mouseUp();" width="1" height="1"></canvas>
<div class="expandButtons" id="backToBarButtons">
</div>
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.6'" id="scrollTileSelectionRight" onclick="scrollTileSelection(1, 'elm');">
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.6'" id="scrollTileSelectionLeft" onclick="scrollTileSelection(-1, 'elm');">
<style>
  .dropdown {
position: relative;
display: inline-block;
}

.dropdown-content {
display: none;
position: absolute;
background-color: #f1f1f1;
min-width: 160px;
box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
z-index: 1;
}

.dropdown-content a {
color: black;
padding: 12px 16px;
text-decoration: none;
display: block;
}

.dropdown-content a:hover {background-color: #ddd;}
</style>
<style>
  #tileSelectionCanvas {
    /* position: -webkit-sticky; */
    position: fixed;
    bottom: 0px;
    overflow: hidden;
    background-color: hsla(0, 0%, 64%, 0.77);
    touch-action: none;
  }
  #scrollTileSelectionRight {
    position: fixed;
    right: 0px;
    opacity: 0.6;
    display: none;
  }
  #scrollTileSelectionLeft {
    position: fixed;
    left: 0px;
    opacity: 0.6;
    transform: rotate(180deg);
    display: none;
  }

  .backToTileB {
    position: fixed;
  }
  .expandButtons {
    display: none;
    font-size: 55px;
    position: absolute;

  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  }
</style>
<style name="bubbleStyle">
  /* (A) SPEECH BOX */
  .speech {
    /* (A1) FONT */
    font-family: arial, sans-serif;
    /* font-size: 0.5em; */
    /* font-size: 0.7em; */
    /* font-size: 1vw; */
    /* font-size: 25px; */
    font-size: 5vh;
  
    /* (A2) COLORS */
    color: #fff;
    background: blue;
  
    /* (A3) DIMENSIONS + POSITION */
    position: absolute;
    padding: 20px;
    border-radius: 10px;
    max-width: 320px;
    z-index: 2;
  }
  
  /* (B) ADD SPEECH "CALLOUT TAIL" */
  /* (B1) USE ::AFTER TO CREATE THE "TAIL" */
  .speech::after {
    /* (B1-1) ATTACH TRANSPARENT BORDERS */
    content: "";
    border: 20px solid transparent;
  
    /* (B1-2) NECESSARY TO POSITION THE "TAIL" */
    position: absolute;
  }
  
  /* (B2) BOTTOM "CALLOUT TAIL" */
  .bottom.speech::after {
    /* (B2-1) DOWN TRIANGLE */
    border-top-color: blue;
    border-bottom: 0;
  
    /* (B2-2) POSITION AT BOTTOM */
    bottom: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C) DIFFERENT TAIL POSITIONS */
  /* (C1) TOP */
  .top.speech::after {
    /* (C1-1) UP TRIANGLE */
    border-bottom-color: blue;
    border-top: 0;
  
    /* (C1-2) POSITION AT TOP */
    top: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C2) LEFT */
  .left.speech::after {
    /* (C2-1) LEFT TRIANGLE */
    border-right-color: blue;
    border-left: 0;
  
    /* (C2-2) POSITION AT LEFT */
    left: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (C3) RIGHT */
  .right.speech::after {
    /* (C3-1) RIGHT TRIANGLE */
    border-left-color: blue;
    border-right: 0;
  
    /* (C3-2) POSITION AT RIGHT */
    right: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (X) DOES NOT MATTER - SPACERS */
  /* .speech, .circular { margin: 50px 0 0 50px; } */
  body { padding-bottom: 100px; }
  
  </style>
  <style>
    #tutorial {
      background-color: rgba(205, 218, 199, 0.77);
      position: fixed;
      right: 0px;
      top: 0px;
      width: 47%;
      box-shadow: 2px 2px 20px #855d5d;
      display: none;
      overflow-y: scroll;
      scroll-behavior: smooth;
    }
    .card {
      box-shadow: 2px 2px 10px #855d5d;
      padding-top: 5px;
      padding-bottom: 5px;
      margin-top: 7px;
      margin-bottom: 7px;
      /* display: none; */
    }
    .cardGeneral {
      border-radius: 10px;
      padding-left: 10px;
      padding-right: 10px;
    }
    .currentTutorialStep {
      box-shadow: 2px 2px 10px red;
      margin-top: 3px;
      margin-bottom: 3px;
    }
    /* custom scrollbar */
    ::-webkit-scrollbar {
  width: 1vw;
}
::-webkit-scrollbar-track {
  border-radius: 100vw;
  background: hsla(0, 0%, 72%, 0.19);
  margin-block: 10px;
}
::-webkit-scrollbar-thumb {
  background: hsla(0, 0%, 72%, 0.55);
  border-radius: 100vw;
}
::-webkit-scrollbar-thumb:hover {
  background: hsla(0, 0%, 65%, 0.55);
}
::-webkit-scrollbar-corner {
  background: rgba(0,0,0,0);
}
/* TODO: option to change settings in tutorial itself */
  </style>
  <div id="tutorial" class="cardGeneral">
    <a id="scrollToTutorial"></a>
    <div class="card cardGeneral">
      <!-- TODO: weiter übersetzen -->
      <b>Settings during the tutorial</b>
      <br>
      You can change almost all settings during the tutorial! The tutorial will draw your attention to the important ones, but you are welcome to have a look or try them out yourself.
    </div>
    <div id="traditionalTutorial">
      <!-- PC -->
    <div style="display: none;" id="traditionalTutorialPC">
    <div class="card cardGeneral section" id="moveTutorial">
      <h2>Move and rotate pieces</h2>
      <button onclick="goToTutorialIndex(this);">start here or continue</button>
      <div class="card cardGeneral">
        <!-- TODO: standardmäßig quadratische Teile oder Originalgröße einstellbar (ausversehen auf Originalgröße abgeändert) -->
        <b>Information on rotating pieces</b>
        <br>
        If it is not edited in the settings, the pieces must be rotated to fit. Therefore, when loading an image or video, the width and height are automatically equalized. If you change the width or height of the image or video, you can still rotate the pieces, but only connect them on the logical two sides.
        <br>
        You can also rotate the pieces in the pieces list mentioned later using the arrow keys while holding down the mouse button or double-clicking on the touchpad.
      </div>
      <div class="card cardGeneral" id="moveStandardPC">
        <input type="radio" id="moveStyleStandard" onclick="unclippStandard.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {goTutorialSteps(1); automaticTileSelectionReset.checked = !checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', !checked);" name="moveStyle"> <b>Standard</b>
        <div id="tileClickMoveTutorialDiv"><input type="checkbox" id="tileClickMoveTutorial" onclick="checked = !checked"> Click on the desired tile. </div>
        <div id="moveMouseMoveTutorialDiv"><input type="checkbox" id="moveMouseMoveTutorial" onclick="checked = !checked"> Then move the mouse pointer to move the piece. </div>
        <div id="rotateTileTutorialDiv"><input type="checkbox" id="rotateTileTutorial" onclick="checked = !checked"> Press the left or right arrow key to rotate the piece to the left or right.</div>
        <div id="clickUnselectMoveTutorialDiv"><input type="checkbox" id="clickUnselectMoveTutorial" onclick="checked = !checked"> You can release/unselect the piece by clicking on it again.</div>
      </div>
      <div class="card cardGeneral" id="moveAlternativePC">
        <input type="radio" id="moveStyleAlternative" onclick="unclippAlternative.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {goTutorialSteps(1); automaticTileSelectionReset.checked = checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" name="moveStyle"> <b>Alternative (drag and drop)</b>
        <div id="holdMouseMoveTutorialDiv"><input type="checkbox" id="holdMouseMoveTutorial" onclick="checked = !checked"> Hold down the mouse button (or double-click and keep your finger on the touchpad).</div>
        <div id="moveMouseMoveTutorialAlternativeDiv"><input type="checkbox" id="moveMouseMoveTutorialAlternative" onclick="checked = !checked"> Move the mouse pointer to move the piece. </div>
        <div id="rotateTileTutorialAlternativeDiv"><input type="checkbox" id="rotateTileTutorialAlternative" onclick="checked = !checked"> Press the left or right arrow key to rotate the piece to the left or right. </div>
        <div id="releaseMoveTutorialDiv"><input type="checkbox" id="releaseMoveTutorial" onclick="checked = !checked"> Release the button or touchpad. </div>
      </div>
      <div id="moveStyleSettingChosenDiv"><input id="moveStyleSettingChosen" type="checkbox" onclick="checked = !checked"> Select above whether you want the default or the alternative. You can change this setting at any time in the settings menu. </div>
    </div>
      <div class="card cardGeneral section" id="clippTutorial">
      <h2>Connecting and disconnecting pieces</h2>
      <div class="card cardGeneral" id="connectTiles">
        <h3>Connect pieces</h3>
        <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <div id="clippingInfos">
            <div class="card cardGeneral">
              <b style="font-size: 15px;">Hitboxes</b>
              <br>
              In the settings, you have the option of reducing the size of the hitboxes, which means you have to be closer to the piece for the connection to be offered. This can help, for example, if you are overwhelmed by the amount of suggestions or frequently connect pieces by mistake. Conversely, you can also enlarge the hitbox so that you don't have to move the pieces so far.
            </div>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">Connection options for piece collisions are not offered by default</b>
            <br>
            If a piece is lying on top of the edge of another tile you want to connect to, it won't sugest the connection by default, but if you want it to, you can change the option in the settings ("Do not allow pieces to attach to covered edges")
          </div>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">Mark incorrect and correct</b>
            <br>
            If pieces are too similar, you can remove them in advance or have them marked as not matching when a connection is suggested.
            <br>
            By default, only whether a piece is correct is marked (all necessary pieces must already be around it)
          </div>
        </div>
        <div class="card cardGeneral">
        <div id="selectTileConnectTileTutorialDiv"><input type="checkbox" id="selectTileConnectTileTutorial" onclick="checked = !checked"> Select a piece. </div>
        <div id="getClippingOptionConnectTileTutorialDiv"><input type="checkbox" id="getClippingOptionConnectTileTutorial" onclick="checked = !checked"> Approach another piece. </div>
        <div id="clipTileTutorialDiv"><input type="checkbox" id="clipTileTutorial" onclick="checked = !checked"> Unselect the piece (release your finger from the screen) when you see a blue line to connect it to the other piece. </div>
        </div>
        <div id="clippSecondTutorialDiv"><input id="clippSecondTutorial" type="checkbox" onclick="checked = !checked"> Connect two more pieces to the already connected ones. </div>
      </div>
      <div class="card cardGeneral section" id="disconnectTiles">
        <h3>Disconnect pieces</h3>
        <button id="contineTutorialUnclippPC" onclick="goToTutorialIndex(this);">start here or continue</button>
        <div class="card cardGeneral">
          <b style="font-size: 15px;">Information shift button</b>
          <br>
          As long as you press the shift key, you can select as many pieces as you like and then move them. They can only be unselected again after you have released the button.
        </div>
        <div id="moveStyleStandardUnclipp" class="card cardGeneral">
          <input type="radio" onclick="moveStyleStandard.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {tutorial.state = 'selectTileConnectTileTutorial'; automaticTileSelectionReset.checked = !checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', !checked);" id="unclippStandard" name="unclippStyle"><b> Default (linked to default for moving the pieces) </b>
          <div id="pressShiftStandardUnclippTutorialDiv"><input type="checkbox" id="pressShiftStandardUnclippTutorial" onclick="checked = !checked"> Press the shift key. </div>
          <div id="selectTileStandardUnclippTutorialDiv"><input type="checkbox" id="selectTileStandardUnclippTutorial" onclick="checked = !checked"> Select a piece (any amount possible outside the tutorial) that is connected to another. </div>
          <div id="releaseShiftStandardUnclippTutorialDiv"><input type="checkbox" id="releaseShiftStandardUnclippTutorial" onclick="checked = !checked"> Release the shift key. </div>
          <div id="unclippStandardTutorialDiv"><input type="checkbox" id="unclippStandardTutorial" onclick="checked = !checked"> Move the mouse pointer to release the pieces. </div>
          <div id="unselectUnclippStandardTutorialDiv"><input type="checkbox" id="unselectUnclippStandardTutorial" onclick="checked = !checked"> Click to unselect the selected pieces. </div>
        </div>
        <div id="moveStyleAlternativeUnclipp" class="card cardGeneral">
          <input type="radio" onclick="moveStyleAlternative.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {tutorial.state = 'selectTileConnectTileTutorial'; automaticTileSelectionReset.checked = checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" id="unclippAlternative" name="unclippStyle"> <b>Alternative (connected with alternative for moving the pieces)</b>
          <div id="pressShiftAlternativeUnclippTutorialDiv"><input type="checkbox" id="pressShiftAlternativeUnclippTutorial" onclick="checked = !checked"> Press the shift key. </div>
          <div id="selectTileAlternativeUnclippTutorialDiv"><input type="checkbox" id="selectTileAlternativeUnclippTutorial" onclick="checked = !checked"> Select a piece (any amount possible outside the tutorial) that is connected to another one and hold the left mouse key down</div>
          <div id="unclippTileAlternativeUnclippTutorialDiv"><input type="checkbox" id="unclippTileAlternativeUnclippTutorial" onclick="checked = !checked"> Move the mouse pointer to detach the pieces. </div>
          <div id="releaseShiftAlternativeUnclippTutorialDiv"><input type="checkbox" id="releaseShiftAlternativeUnclippTutorial" onclick="checked = !checked"> Release the shift key. </div>
          <div id="unselectAlternativeUnclippTutorialDiv"><input type="checkbox" id="unselectAlternativeUnclippTutorial" onclick="checked = !checked"> Release the touchpad or mouse button to unselect the piece. </div>
        </div>
      </div>
    </div>
    <div class="card cardGeneral section" id="generalSkills">
      <h2>General skills</h2>
      <button onclick="goToTutorialIndex(this);">start here or continue</button>
      <div class="card cardGeneral">
        <h3>zoom</h3>
        As on any other website, you can zoom in and out. The usual is Ctrl + "-" to zoom out and Ctrl + "+" to zoom in (you can also use the mouse wheel instead of plus and minus). This gives you a better overview of the "playing field", but you also have smaller pieces and vice versa.
      </div>
      <div id="scrollTutorial" class="card cardGeneral">
        <b style="font-size: 21px;">scrolling</b>
        <br>
        <div class="card cardGeneral" id="manualScrollingTutorial">
          <h3>manual scrolling</h3>
          <div id="selectTileScrollingTutorialDiv"><input type="checkbox" id="selectTileScrollingTutorial" onclick="checked = !checked">Select piece (if you want to use 2 finger gesture with the left mouse button)</div>
          <div id="manuallyScrollingTutorialDiv"><input type="checkbox" id="manuallyScrollingTutorial" onclick="checked = !checked">Scroll (e.g. with 2 finger gesture on the touchpad or with the mouse wheel)</div>
          <div id="unselectTileScrollingTutorialDiv"><input type="checkbox" id="unselectTileScrollingTutorial" onclick="checked = !checked">Unselect piece</div>
        </div>
        <div class="card cardGeneral" id="autoScrollTutorial">
          <h3>automatic scrolling</h3>
          <div id="selectTileAutomaticScrollingTutorialDiv"><input type="checkbox" id="selectTileAutomaticScrollingTutorial" onclick="checked = !checked">Select piece</div>
          <div id="automaticScrollingTutorialDiv"><input type="checkbox" id="automaticScrollingTutorial" onclick="checked = !checked">move the piece down so that more than half of the piece has left the screen (all directions possible outside the tutorial)</div>
          <!-- TODO: move away from the edge -->
          <div id="stopScrollingAutomaticScrollingTutorialDiv"><input type="checkbox" id="stopScrollingAutomaticScrollingTutorial" onclick="checked = !checked">Unselect the piece or move it away from the edge to stop scrolling</div>
        </div>
      </div>
    </div>
      <div class="card cardGeneral section" id="tileSelectionBarTutorial">
        <h3>The pieces list</h3>
        <div class="card cardGeneral">
          <b>Information on the preparation of the pieces (incl. pieces list)</b>
          <br>
          In the settings, you can select how the pieces are prepared. They can be distributed (with overlapping), placed in the pieces list, which is the subject of the following section, or placed next to each other on the playing field. You can also start with an empty list so that you can sort the pieces in the list or keep selected ones on the playing field.
        </div>
        <div class="card cardGeneral">
          <b>Additional settings</b>
          <br>
          There are additional settings for the pieces list that you can now view.
        </div>
        <div class="card cardGeneral" id="controlTileBarScrollTutorial">
          <h3>Scrolling in the pieces list</h3>
          <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <div id="scrollArrowTileBarTutorialDiv"><input type="checkbox" id="scrollArrowTileBarTutorial" onclick="checked = !checked">Scroll by clicking on the red (semi-transparent) arrows at the edges of the screen (become more visible when you touch them with the mouse)</div>
          <div class="card cardGeneral" id="scrollWithMouse">
            <h4 id="scrollTilelistSwipeTutorial">Scrolling with the mouse button</h4>
            <div id="MouseDownScrollTileBarTutorialDiv"><input type="checkbox" id="MouseDownScrollTileBarTutorial" onclick="checked = !checked">Press the mouse button or double-click on the touchpad and hold it down or leave your finger on the touchpad</div>
            <div id="moveMouseScrollTileSelectionBarTutorialDiv"><input type="checkbox" id="moveMouseScrollTileSelectionBarTutorial" onclick="checked = !checked">Move the pointer to move the list in the corresponding direction </div>
            <div id="stopScrollingTileBarTutorialDiv"><input type="checkbox" id="stopScrollingTileBarTutorial" onclick="checked = !checked">Release the mouse button or touchpad</div>
          </div>
          <div id="ScrollkeyTileBarTutorialDiv"><input type="checkbox" id="ScrollkeyTileBarTutorial" onclick="checked = !checked">Scroll by pressing the left or right arrow key (mouse pointer must be on list)</div>
        </div>
        <div class="card cardGeneral section" id="leaveTileBarTutorial">
          <h3>Move pieces to "playing field"</h3>
          <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">automatically select next piece</b>
            <br>
            <!-- TODO: besser ausdrücken -->
            On the PC, the next piece in the pieces list is selected by default, but not on mobile devices. As long as you have selected a piece on the "playing field", no piece will be removed from the pieces list. You can also change this in the settings.
          </div>
          <div class="card cardGeneral" id="leaveTileBarTutorial">
            <div id="selectTileBarTileTutorialDiv"><input type="checkbox" id="selectTileBarTileTutorial" onclick="checked = !checked">Click on a piece in the list to select it.</div>
            <div id="placeTileOnFiledTutorialDiv"><input type="checkbox" id="placeTileOnFiledTutorial" onclick="checked = !checked">Click on the "field" to "place" the piece there. </div>
            <div id="unselecTileAfterTileBarTilePlacementTutorialDiv"><input type="checkbox" id="unselecTileAfterTileBarTilePlacementTutorial" onclick="checked = !checked">Unselect the piece.</div>
          </div>
          <div id="SecondPlaceTileTutorialDiv"><input type="checkbox" id="SecondPlaceTileTutorial" onclick="checked = !checked">Drop another tile on the playing field.</div>
        </div>
        <div class="card cardGeneral section" id="backToBarTutorial">
          <h3>Bring pieces back to the pieces list</h3>
          <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <div class="card cardGeneral" id="backToBarPlusBTutorial">
            <h4>with "+" button</h4>
            <div id="BackToTileBarTutorialDiv"><input type="checkbox" id="BackToTileBarTutorial" onclick="checked = !checked">Click on one of the "+" buttons</div>
            <div id="backToTileBarPlusBTutorialDiv"><input type="checkbox" id="backToTileBarPlusBTutorial" onclick="checked = !checked">Click on a piece to bring it back into the pieces list at the selected position. </div>
          </div>
          <div class="card cardGeneral" id="backToBarBTutorial">
            <h4>with "back to piece list" button</h4>
            <div id="selectTileTileBarBackToBarTutorialDiv"><input type="checkbox" id="selectTileTileBarBackToBarTutorial" onclick="checked = !checked">Select a piece in the pieces list. The new piece will be added to the right of the selected piece. </div>
            <div id="clickBackToBarBTurotialDiv"><input type="checkbox" id="clickBackToBarBTurotial" onclick="checked = !checked">Click on the "back to piece list" button (top left of the screen, can only be activated if a piece is on the "playing field"). </div>
            <div id="selectBackToBarTileZurückInLeisteTutorialDiv"><input type="checkbox" id="selectBackToBarTileZurückInLeisteTutorial" onclick="checked = !checked">Click on the piece you want to retrieve. </div>
            <div class="card cardGeneral">
              <b style="font-size: 15px;">automatic position selection</b>
              <br>
              If you have not selected a piece and still press the button, the selected piece will be appended to the end of the list.
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Handy -->
    <div id="traditionalTutorialHandy" style="display: none;">
      <div class="card cardGeneral section" id="moveTutorial">
        <h2>Move pieces</h2>
        <button onclick="goToTutorialIndex(this);">start here or continue</button>
        <div class="card cardGeneral">
          <div id="selectTileMobileTurorialDiv"><input type="checkbox" id="selectTileMobileTurorial" onclick="checked = !checked"> Place your finger on a piece. </div>
          <div id="moveTileMobileTutorialDiv"><input type="checkbox" id="moveTileMobileTutorial" onclick="checked = !checked"> Then move your finger to move the piece. </div>
          <div id="releaseTileMobileTutorialDiv"><input type="checkbox" id="releaseTileMobileTutorial" onclick="checked = !checked"> Lift your finger off the screen to unselect the piece. </div>
        </div>
      </div>
        <div class="card cardGeneral section" id="clippTutorial">
        <h2>Connecting and disconnecting pieces</h2>
        <div class="card cardGeneral" id="connectTiles">
          <h3>Connect tiles</h3>
          <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <div id="clippingInfosMobile"></div>
          <div class="card cardGeneral">
          <div id="selectTileConnectTileMobileTutorialDiv"><input type="checkbox" id="selectTileConnectTileMobileTutorial" onclick="checked = !checked"> Select a piece. </div>
          <div id="getClippingOptionConnectTileMobileTutorialDiv"><input type="checkbox" id="getClippingOptionConnectTileMobileTutorial" onclick="checked = !checked"> Approach another piece. </div>
          <div id="clipTileMobileTutorialDiv"><input type="checkbox" id="clipTileMobileTutorial" onclick="checked = !checked"> unselect the piece when you see a blue line to connect it to the other piece. </div>
          </div>
          <div id="clippSecondMobileTutorialDiv"><input id="clippSecondMobileTutorial" type="checkbox" onclick="checked = !checked"> Connect three more pieces to the ones already connected. </div>
        </div>
        <div class="card cardGeneral section" id="disconnectTiles">
          <h3>Disconnect tiles</h3>
          <button id="contineTutorialUnclippMobile" onclick="goToTutorialIndex(this);">start here or continue</button>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">General note</b>
            <br>
            If you have trouble clicking on the elements at the top of the bar (scroll, rotate, shift key), try clicking a little further down, even if you click outside the displayed element, that may be just the right place to click.
          </div>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">Information shift button</b>
            <br>
            As long as you press the shift key, you can select as many pieces as you like and then move them. They can only be deselected again after you have released the button.
          </div>
          <div class="card cardGeneral">
            <div id="pressShiftMobileUnclippTutorialDiv"><input type="checkbox" id="pressShiftMobileUnclippTutorial" onclick="checked = !checked"> Press the "shift key". </div>
            <div id="selectTileMobileShiftUnclippTutorialDiv"><input type="checkbox" id="selectTileMobileShiftUnclippTutorial" onclick="checked = !checked"> Place your finger on a piece that is connected to another. </div>
            <div id="moveTileShiftUnclippTutorialDiv"><input type="checkbox" id="moveTileShiftUnclippTutorial" onclick="checked = !checked"> Move the piece with your finger. </div>
            <div id="releaseFingerMobileShiftTutorialDiv"><input type="checkbox" id="releaseFingerMobileShiftTutorial" onclick="checked = !checked"> Release your finger from the screen.</div>
          </div>
          <div class="card cardGeneral">
            <b>Multiple selection (also possible without detaching)</b>
            <br>
            <button onclick="goToTutorialIndex(this);">start here or continue</button>
            <br>
            <div id="pressShiftMobileMultipleUnclippTutorialDiv"><input type="checkbox" id="pressShiftMobileMultipleUnclippTutorial" onclick="checked = !checked"> Press the "shift key". </div>
            <div id="selectTileMobileShiftMultipleUnclippTutorialDiv"><input type="checkbox" id="selectTileMobileShiftMultipleUnclippTutorial" onclick="checked = !checked"> Click on two pieces that are connected to each other and have a connection to another piece (any number possible outside the tutorial) that you want to separate from the rest. </div>
            <div id="moveTileShiftMultipleUnclippTutorialDiv"><input type="checkbox" id="moveTileShiftMultipleUnclippTutorial" onclick="checked = !checked"> Move one of the selected pieces with your finger. </div>
            <div id="releaseFingerMobileMultiShiftTutorialDiv"><input type="checkbox" id="releaseFingerMobileMultiShiftTutorial" onclick="checked = !checked"> Release your finger from the screen.</div>
          </div>
          <div class="card cardGeneral">
            <div id="twoFingersDownUnclippTutorialDiv"><input type="checkbox" id="twoFingersDownUnclippTutorial" onclick="checked = !checked"> Place two fingers on the piece you want to unclip. (must be connected to at least one other piece)</div>
            <div id="releaseTwoFingersUnclippTutorialDiv"><input type="checkbox" id="releaseTwoFingersUnclippTutorial" onclick="checked = !checked"> Release your fingers from the screen. </div>
            <div id="selectTileMobileTwoFingersUnclippTutorialDiv"><input type="checkbox" id="selectTileMobileTwoFingersUnclippTutorial" onclick="checked = !checked"> Place your finger on the detached piece. </div>
            <div id="moveTileTwoFingersUnclippTutorialDiv"><input type="checkbox" id="moveTileTwoFingersUnclippTutorial" onclick="checked = !checked"> Move the detached piece with your finger. </div>
            <div id="releaseFingerMobileTwoFingersTutorialDiv"><input type="checkbox" id="releaseFingerMobileTwoFingersTutorial" onclick="checked = !checked"> Release the finger from the screen.</div>
          </div>
        </div>
      </div>
      <div class="card cardGeneral section" id="generalSkills">
        <h2>General skills</h2>
        <div id="scrollTutorial" class="card cardGeneral">
          <b style="font-size: 21px;">scroll and zoom</b>
          <br>
          <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <br>
          <div class="card cardGeneral" id="manualScrollingTutorial">
            <h3>Manual scrolling and zooming</h3>
            <div class="card cardGeneral">
              <b style="font-size: 15px;">on an empty background</b>
              <br>
              In the settings, you have the option to set that you can always scroll on an empty or white background (without checking the "scroll" box)
            </div>
            <!-- TODO: speech bubble -->
            <div id="selectScrollScrollingTutorialDiv"><input type="checkbox" id="selectScrollScrollingTutorial" onclick="checked = !checked">Select "scroll" on the top of your screen</div>
            <div id="scrollMobileScrollingTutorialDiv"><input type="checkbox" id="scrollMobileScrollingTutorial" onclick="checked = !checked">Scroll</div>
            <div id="zoomInTutorialDiv"><input type="checkbox" id="zoomInTutorial" onclick="checked = !checked">Zoom in (without ticking "scroll" not possible)</div>
            <div id="zoomOutTutorialDiv"><input type="checkbox" id="zoomOutTutorial" onclick="checked = !checked">zoom out as far as possible (without checking "scroll" not possible)</div>
            <div id="unselectScrollScrollingTutorialDiv"><input type="checkbox" id="unselectScrollScrollingTutorial" onclick="checked = !checked">unselect "scroll"</div>
          </div>
          <div id="autoScrollMobileTutorial"></div>
        </div>
        <div class="card cardGeneral section">
          <h3>rotate</h3>
          <button onclick="goToTutorialIndex(this);">start here or continue</button>
          <div class="card cardGeneral">
            <b>Information on rotating pieces</b>
            <!-- TODO: information: shift to rotate when already attached to other one -->
            <br>
            If it is not edited in the settings, the pieces must be rotated to fit. Therefore, when loading an image or video, the width and height are automatically equalized. If you change the width or height of the image or video, you can still rotate the piece, but you can only connect it at the logical sides.
            <br>
            After activating the rotation function at the top of the bar, you can also rotate the pieces in the pieces bar mentioned later by clicking on the pieces until you have deselected the function.
          </div>
          <div id="activateRotateLeftTutorialDiv"><input type="checkbox" id="activateRotateLeftTutorial" onclick="checked = !checked"> Activate rotation to the left.</div>
          <div id="rotateLeftMobileTutorialDiv"><input type="checkbox" id="rotateLeftMobileTutorial" onclick="checked = !checked"> Click on the piece(s) you want to rotate.</div>
          <div id="activateRotateRightTutorialDiv"><input type="checkbox" id="activateRotateRightTutorial" onclick="checked = !checked"> Activate rotate to the right.</div>
          <div id="rotateRightMobileTutorialDiv"><input type="checkbox" id="rotateRightMobileTutorial" onclick="checked = !checked"> Click on the piece(s) you want to rotate.</div>
          <div id="deactivateRotateRightTutorialDiv"><input type="checkbox" id="deactivateRotateRightTutorial" onclick="checked = !checked"> Deactivate rotation to the right.</div>
        </div>
      </div>
      <div id="tileSelectionBarMobileTutorial"></div>
    </div>
    <div id="completePuzzleTutorialDiv" class="section">
      <input type="checkbox" id="completePuzzleTutorial" onclick="checked = !checked">Complete the puzzle.
    </div>
</div>
<div id="exchangeTutorial" style="display: none;" class="cardGeneral">
  <div class="card cardGeneral section">
    <h1>Exchange pieces</h1>
    <div class="card cardGeneral">
      <div id="moveStyleStandardExchangeDiv" class="card cardGeneral">
        <input type="radio" id="moveStyleStandardExchange" onclick="localStorage.setItem('swipeExchangePuzzleCreator', !checked);" name="moveStyle">
      <b>Standard control</b>
      <div id="selectFirstExchangeNormalTutorialDiv"><input type="checkbox" id="selectFirstExchangeNormalTutorial" onclick="checked = !checked"> Click on the first piece to be exchanged.</div>
      <div id="selectSecondExchangeNormalTutorialDiv"><input type="checkbox" id="selectSecondExchangeNormalTutorial" onclick="checked = !checked"> Click on the second piece to select it and exchange the two selected pieces. </div>
    </div>
    <div id="moveStyleAlternativeExchange" class="card cardGeneral">
      <input type="radio" onclick="localStorage.setItem('swipeExchangePuzzleCreator', !checked);" name="moveStyle">
      <b>Alternative control (standard control can also be used or is included here)</b>
      <div id="mouseDownSelectFirstExchangeAlternativeTutorialDiv"><input type="checkbox" id="mouseDownSelectFirstExchangeAlternativeTutorial" onclick="checked = !checked"> Press and hold the mouse button or finger on the screen.</div>
      <div id="mouseMoveExchangeAlternativeTutorialDiv"><input type="checkbox" id="mouseMoveExchangeAlternativeTutorial" onclick="checked = !checked"> Move the mouse or finger to the piece with which you want to exchange the first selected piece.</div>
      <div id="mouseUpExchangeAlternativeTutorialDiv"><input type="checkbox" id="mouseUpExchangeAlternativeTutorial" onclick="checked = !checked"> Release the mouse button or the screen.</div>
    </div>
    <h1>Deselect the selection</h1>
    <div id="standardUnselectExchangeTutorial" class="card cardGeneral">
      <b>Standard control</b>
      <div id="selectTileUnselectStandardTutorialDiv"><input type="checkbox" id="selectTileUnselectStandardTutorial" onclick="checked = !checked"> Click on the first piece to be exchanged.</div>
      <div id="unselectTileUnselectStandardTutorialDiv"><input type="checkbox" id="unselectTileUnselectStandardTutorial" onclick="checked = !checked"> Click on it again to unselect it. </div>
    </div>
    <div id="alternativeUnselectExchangeTutorial" class="card cardGeneral">
      <b>Alternative control (standard control can also be used or is included here)</b>
        <div id="mouseDownUnselectAlternativeTutorialDiv"><input type="checkbox" id="mouseDownUnselectAlternativeTutorial" onclick="checked = !checked"> Press and hold the mouse button or finger on the screen.</div>
        <div id="moveMouseOutUnselectAlternativeTutorialDiv"><input type="checkbox" id="moveMouseOutUnselectAlternativeTutorial" onclick="checked = !checked"> Move the mouse or finger to another piece.</div>
        <div id="moveMouseInUnselectAlternativeTutorialDiv"><input type="checkbox" id="moveMouseInUnselectAlternativeTutorial" onclick="checked = !checked"> Move the mouse or finger to the first selected piece.</div>
        <div id="releaseMouseUnselectAlternativeTutorialDiv"><input type="checkbox" id="releaseMouseUnselectAlternativeTutorial" onclick="checked = !checked"> Release on the piece you started on to unselect the selection.</div>
        <div class="card cardGeneral">
          If you are still on the piece you selected first, you can also release the mouse button or finger immediately and click again to unselect the piece.
        </div>
    </div>
  </div>
</div>
</div>
<div id="schiebenTutorial" style="display: none;" class="cardGeneral">
  <div class="card cardGeneral section">
    <h1>Sliding pieces</h1>
    <div class="card cardGeneral">
      <b>Moving an option</b>
      <div id="moveNormalTurorialDiv"><input type="checkbox" id="schiebenNormalTurorial" onclick="checked = !checked"> Click on a piece next to the gap to move it into the gap.</div>
    </div>
    <div id="moveMultipleOptionsSchiebenTutorial" class="card cardGeneral">
      <b>Move multiple options</b>
      <div id="schiebenSelectTileMoveMultipleTurorialDiv"><input type="checkbox" id="schiebenSelectTileMoveMultipleTurorial" onclick="checked = !checked"> If you can move a piece into several gaps, you must <b>select the piece again first</b>.</div>
      <div id="schiebenSelectGapMoveMultipleTurorialDiv"><input type="checkbox" id="schiebenSelectGapMoveMultipleTurorial" onclick="checked = !checked"> However, you must now also click on the gap into which the piece is to be moved.</div>
    </div>
    <div class="card cardGeneral">
      <b>Information settings</b>
      <div class="card cardGeneral">
        <b>Undo moves</b>
        <br>
        In the settings, you can undo your moves and choose beforehand whether the necessary moves should count for the statistics.
      </div>
      <div class="card cardGeneral">
        <b>View the PC's moves</b>
        <br>
        You can also see how the PC solves the puzzle. It may not always take the shortest route, but at least it knows one. If it overlaps with yours, you can even see how to solve the puzzle from your position in the game.
      </div>
    </div>
  </div>
</div>
</div>
<script>
  document.body.style.backgroundColor = "white";
    window.onbeforeunload = function(){
    console.log("Leave Website");
      return 'Are you sure you want to leave?';
  };
  var mouseSupported = false;
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
    automaticTileSelectionReset.checked = true;
    automaticTileSelectionReset.style.display = 'none';
    // tileSelectionCanvas.style.position = "fixed";
    autoScrollMobileTutorial.appendChild(autoScrollTutorial);
    tileSelectionBarMobileTutorial.appendChild(tileSelectionBarTutorial);
    clippingInfosMobile.appendChild(clippingInfos);
    MouseDownScrollTileBarTutorialDiv.innerHTML = MouseDownScrollTileBarTutorialDiv.innerHTML.split('>')[0] + ">put finger on pieces list";
    moveMouseScrollTileSelectionBarTutorialDiv.innerHTML = moveMouseScrollTileSelectionBarTutorialDiv.innerHTML.split('>')[0] + ">move finger right/left to move the list, like when scrolling left/right";
    stopScrollingTileBarTutorialDiv.innerHTML = stopScrollingTileBarTutorialDiv.innerHTML.split('>')[0] + ">release your finger from the screen";
    scrollTilelistSwipeTutorial.innerHTML = "scroll by swiping";
    ScrollkeyTileBarTutorialDiv.remove();
  } else {
    var gerät = "PC"
    mouseSupported = true;
    console.log("PC");
    swipeSteuerungP.innerHTML = swipeSteuerungP.innerHTML.replace('start Sipe at first part and end it at 2nd part to swap them', 'press the mouse button down or double click at first part and release at 2nd part.');
    scrollOnBlancP.style.display = "none";
    vibrateA.style.display = "none";
  }
  document.querySelector("#closeMobileControls").disabled = !mouseSupported;
  // changeControlMode();
  exchangeTutorial.id += gerät;
  schiebenTutorial.id += gerät;
  gapSizeChanged(tilesGap.value);
  expandBottom.style.height = window.innerWidth/29;
  expandTop.style.height = window.innerWidth/29;
  expandLeft.style.width = window.innerWidth/29;
  expandRight.style.width = window.innerWidth/29;
  mobileControls.style.display = 'none';
  reloadWhenFinished.checked = JSON.parse(localStorage.getItem("reloadWhenFinished"));
  anzahlVerschieben.value = amountX.value*anzahlY.value;
  aufgebenId.style.display = "none";
  // schiebenSettings.style.display  = "inline"
  randSettings.style.display = "none";
  schiebenSettings.style.display = "none";
  größeAnpassenX.max = window.innerWidth
  größeAnpassenY.max = window.innerHeight
  var canvas = textur.getContext('2d');
  if (localStorage.getItem('tutorialAskedPuzzleCreatortraditional') != "true" && localStorage.getItem('tutorialAskedPuzzleCreatorexchange') != "true" && localStorage.getItem('tutorialAskedPuzzleCreatorschieben') != "true" && confirm('You have apparently never played this game before. You can play the individual parts of the tutorial (not all parts available due to setting options) directly while playing your first puzzle in the order that suits you ("Show controls")! If you click on "OK" or similar, you will be taken to the complete tutorial for the "traditional" mode, if you click on "Cancel" or similar, you can play your puzzle. You can also access the tutorials for the respective game mode in the settings.')) {
    setTimeout(() => {
      setupTutorial();
    }, 100);
  }
  // section 1: mainly change element style and visibility
  function emptyTileBarShuffleStyleSelected(value) {
    if (value == 'nextToEachOther' && emptyTileBar.checked) tilesGapS.style.display = 'block'; 
    else tilesGapS.style.display = 'none';
  }
  function rotateLeftModeChanged() {
    if (state.rotateLeft) rotatesLeft.checked = false; 
    state.rotateLeft = JSON.parse(JSON.stringify(rotatesLeft.checked));
    state.rotateRight = false;
    if ((tutorial.state == 'activateRotateLeftTutorial' && rotatesLeft.checked)) goTutorialSteps(1); 
    if (tutorial.state == 'rotateLeftMobileTutorial' && !rotatesLeft.checked) goTutorialSteps(-1);
  }
  function rotateRightModeChanged() {
    if (state.rotateRight) rotatesRight.checked = false;
    state.rotateRight = JSON.parse(JSON.stringify(rotatesRight.checked)); 
    state.rotateLeft = false;
    if ((tutorial.state == 'activateRotateRightTutorial' && rotatesRight.checked) || (tutorial.state == 'deactivateRotateRightTutorial' && !rotatesRight.checked)) goTutorialSteps(1); 
    if (tutorial.state == 'rotateRightMobileTutorial' && !rotatesRight.checked) goTutorialSteps(-1);
  }
  function hexTorgb(hex) {
    return ['0x' + hex[1] + hex[2] | 0, '0x' + hex[3] + hex[4] | 0, '0x' + hex[5] + hex[6] | 0];
  }
  function checkOut(closeAnyway) {
    var stillIn = false;
      for (var elm of document.getElementsByClassName('dropdown-content')[0].children) {
        if (window.getComputedStyle(elm).backgroundColor == "rgb(221, 221, 221)") stillIn = true;
      }
    if (!stillIn || closeAnyway) document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function shuffleStyleVisibilities(value) {
    if (value == 'nextToEachOther') {
      shuffleStyleTileGap.appendChild(tilesGapS);
      tilesGapS.style.display = 'block'; 
    }
    else tilesGapS.style.display = 'none';
    if (value == "listTiles") document.getElementById('EmptyTileBarDiv').style.display = "block";
    else document.getElementById('EmptyTileBarDiv').style.display = "none";
    if (value == "overlapTiles") shuffleHeadline.style.display = 'none';
    else shuffleHeadline.style.display = 'inline';
    if (value == 'listTiles' && emptyTileBar.checked) {
      emptyTileBarSettings.style.display = 'block';  
      if (shuffleStyleBar.value == "nextToEachOther") {
        emptyTilebarTileGap.appendChild(tilesGapS);
        tilesGapS.style.display = 'block';
      }
    }
    else emptyTileBarSettings.style.display = 'none';
  }
  function backToBarVis(checked) {
    if (checked) {
      backToBarButtons.style.display = 'inline';
      backToBarBSize.style.display = 'inline';
    }
    else {
      backToBarButtons.style.display = 'none';
      backToBarBSize.style.display = 'none';
    }
  }
  function showTitle(id, display) {
    id = id.replace('Symbol', 'Title');
    if (id != "rotateLeftTitle") rotateLeftTitle.style.display = 'none'; 
    if (id != "rotateRightTitle") rotateRightTitle.style.display = 'none'; 
    if (id != "selectMultipleTitle") selectMultipleTitle.style.display = 'none'; 
    if (id != "swipeTitle") swipeTitle.style.display = 'none'; 
    if (document.getElementById(id).style.display == "inline") document.getElementById(id).style.display = "none";
    else {
      document.getElementById(id).style.display = "inline";
      setTimeout(function () {
        document.getElementById(id).style.display = "none";
      }, 5000);
    }
  }
  function changeSettingsVis(vis) {
    if ((settings.style.display == 'none' || vis == "inline") && vis != "none") {
      settings.style.display = 'block'; 
      document.getElementById('tutorial').style.display = "none";
      selectBackToBarB.style.display = 'none';
      if (!state.removeTile && aufgebenId.style.display == "inline") wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
    }
    else {
      if (tutorial.state != "") {
        document.getElementById('tutorial').style.display = "inline";
        setTimeout(() => {
          tutorialSteps = Array.from(document.getElementById('tutorial').querySelectorAll('input[type="checkbox"]')).filter(x => x.offsetWidth > 0 || x.offsetHeight > 0);
          tutorial.index = 0;
          while (tutorialSteps.filter(x => document.getElementById(x.id + 'Div').className.includes('currentTutorialStep')).length > 0 && tutorialSteps[tutorial.index] && !document.getElementById(tutorialSteps[tutorial.index].id + "Div").className.includes('currentTutorialStep')) {
            tutorial.index++;
          }
          if (tutorialSteps[tutorial.index]) tutorial.state = tutorialSteps[tutorial.index].id;
          goTutorialSteps(0)
        }, 777);
      }
      settings.style.display = 'none';
      if (['inline', ''].includes(tileSelectionCanvas.style.display))  selectBackToBarB.style.display = "inline"
      originalDisplayChanged(false);
      canvas = textur.getContext('2d');
      if (wrongPosition && !state.changedPos) positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
      state.changedPos = false; 
    }
    if (modeSelection.value == "traditional") adaptExpandButtonPosition();
    texturTop = textur.getBoundingClientRect().top + scrollY;
  }
  function adaptExpandButtonPosition() {
    setTimeout(() => {
      if (settings.style.display == "block") expandTop.style.top = settings.getBoundingClientRect().bottom + scrollY + 17;
      else expandTop.style.top = showSettings.getBoundingClientRect().bottom + scrollY + 17;
      textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY;
      texturTop = textur.getBoundingClientRect().top + scrollY;
      expandRight.style.top = textur.getBoundingClientRect().top + scrollY;
      expandLeft.style.top = textur.getBoundingClientRect().top + scrollY;
      expandBottom.style.top = textur.getBoundingClientRect().top + scrollY;
      // update canvas and expand buttons position
      expandSide();
      textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
    }, 10);
  }
  function mirrorCanvas(checked) {
    if (checked) textur.style = "-webkit-transform: scaleX(-1); transform: scaleX(-1);";
    else {
      textur.style.transform = "";
      textur.style.webkitTransform = "";
    }
  }
  // change visibility of player of PC movement in schieben mode
  function changeMovementPlayerVis(checked) {
    if (checked) {
      innerMovementPlayer.style.display = 'inline'; 
      playMovementPos(getPlayerPosition(true));
      texturTop = textur.getBoundingClientRect().top + scrollY;
      movementPlayer.scrollIntoView();
      window.scroll(0, scrollY);
    }
    else {
      innerMovementPlayer.style.display = 'none';
      texturTop = textur.getBoundingClientRect().top + scrollY;
      canvas = textur.getContext('2d');
    }
  }
  // change size of + buttons for backToBar
  function changeBackToBarB(side, value) {
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var button = document.getElementsByClassName('backToTileB')[i];
      button.style[side] = value + 'px';
      button.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2 + 'px';
      button.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(button.style.width)/2 + 'px';
    }
  }
  // change play direction of movement player (player which shows the moves the PC did in schieben mode)
  function changeMovementDirection(direc) {
    objMovementPlayer.direc = direc;
    movementDirectionLeft.style.backgroundColor = '';
    movementDirectionRight.style.backgroundColor = '';
    if (direc == -1) movementDirectionLeft.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
    else movementDirectionRight.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
  }
  function changeTileBarHeight(value) {
    tileBarHeight.value = value;
    tileSelectionCanvas.style.height = JSON.parse(value) + 'px';
    if (lengthPerTeil.edit.x > lengthPerTeil.edit.y && rotateTiles.checked) {
      tileSelectionBar.pictureSize = {width: lengthPerTeil.edit.x*(((JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)))/lengthPerTeil.edit.x), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)};
    }
    else {
      tileSelectionBar.pictureSize = {width: lengthPerTeil.edit.x*(((JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.y)))/lengthPerTeil.edit.y), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.y)};
    }
    lengthPerTeil.sizeAdapted = {x: tileSelectionBar.pictureSize.width, y: tileSelectionBar.pictureSize.height};
    if (lengthPerTeil.sizeAdapted.y > lengthPerTeil.sizeAdapted.x && rotateTiles.checked) {
      var ablage = JSON.parse(JSON.stringify(lengthPerTeil.edit.x));
      lengthPerTeil.edit.x = lengthPerTeil.edit.y;
      lengthPerTeil.edit.y = ablage;
    }
    tileSelectionCanvas.width = (lengthPerTeil.edit.x + 10)*positions.wrong.length;
    layout();
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
      backToBarBWidth.value = lengthPerTeil.sizeAdapted.x/7;
      backToBarBHeight.value = lengthPerTeil.sizeAdapted.y/7;
      elm.style.width = backToBarBWidth.value;
      elm.style.height = backToBarBHeight.value;
      elm.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2;
      elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
    }
    backToBarBWidth.max = lengthPerTeil.sizeAdapted.x;
    backToBarBHeight.max = lengthPerTeil.sizeAdapted.y;
    scrollTileSelectionLeft.height = lengthPerTeil.sizeAdapted.y/2;
    scrollTileSelectionRight.height = lengthPerTeil.sizeAdapted.y/2;
    scrollTileSelectionRight.style.bottom = (lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionRight.getBoundingClientRect().height/2) + "px";
    scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionLeft.getBoundingClientRect().height/2 + "px";
  }
  function originalDisplayChanged(checked) {
      if (checked) stats.viewOriginal.times++;
      if (checked) {
        if (sourceIsPicture.checked) preview.style.display = "inline";
        else videoPreview.style.display = "inline";
        if (!stopClock.viewOriginal.running) startPause('viewOriginal');
        showOriginal.scrollIntoView();
      }
      else {
        if (sourceIsPicture.checked) preview.style.display = "none";
        else videoPreview.style.display = "none";
        if (stopClock.viewOriginal.running) startPause('viewOriginal');
      }
      adaptExpandButtonPosition();
  }
  // section 2: actions followed by element change/user input
  function goToTutorialIndex(bElm) {
    var indexId = Array.from(bElm.parentElement.querySelectorAll('input[type="checkbox"]')).filter(x => x.offsetWidth > 0 || x.offsetHeight > 0)[0].id;
    for (let i = 0; i < tutorialSteps.length; i++) {
      if (tutorialSteps[i].id == indexId) {
        goTutorialSteps(i - tutorial.index);
      }
    }
  }
  function showInformation() {
    var puzzle = puzzles[selected.puzzle];
    if (puzzle.fileName) alert('The puzzle uses the image "' + puzzle.fileName + '"');
    else if (puzzle.URL) alert('The puzzle uses the image/video from the website "' + puzzle.URL + '"');
    else alert('The image uses the live camera "' + puzzle.liveCam + '"');
    alert(`This puzzle uses the mode "${puzzle.mode}". You have already spent ${getTimeString(puzzle.completionTime)} minutes on the puzzle. The puzzle contains ${puzzle.positions.wrong.length} pieces.`);
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function editPuzzleName() {
    var newName = prompt("Bitte geben Sie hier den neuen Namen ein.", selected.puzzle);
    if (newName && newName != selected.puzzle) {
      getPuzzles();
      puzzles[newName] = puzzles[selected.puzzle];
      delete puzzles[selected.puzzle];
      localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
      getPuzzles();
    }
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function deletePuzzle() {
    getPuzzles();
    delete puzzles[selected.puzzle]; 
    localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
    getPuzzles();
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  // Test
  function showHitboxes(recursively) {
    var canvas = hitboxTextur.getContext('2d');
    var waitTime = 0;
    if (doHitboxAnimation.checked && tileColliderSettings.style.display == "block" && (!state.hitboxPos || recursively)) {
      if (!state.hitboxPos) state.hitboxPos = {bottomTile: lengthPerTeil.edit.x, rightTile: lengthPerTeil.edit.y};
      if (!state.hitboxDirection) state.hitboxDirection = {bottomTile: -1, rightTile: 1};
      setTimeout(() => {
        if (state.hitboxPos.bottomTile < 0 || state.hitboxPos.bottomTile > lengthPerTeil.edit.x*2) state.hitboxDirection.bottomTile *= -1;
        if (state.hitboxPos.rightTile < 0 || state.hitboxPos.rightTile > lengthPerTeil.edit.y*2) state.hitboxDirection.rightTile *= -1;
        state.hitboxPos.bottomTile += state.hitboxDirection.bottomTile;
        state.hitboxPos.rightTile += state.hitboxDirection.rightTile;
        setTimeout(() => {
          showHitboxes(true);
        }, waitTime);
      }, 10);
    }
    if (!(doHitboxAnimation.checked && tileColliderSettings.style.display == "block")) state.hitboxPos = undefined;
    canvas.clearRect(0, 0, hitboxTextur.width, hitboxTextur.height);
    canvas.fillStyle = "hsl(0, 100%, 41%)";
    if (doHitboxAnimation.checked) {
    canvas.fillRect(lengthPerTeil.edit.x, lengthPerTeil.edit.y, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // right
    if (collides({x: lengthPerTeil.edit.x*2, y: lengthPerTeil.edit.y/2 - parseInt(hitboxHeight.value)/2 + lengthPerTeil.edit.y, width: 10, height: parseInt(hitboxHeight.value)}, {x: lengthPerTeil.edit.x*2, y: lengthPerTeil.edit.y/2 - parseInt(hitboxHeight.value)/2 + state.hitboxPos.rightTile, width: 10, height: parseInt(hitboxHeight.value)}).boolean) {
      if (shortHaltCollider.checked && !state.rightTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "hsl(120, 100%, 40%)";
      }
      else canvas.fillStyle = "green";
      state.rightTileCollidesHitbox = true;
    }
    else {
      if (shortHaltCollider.checked && state.rightTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "red";
      }
      else canvas.fillStyle = "hsl(0, 100%, 34%)";
      state.rightTileCollidesHitbox = false;
    }
    canvas.fillRect(lengthPerTeil.edit.x*2 + 11, state.hitboxPos.rightTile, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // bottom
    if (collides({x: lengthPerTeil.edit.x/2 - parseInt(hitboxWidth.value)/2 + lengthPerTeil.edit.x, y: lengthPerTeil.edit.y*2, width: parseInt(hitboxWidth.value), height: 10}, {x: lengthPerTeil.edit.x/2 - parseInt(hitboxWidth.value)/2 + state.hitboxPos.bottomTile, y: lengthPerTeil.edit.y*2, width: parseInt(hitboxWidth.value), height: 10}).boolean) {
      if (shortHaltCollider.checked && !state.leftTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "hsl(120, 100%, 40%)";
      }
      else canvas.fillStyle = "green";
      state.leftTileCollidesHitbox = true;
    }
    else {
      if (shortHaltCollider.checked && state.leftTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "red";
      }
      else canvas.fillStyle = "hsl(0, 100%, 34%)";
      state.leftTileCollidesHitbox = false;
    }
    canvas.fillRect(state.hitboxPos.bottomTile, lengthPerTeil.edit.y*2 + 11, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
    // right
    canvas.fillRect(lengthPerTeil.edit.x*2, lengthPerTeil.edit.y/2 - hitboxHeight.value/2 + lengthPerTeil.edit.y, 10, hitboxHeight.value);
    canvas.fillRect(lengthPerTeil.edit.x*2, lengthPerTeil.edit.y/2 - hitboxHeight.value/2 + state.hitboxPos.rightTile, 10, hitboxHeight.value);
    // bottom
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2 + lengthPerTeil.edit.x, lengthPerTeil.edit.y*2, hitboxWidth.value, 10);
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2 + state.hitboxPos.bottomTile, lengthPerTeil.edit.y*2, hitboxWidth.value, 10);
  }
    else {
    canvas.fillRect(0, 0, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillRect(lengthPerTeil.edit.x + 11, 0, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillRect(0, lengthPerTeil.edit.y + 11, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
    canvas.fillRect(lengthPerTeil.edit.x, lengthPerTeil.edit.y/2 - hitboxHeight.value/2, 10, hitboxHeight.value);
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2, lengthPerTeil.edit.y, hitboxWidth.value, 10);
    }
  }
  function changeAdaptedSizeMax(width, height) {
    textur.width = width// + 111;
    textur.height = height// + 111;
    if (window.innerWidth > width || screenIsMax.checked) größeAnpassenX.max = window.innerWidth;
    else größeAnpassenX.max = width;
    if (window.innerHeight > height || screenIsMax.checked) größeAnpassenY.max = window.innerHeight;
    else größeAnpassenY.max = height;
    größeAnpassenX.value = width;
    größeAnpassenY.value = height;
    zeigeGröße();
  }
    // back to bar to the right of the selected tile in the tileBar
    function generalBackToBar(elm) {
    if (tileSelectionBar.tiles.length != amountX.value*anzahlY.value) {
      if (elm.style.backgroundColor == 'red') {
        state.backToBar = false;
        elm.style.backgroundColor = '';
        tileSelectionBar.selectedTile = undefined;
      }
      else {
        if (tutorial.state == "clickBackToBarBTurotial") goTutorialSteps(1);
        if (!tileSelectionBar.selectedTile) tileSelectionBar.selectedTile = {i: tileSelectionBar.tiles.length - 1};
        state.backToBar = tileSelectionBar.selectedTile.i + 1; 
        elm.style.backgroundColor = 'red';
        tileSelectionBar.selectedTile = undefined;
      }
    }
  }
  function expandSide(side, adaptButtonsOnly) {
    // if (!state.sideExpanded && aufgebenId.style.display == 'inline') {
    if (!adaptButtonsOnly) {
      if (['right', 'left'].includes(side)) textur.width += lengthPerTeil.edit.x*3;
      if (['bottom', 'top'].includes(side)) textur.height += lengthPerTeil.edit.y*3;
    }
    expandRight.style.left = textur.getBoundingClientRect().right + scrollX + 'px';
    expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY; + 'px';
    expandBottom.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandTop.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandRight.style.height = textur.height + 6; 
    expandLeft.style.height = textur.height + 6; 
    if (['top', 'left'].includes(side)) {
      var moveDirection = "x";
      if (side == "top") moveDirection = "y";
      for (const position of positions.wrong) {
        position.edit[moveDirection] += lengthPerTeil.edit[moveDirection]*3;
      }
    }
    state.rightScroll = 0;
    state.upScroll = 0;
    layout(true, true);
  }
  function showCurrentStats(mode) {
    if (mode == "traditional") alert(`Your preliminary data: You have connected parts ${stats.turns} times (it is possible with at least ${amountX.value*numberY.value - 1} times) and unclipped parts ${stats.unclipped} times. You have connected parts incorrectly ${stats.wrongClipped} times. You have also rotated a part a total of ${stats.rotated} times.`);
    if (mode == "exchange") alert("Your Highest match with the original is " + stats.highestRight.right + " from " + positions.wrong.length + "pieces after " + stats.highestRight.turns + " moves (It is possible with " + (positions.wrong.length - stats.preOrdered) + "moves! Will you make it?)");
    if (mode == "schieben") alert("Your Highest match with the original is " + stats.highestRight.right + " from " + positions.wrong.length + " pieces after " + stats.highestRight.turns + " moves (It is possible with " + distinctMoves.length + "moves or less! Do you think you will make it?)");
    if (mode != "traditional" && stats.preOrdered) alert(`Remember, however, that you had ${stats.highestRight.right} of the ${stats.preOrdered} parts of the total ${positions.wrong.length} parts in the right position from the get-go!`);
    if (stats.viewOriginal.times > 0) alert(`In addition, you have looked at the original image ${stats.viewOriginal.times} times for a total of ${stats.viewOriginal.time} minutes and spent a total of ${stats.completionTime} minutes on this puzzle so far.`.replace('undefined', '0'));
  }
  function zuBildschirmgröße() {
    größeAnpassenX.value = window.innerWidth;
    größeAnpassenY.value = window.innerHeight;
    zeigeGröße();
  }
  function resetImageSize() {
    größeAnpassenX.value = preview.naturalWidth;
    größeAnpassenY.value = preview.naturalHeight;
    if (sourceIsVideo.checked) {
      größeAnpassenX.value = video.videoWidth;
      größeAnpassenY.value = video.videoHeight;
    }
    zeigeGröße();
  }
  // Seitenverhältnisse des Bildes anpassen
  function zuAngepassterBildschirmgröße(noShowing) {
    var referenceSize = originalSize;
    if (!screenIsMax.checked) referenceSize = {width: JSON.parse(JSON.stringify(größeAnpassenX.value)), height: größeAnpassenY.value};
    else referenceSize = {width: window.innerWidth + 1, height: window.innerHeight + 1};
    if (window.innerWidth < referenceSize.width && window.innerHeight < referenceSize.height) {
      größeAnpassenX.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
    }
    else {
      größeAnpassenX.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
    }
    if (!noShowing || noShowing == "repeat") zeigeGröße(true);
    if (screenIsMax.checked) {
      preventAutomaticZoom.content = `width=${größeAnpassenX.value}, height=${größeAnpassenY.value}, initial-scale=1.0, maximum-scale=1.0, user-scalable=0`;
      if (!noShowing) zuAngepassterBildschirmgröße("repeat");
    }
  }
  function zuOptimalerBildschirmgröße() {
    größeAnpassenX.value = preview.width;
    größeAnpassenY.value = preview.height;
    while (größeAnpassenX.value > window.innerWidth || größeAnpassenY.value > window.innerHeight) {
      größeAnpassenX.value--;
      größeAnpassenY.value--;
    }
    zeigeGröße();
  }
  function zeigeGröße(adapted, onInput) {
    if (größeAnpassenX.value != größeAnpassenY.value && !state.loadImage) bAdaptAmount.checked = true;
    if (state.loadImage && !adapted) zuAngepassterBildschirmgröße();
    delete state.loadImage;
    textur.width = größeAnpassenX.value;
    textur.height = größeAnpassenY.value
    // canvas.clearRect(0, 0, textur.width, textur.height);
    if (preview.src == "") {
    canvas.fillStyle = "blue";
    canvas.fillRect(0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  else {
    canvas.drawImage(document.getElementById('preview'), 0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  if (textur.width > window.innerWidth) editCanvasDiv.style.width = textur.width;
  else if (editCanvasDiv.style.width.replace('px', '') > window.innerWidth || (textur.getBoundingClientRect().right <= window.innerWidth + textur.getBoundingClientRect().left && textur.getBoundingClientRect().right > editCanvasDiv.getBoundingClientRect().right)) editCanvasDiv.style.width = window.innerWidth;
  // tilesSizeDiv: size reference
  else if (textur.getBoundingClientRect().right <= tilesSizeDiv.getBoundingClientRect().right) editCanvasDiv.style.width = "";
  // show tiles in grid
  drawTileGrid();
}
function drawTileGrid(doNotDrawPicture) {
  if (!doNotDrawPicture) {
    canvas.clearRect(0, 0, textur.width, textur.height);
    canvas.drawImage(preview, 0, 0, textur.width, textur.height);
  }
  for (let i = 0; i < amountX.value; i++) {
    canvas.beginPath();
    canvas.moveTo((textur.width/amountX.value)*i, 0);
    canvas.lineTo((textur.width/amountX.value)*i, textur.height);
    canvas.stroke();
  }  
  for (let i = 0; i < anzahlY.value; i++) {
    canvas.beginPath();
    canvas.moveTo(0, (textur.height/anzahlY.value)*i);
    canvas.lineTo(textur.width, (textur.height/anzahlY.value)*i);
    canvas.stroke();
  }  
}
  function playPauseVideo(innerHTML) {
    if (innerHTML == "play") {
      video.play();
      playVideo.innerHTML = 'pause';
    } 
    else {
      video.pause();
      playVideo.innerHTML = 'play';
    }
  }
  function modeSelected(value) {
    document.getElementById(value + 'Description').appendChild(startTutorialButton);
    modeSelection.value = value;
    traditionalDescription.style.display = 'none';
    exchangeDescription.style.display = 'none';
    schiebenDescription.style.display = 'none';
    document.getElementById(value + 'Description').style.display = 'block';
    if (value == "traditional") zeigeGröße();
    traditionalSettings.style.display = 'none';
    exchangeSettings.style.display = 'none';
    schiebenSettings.style.display = 'none';
    document.getElementById(value + 'Settings').style.display = 'block';
    document.getElementById(value + 'Settings').prepend(modeSettingsHeading);
  }
  var originalSize = {width: 0, height: 0};
  function gapSizeChanged(value) {
    gapCanvas.width = 100 + JSON.parse(tilesGap.value);
    gapCanvas.height = 100;
    var gCanvas = gapCanvas.getContext('2d');
    gCanvas.clearRect(0, 0, gCanvas.width, gCanvas.height);
    gCanvas.fillStyle = 'red';
    gCanvas.fillRect(0, 0, 50, 50);
    gCanvas.fillRect(50 + JSON.parse(tilesGap.value), 0, 50, 50);
  }
    // create the puzzle
    function create() {
      videoControlsInSettings.appendChild(videoControls);
      puzzleManager.style.display = "block";
    if (document.getElementById('preview').src == '' && video.src == '' && !pMediaStream && URLInfo.style.display == "none") alert('Please upload a picture or a video before you click on this button to create a puzzle!') 
    else if (!state.removeTile) {
      if (tutorial.state == "" && localStorage.getItem('tutorialAskedPuzzleCreator' + modeSelection.value) != "true" && confirm('You have apparently never played this game mode before. Do you want to play the tutorial as an introduction? Alternatively, you can play the individual parts of the tutorial (not all parts available due to setting options) directly while playing your first puzzle in this mode in the order that suits your needs ("Show controls")! If you click on "OK" or similar, you will be taken to the complete tutorial for the mode ' + modeSelection.value + ', if you click on "Cancel" or similar, you can play your own puzzle.')) {
        setupTutorial();
      }
      else {
        futureTexturPosition.appendChild(textur);
        if (modeSelection.value == "schieben") modeDiv.prepend(modeSettingsHeading);
        else document.getElementById(modeSelection.value + 'Settings').prepend(modeSettingsHeading);
        if (modeSelection.value != "traditional") shuffleStyle.value = "none";
        if (modeSelection.value == "exchange") doNotMoveTile.checked = true;
        if (screenIsMax.checked) preventAutomaticZoom.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
        positions = {right: [], wrong: []};
        if (modeSelection.value == "traditional") {
          positions.layoutOrder = new Array(amountX.value*anzahlY.value);
          for (var i = 0; i < positions.layoutOrder.length; i++) {
            positions.layoutOrder[i] = i;
          }
        }
        removeTilesFinishedB.style.display = 'inline';
        if (modeSelection.value == "schieben") tileStatusOptions.style.display = 'inline';
        showSettings.title = "Einstellungsmöglichkeiten und Möglichkeit aufzugeben";
        imageSettings.style.display = "none";
        modeSelection.style.display = "none";
        schiebenSettings.style.display = "none";
        rotateTilesP.style.display = "none";
        missing = [];
        if (gerät == "Handy") mobileControls.style.display = "inline";
        originalSize.width = preview.width;
        originalSize.height = preview.height;
        preview.width = größeAnpassenX.value;
        preview.height = größeAnpassenY.value;
        textur.width = preview.width + 3*(amountX.value - 1) - 1// + 111;
        textur.height = preview.height + 3*(anzahlY.value - 1) - 1// + 111;
        videoPreview.width = größeAnpassenX.value;
        videoPreview.height = größeAnpassenY.value;
        var pAnzahlX = amountX.value;
        var pAnzahlY = anzahlY.value;
        if (sourceIsPicture.checked) lengthPerTeil = {original: {x: Math.round(originalSize.width/pAnzahlX), y: Math.round(originalSize.height/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
        else lengthPerTeil = {original: {x: Math.round(video.videoWidth/pAnzahlX), y: Math.round(video.videoHeight/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
        breiteRand.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3;
        randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - breiteRand.value;
        for (var i = 0; i < pAnzahlY; i++) {
          for (var i1 = 0; i1 < pAnzahlX; i1++) {
            if (modeSelection.value == "traditional") {
              var newTile = {original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}};
              if (i1) newTile.original.left = {x: positions.right[i*pAnzahlX + i1 - 1]?.original.x, y: positions.right[i*pAnzahlX + i1 - 1]?.original.y};
              if (i) newTile.original.top = {x: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.x, y: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.y};
              positions.right.push(newTile);
              if (i) positions.right[i*pAnzahlX + i1 - pAnzahlX].original.bottom = {x: newTile.original.x, y: newTile.original.y};
              if (i1) positions.right[i*pAnzahlX + i1 - 1].original.right = {x: newTile.original.x, y: newTile.original.y};
            }
            else {
              positions.right.push({original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}})
            }
            positions.right[positions.right.length - 1].border = [];
            if (i1 == 0) positions.right[positions.right.length - 1].border.push("left");
            if (i1 == pAnzahlX - 1) positions.right[positions.right.length - 1].border.push("right");
            if (i == 0) positions.right[positions.right.length - 1].border.push("top");
            if (i == pAnzahlY - 1) positions.right[positions.right.length - 1].border.push("bottom");
            positions.right[i*pAnzahlX + i1].x = i1;
            positions.right[i*pAnzahlX + i1].y = i;
          }
        }
        positions.wrong = JSON.parse(JSON.stringify(positions.right));
        for (var i = 0; i < pAnzahlY; i++) {
          for (var i1 = 0; i1 < pAnzahlX; i1++) {
            positions.wrong[i*pAnzahlX + i1].edit.x += 3*i1;
            positions.wrong[i*pAnzahlX + i1].edit.y += 3*i;
          }
        }
        //canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/200, /*yFromPicture*/200, 200, 200, /*xFromPlacement*/0, /*yFromPlacement*/0, 200, 200);
        window.scroll(0, /*96 50*/32);
        if (modeSelection.value == "schieben") {
          if (!state.restorePuzzle) alert("Please select a piece to be removed. In the best case it is an unimportant part of the picture!");
          state.removeTile = true;
          layout(true, false, false, true);
        }
        else removeTile(true);
        // else layout();
        if (sourceIsVideo.checked) canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
        showSettings.scrollIntoView();
        window.scroll(0, 0);
        changeSettingsVis('none');
        swipeTitle.style.display = "inline";
        swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + 20;
        swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
        swipeTitle.style.display = "none";
        modeHeadline.style.display = 'none';
        shuffleHeadline.style.display = 'none';
        startTutorialButton.style.display = "none";
        EmptyTileBarDiv.style.display = "none";
        texturTop = textur.getBoundingClientRect().top + scrollY;
        futurePuzzleManager.appendChild(puzzleManagerIcon);
        futurePuzzleManager.appendChild(puzzleManager);
        automaticTileSelectionReset.checked = true;
      }
    }
    autoScroll = setInterval(function () {
      if (!selected.position.manualScrolling &&  aufgebenId.style.display == "inline" && !state.removeTile) {
        // top boundary: 
      // canvas.fillStyle = "blue";
      // canvas.fillRect(visualViewport.pageLeft - texturLeft, visualViewport.pageTop + state.upScroll - texturTop, visualViewport.width, 10);
  // up
  if (!scrollable.checked && aufgebenId.style.display == "inline" && (((modeSelection.value == "traditional" && positions.wrong[selected.tiles[0]]?.edit.y - lengthPerTeil.edit.y/2 < visualViewport.pageTop + state.upScroll - texturTop && selected.tiles.length) || (((modeSelection.value == "exchange" && selected.boolean.swipe) || (modeSelection.value == "schieben" && state.mouse == "down")) && mausy - scrollY < 30)))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    // window.scroll(scrollX, scrollY - 3);
    // mausy -= 3;
    fAutoScroll({x: 0, y: -3});
}
// right 
if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX + scrollX + lengthPerTeil.edit.x/2 > visualViewport.pageLeft + window.visualViewport.width/* - texturLeft*/ && selected.tiles?.length) {
      // window.scroll(scrollX + 3, scrollY);
      fAutoScroll({x: 3, y: 0}, true);
    }
if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x + lengthPerTeil.edit.x/2 > visualViewport.pageLeft + window.visualViewport.width + state.rightScroll/* + scrollX*/) || (modeSelection.value != "traditional" && mausx + texturLeft > visualViewport.pageLeft + window.visualViewport.width  - 50))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        // window.scroll(scrollX + 3, scrollY);
        // mausx += 3;
        fAutoScroll({x: 3, y: 0});
      }
      // left
      if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX - lengthPerTeil.edit?.x/2 < visualViewport.offsetLeft && selected.tiles.length) {
      // window.scroll(scrollX - 3, scrollY);
      fAutoScroll({x: -3, y: 0}, true);
    }
  if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && (mausx - visualViewport.pageLeft - state.rightScroll < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    // window.scroll(scrollX - 3, scrollY);
    // mausx -= 3;
    fAutoScroll({x: -3, y: 0});
}
  }
// down
var pScrollY = scrollY;
    if (shuffleStyle.value == "listTiles") pScrollY -= tileSelectionCanvas.getBoundingClientRect().height;// lengthPerTeil.edit.y - 10;
    var ptexturTop = textur.getBoundingClientRect().top - visualViewport.offsetTop; 
    if (ptexturTop < 0) ptexturTop = 0;
    if (!scrollable.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && ((positions.wrong[selected.tiles[0]].edit.y > visualViewport.pageTop + window.visualViewport.height + state.upScroll - ptexturTop - texturTop) || (['inline', ''].includes(tileSelectionCanvas.style.display) && positions.wrong[selected.tiles[0]].edit.y > tileSelectionCanvas.getBoundingClientRect().top + scrollY + state.upScroll - texturTop /* + pScrollY - texturTop*/))) || (modeSelection.value != "traditional" && mausy + texturTop > visualViewport.pageTop + window.visualViewport.height  - 70))) && (selected.boolean.swipe || modeSelection.value != "exchange") && state.mouse == "down")) {
        // window.scroll(scrollX, scrollY + 3);
        // mausy += 3;
        fAutoScroll({x: 0, y: +3});
      }
}, 10);
  }
  function fAutoScroll(direction, mirrored) {
    pcScrolls = true;
    if (tutorial.state == "automaticScrollingTutorial" && state.scrollY != scrollY) goTutorialSteps(1);
    state.scrollY = scrollY;
    if (!positions.wrong[selected.tiles[0]] || positions.wrong[selected.tiles[0]].edit.y > 0) window.scrollBy(direction.x, direction.y);
    mausx += direction.x;
    mausy += direction.y;
    if (gerät == "Handy") {
      if (direction.x && (positions.wrong[selected.tiles[0]] && ((positions.wrong[selected.tiles[0]].edit.x < textur.width && !mirrored) || (mausx > lengthPerTeil.edit.x/2 && mirrored))/*state.rightScroll < textur.width - visualViewport.width*/ && direction.x > 0) || (direction.x < 0 && ((selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x > 0 && !mirrored) || (mausx < textur.width - lengthPerTeil.edit.x/2 + texturLeft && mirrored))/*state.rightScroll > 0*/)) {
        state.rightScroll += direction.x;
        if (mirrored) canvas.translate(direction.x, 0);
        else canvas.translate(-direction.x, 0);
        layout(true, true);
      }
      if (direction.y && scrollY == state.scrollY && ((positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.y < textur.height/*textur.height - visualViewport.height*/ && direction.y > 0) || (direction.y < 0 && positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.y > 0))) {
        state.upScroll += direction.y;
        canvas.translate(0, -direction.y);
        layout(true, true);
        folgenMouseMove();
      }
    }
  }
  function checkAutoscrollStop(scrollBefore) {
    setTimeout(() => {
      if (tutorial.state == "stopScrollingAutomaticScrollingTutorial") {
        if (scrollX == scrollBefore.x && scrollY == scrollBefore.y) goTutorialSteps(1);
        checkAutoscrollStop({x: scrollX, y: scrollY});
      }
    }, 777);
  }
  var positionsBeginning = [];
  function shufflePuzzle() {
    var shuffleStyleBefore = shuffleStyle.value;
    if (emptyTileBar.checked)  shuffleStyle.value = shuffleStyleBar.value;
    if (modeSelection.value == "schieben" && !selected.tiles.length && !state.restorePuzzle) alert("You must have selected at least one part to be removed so that you can slide a piece!");
    else {
      localStorage.setItem('tutorialAskedPuzzleCreator' + modeSelection.value, "true");
      for (var i = 0; i < anzahlY.value; i++) {
      for (var i1 = 0; i1 < amountX.value; i1++) {
        positions.wrong[i*amountX.value + i1].edit.x -= 3*i1;
        positions.wrong[i*amountX.value + i1].edit.y -= 3*i;
      }
    }
    textur.width -= 3*(amountX.value - 1);
    textur.height -= 3*(anzahlY.value - 1);
      var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
      for (var i of selected.tiles) {
        missing.push(JSON.parse(JSON.stringify(positions.wrong[i].edit.x + ' - ' + positions.wrong[i].edit.y)));
        positionsBeginning.push(positions.wrong[i]);
        positions.wrong.forEach((position, i1) => {
          for (var direc of ['top', 'right', 'bottom', 'left']) {
            if (positions.wrong[i].border.includes(directionConverter[direc]) && positions.wrong[i].original[direc] && !i1/* && !selected.tiles.includes(getTile(positions.wrong[i].original[direc]))*/) {
              positions.wrong[getTile(positions.wrong[i].original[direc])].border.push(directionConverter[direc]);
            }
            if (position.original[direc]) {
            position.original[direc].degree = 0;// position.edit.degree;
            if (angular.equals(position.original[direc], {x: positions.wrong[i].original.x, y: positions.wrong[i].original.y, degree: 0})) {
              delete position.original[direc].degree;
              delete positions.right[i1].original[direc];
              // delete position.original[direc];
            }
            else delete position.original[direc].degree;
          }
          }
        });
      }
      if (modeSelection.value != "exchange") {
        for (var i = 0; i < positions.wrong.length; i++) {
          if (selected.objTiles.includes(JSON.stringify(positions.wrong[i].edit))) {
            positions.wrong.splice(i, 1);
            positions.right.splice(i, 1);
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
              if (doNotChange[i1] > i) doNotChange[i1]--;
            }
            if (modeSelection.value == "traditional") {
              positions.layoutOrder.splice(i, 1);
              for (var i1 = i; i1 < positions.layoutOrder.length; i1++) {
                positions.layoutOrder[i1]--;
              }
            }
            i--;
          }
        }
      }
      selected.tiles = [];
      removeTilesFinishedB.style.display = 'none';
      state.removeTile = false;
      if (modeSelection.value == "schieben") {
        getShortestPCMovement();
      }
      else {
      if (modeSelection.value == "traditional") {
        textur.width += 500;
        textur.height += 500;
        positions.wrong.forEach((position, i) => {
          if (shuffleStyle.value != "listTiles" || emptyTileBar.checked) {
            position.edit = {x: Math.round(Math.random()*(textur.width - lengthPerTeil.edit.x)), y: Math.round(Math.random()*(textur.height - lengthPerTeil.edit.y)), degree: 0};
            if (emptyTileBar.checked) tileSelectionBar.tiles.push(i);
          }
          else {
            position.edit = {x: i*(lengthPerTeil.edit.x + 5) + lengthPerTeil.edit.x/2, y: 5 + lengthPerTeil.edit.y/2, degree: 0};
            tileSelectionBar.tiles.push(i);
          }
          position.original = {x: position.original.x, y: position.original.y, degree: [0, 90, 180, 270][Math.round(Math.random()*3)]};
          if (!rotateTiles.checked) position.original.degree = 0;
          if (position.original.degree == 270) stats.minimumRotations++;
          else stats.minimumRotations += Math.abs(position.original.degree/90);
      });
      if (emptyTileBar.checked) {
        state.modelEmptybar = true;
        setTimeout(function () {
          tileSelectionBar.tiles = [];
          state.modelEmptybar = false;
          layout();
        }, 100);  
      }
    }
    if (shuffleStyle.value == "nextToEachOther") {
        if (isNaN(tilesGap.value) || tilesGap.value == '') tilesGap.value = 55;
        if (isNaN(tilesXTileGap.value) || tilesXTileGap.value == '') tilesXTileGap.value = amountX.value;
        var pos = {x: lengthPerTeil.edit.x/2, y: lengthPerTeil.edit.y/2};
        for (let i = 0; i < positions.wrong.length; i++) {
          positions.wrong[i].edit = {x: pos.x, y: pos.y, degree: 0};
          pos.x += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
          if ((pos.x + lengthPerTeil.edit.x/2 > window.innerWidth && fillScreenTileGap.checked) || (!fillScreenTileGap.checked && pos.x > lengthPerTeil.edit.x + (lengthPerTeil.edit.x + JSON.parse(tilesGap.value))*(parseInt(tilesXTileGap.value) - 1))) {
            if (pos.x + lengthPerTeil.edit.x/2 > textur.width) textur.width = pos.x - lengthPerTeil.edit.x/2 - JSON.parse(tilesGap.value);
            pos.x = lengthPerTeil.edit.x/2;
            if (pos.y + lengthPerTeil.edit.y/2 > textur.height) textur.height = pos.y + lengthPerTeil.edit.y/2;
            pos.y += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
          }
        }
      }
      for (i = positions.wrong.length - 1; (modeSelection.value == "exchange" || shuffleStyle.value != "overlapTiles") && i > 0; i--) {
        do {
          j = Math.floor(Math.random() * (i + 1));
        } while (doNotChange.includes(j) && j != i && doNotChange.length != positions.wrong.length);
        x = positions.wrong[i].edit;
        if (!doNotChange.includes(i)) {
          positions.wrong[i].edit = positions.wrong[j].edit;
          positions.wrong[j].edit = x;
        }
      }
      stats.preOrdered = "pending";
    }
    if (shuffleStyle.value == "nextToEachOther") tilesGapS.style.display = "none";
    shuffleStyle.value = shuffleStyleBefore;
    doNotChange = [];
    aufgebenId.style.display = "inline";
  showOriginalP.style.display = 'inline';
  showTutorialB.style.display = "inline"
  shuffleStyle.style.display = 'none';
  tileStatusOptions.style.display = 'none';
  shuffleStyleLable.style.display = 'none';
  if (modeSelection.value == "schieben") turnsHistoryS.style.display = 'inline';
  // expand textur buttons
  if (modeSelection.value == "traditional") { 
    if (localStorage.getItem('automaticTileSelectionResetPuzzleCreator') != "true" && gerät == "PC") automaticTileSelectionReset.checked = false;
    else automaticTileSelectionReset.checked = true;
  textur.style.position = "absolute";
  expandBottom.style.width = textur.width + 6; 
  expandTop.style.width = textur.width + 6;  
  // expandTop.style.position = "static";  
  for (const elm of document.getElementsByClassName('expandButtons')) {
    elm.style.display = 'inline';
  }
  textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY + 'px';
  texturTop = textur.getBoundingClientRect().top + scrollY;
  expandLeft.style.left = '0px';
  expandLeft.style.height = textur.height + 6;  
  expandLeft.style.top = textur.getBoundingClientRect().top + scrollY// texturTop;
  textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
  expandTop.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandBottom.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandRight.style.top = texturTop;
  expandRight.style.height = textur.height + 6;  
  expandRight.style.left = textur.getBoundingClientRect().right + scrollX// textur.getBoundingClientRect().x + scrollX + textur.width + 6 + 'px';
  expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY;// texturTop + scrollY + textur.height + 6 + 'px'; 
}
  texturLeft = textur.getBoundingClientRect().left + scrollX;
  // TODO
  if (gerät == "Handy") autoSelectTileBar.checked = false;
  tileBarHeight.max = window.innerHeight - texturTop - lengthPerTeil.edit.y;
  setDefaultSelectionBarHeight();
  backToBarBWidth.max = lengthPerTeil.edit.x;
  backToBarBHeight.max = lengthPerTeil.edit.y;
  backToBarBWidth.value = lengthPerTeil.edit.x/7;
  backToBarBHeight.value = lengthPerTeil.edit.y/7;
  hitboxCheckbox.style.display = "inline";
  hitboxWidth.max = lengthPerTeil.edit.x;
  hitboxWidth.value = lengthPerTeil.edit.x/4;
  hitboxHeight.max = lengthPerTeil.edit.y;
  hitboxHeight.value = lengthPerTeil.edit.y/4;
  hitboxTextur.width = lengthPerTeil.edit.x*3 + 33;
  hitboxTextur.height = lengthPerTeil.edit.y*3 + 33;
  if (shuffleStyle.value == "listTiles") {
    tileSelectionCanvas.style.display = "inline";
    selectBackToBarB.style.display = 'inline';
    listTilesS.style.display = 'block';
    settings.style.display = 'block';
    tileBarHeight.style.width = window.innerWidth - tileBarHeightText.getBoundingClientRect().width - resetBarSize.getBoundingClientRect().width - 100;
    settings.style.display = 'none';
  }
  else tileSelectionCanvas.style.display = "none";
  scrollTileSelectionRight.style.bottom = (lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionRight.getBoundingClientRect().height/2) + "px";
  scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionLeft.getBoundingClientRect().height/2 + "px";
  if (gerät == "Handy") {
    selectBackToBarB.style.fontSize = '5vh';
    // zoom out: 
    var newElm = document.createElement('meta');
      newElm.name = "viewport";
      newElm.id = "zoomLevelControler";
      newElm.content = "initial-scale=0.25";
      document.getElementsByTagName('head')[0].appendChild(newElm);
  }
  if (shuffleStyle.value == "listTiles") {
    scrollTileSelection(0);
    for (var i = 0; i < tileSelectionBar.tiles.length + 1; i++) {
      addElement({class: "backToTileB", innerText: '+', style: `width: ${backToBarBWidth.value}px; height: ${backToBarBHeight.value}; bottom: ${(lengthPerTeil.edit.y + 5)/2 - (backToBarBHeight.value)/2}px; left: ${10 + (5 + lengthPerTeil.edit.x)*(i) - (backToBarBWidth.value)/2}px`, onclick: `posInBarSelected(${i});`}, 'button', 'backToBarButtons');
    }
  }
    if (gerät == "Handy") {
    mobileControls.style.display = 'inline';
    rotateControls.style.display = "inline";
  }
  selected.boolean = {click: false, swipe: false};
  try {
  preventAutomaticZoom.content = "";
  } catch (err) {}
  window.scroll(0, 0);
  }
  adaptTitlesPosition();
  emptyTileBar.style.display = "none";
  if (modeSelection.value == "traditional") {
    traditionalModeMobileControls.style.display = 'inline';
  }
  canvas = textur.getContext('2d');
  layout(true, true);
  startPause('completionTime');
  setTimeout(() => {
    adaptMobileControlsPosition();
    if (tileSelectionCanvas.style.display != "none") {
      scrollTileSelection(1);
      changeTileBarHeight(tileBarHeight.value);
      scrollTileSelection(-1);
    }
  }, 100);
}
function setDefaultSelectionBarHeight() {
  var pTileBarHeight = lengthPerTeil.edit.y + 10;
  if (lengthPerTeil.edit.x > lengthPerTeil.edit.y && rotateTiles.checked) pTileBarHeight = lengthPerTeil.edit.x + 10;
  tileSelectionBar.height = pTileBarHeight;
  tileSelectionCanvas.height = pTileBarHeight;
  changeTileBarHeight(pTileBarHeight);
}
// #importantUserInputs
// select tiles to remove and move tiles or exchange them depending on the mode
function canvasClicked(calledBy) {
  if (calledBy == "elm") selected.boolean.swipe = false;
  selected.tile = checkSelected();
  if (!state.removeTile && !scrollable.checked && !finished) { 
    if (aufgebenId.style.display == "inline" && settings.style.display == "block") changeSettingsVis('none');
    if (selected.tile && selected.tiles.length && (selected.boolean.click || selected.boolean.swipe) && modeSelection.value == "exchange" && !state.removeTile) {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == selected.tile.x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == selected.tile.y) {
          if (selected.tile.x + "-" + selected.tile.y == selected.coord.x + "-" + selected.coord.y && (!selected.boolean.swipe || (calledBy == "mouseup" && state.tileChanged)) && !state.unselected) {
            selected.tiles = selected.tiles.filter(x => x != i);
            if (["unselectTileUnselectStandardTutorial"].includes(tutorial.state) || (tutorial.state == "releaseMouseUnselectAlternativeTutorial" && state.tileChanged)) goTutorialSteps(1);
            if (tutorial.state == "selectSecondExchangeNormalTutorial") goTutorialSteps(-1);
            state.unselected = true;
            setTimeout(() => {
              state.unselected = false;
            }, 100);
          }
          else if (selected.tile.x + "-" + selected.tile.y != selected.coord.x + "-" + selected.coord.y) {
              console.log("vertausche " + selected.tile.x + "-" + selected.tile.y + " mit " + selected.coord.x + "-" + selected.coord.y);
              if (["selectSecondExchangeNormalTutorial"].includes(tutorial.state)) goTutorialSteps(1);
              if (tutorial.state == "unselectTileUnselectStandardTutorial") goTutorialSteps(-1);
              if (tutorial.state == "releaseMouseUnselectAlternativeTutorial") goTutorialSteps(-3);
              stats.turns++;
              vertauscheZwei(i, selected.tiles[0]);
              selected.tiles = [];
              i = positions.wrong.length;
              // i1 = positions.wrong.length;
              if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
              state.exchangedTiles = true;
              setTimeout(() => {
                state.exchangedTiles = false;
              }, 500);
          }
          selected.boolean = {click: false, swipe: false};
      }
    }
    }
    else if (modeSelection.value == "schieben" && selected.tile/* && selected.boolean*/ && missing.length && !state.removeTile) {
      var tileMoved = false;
      for (var i1 = 0; i1 < missing.length; i1++) {
        pMissing = missing[i1];
        if (possibleMissing.length && pMissing == (selected.tile.x)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y) {
          if (tutorial.state == "schiebenSelectGapMoveMultipleTurorial") goTutorialSteps(1);
          moveTile(possibleMissing.filter(x => x.i1 == i1)[0].i, i1);
          tileMoved = true;
        }
        else {
        if ((pMissing == (selected.tile.x + 1)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y) /*right*/ || (pMissing ==(selected.tile.x - 1)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y)/*left*/ || (pMissing == selected.tile.x*lengthPerTeil.edit.x + ' - ' + (selected.tile.y + 1)*lengthPerTeil.edit.y)/*down*/ || (pMissing == (selected.tile.x*lengthPerTeil.edit.x + ' - ' + (selected.tile.y - 1)*lengthPerTeil.edit.y)/*up*/)) {
          for (var i = 0; i < positions.wrong.length; i++) {
            if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == selected.tile.x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == selected.tile.y) {
              possibleMissing.push({i: i, i1: i1});
            }
          }
        }
      }
  }
  if (possibleMissing.length == 1 && !tileMoved) {
    if (tutorial.state == "schiebenNormalTurorial") goTutorialSteps(1);
    moveTile(possibleMissing[0].i, possibleMissing[0].i1);
  }
  if (possibleMissing.length > 1 && tutorial.state == "schiebenSelectTileMoveMultipleTurorial") goTutorialSteps(1);
}
    else if (selected.tile && (modeSelection.value == "exchange"/* || missing*/) && !state.exchangedTiles && !state.unselected) {
      selected.coord = {x: selected.tile.x, y: selected.tile.y};
      selected.tiles = [getTileIByCoord(selected.tile)];
      selected.boolean.click = true;
      if (["selectFirstExchangeNormalTutorial", "selectTileUnselectStandardTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
  }
    selected.tile = checkSelected(true);
    if (selected.tile && ((!missing.length && modeSelection.value == "schieben") || state.removeTile) && (!lastCoord || JSON.stringify(lastCoord) != JSON.stringify(selected.tile) || (((state.mouse == "up" && calledBy != "elm") || calledBy == "mouseDown") && JSON.stringify(state.coord) == JSON.stringify(selected.tile)))) {
      removeTile(null, calledBy);
      lastCoord = selected.tile;
    }
    else {
      if (aufgebenId.style.display == "inline") layout(false, true);
    }
    selected.tile = checkSelected();
  }
  function getTileIByCoord(coord, positionType) {
    if (!positionType) positionType = "wrong";
    for (let i = 0; i < positions[positionType].length; i++) {
      if (positions[positionType][i].edit.x/lengthPerTeil.edit.x == coord.x && positions[positionType][i].edit.y/lengthPerTeil.edit.y == coord.y) return i;
    }
  }
  // section 2.1: movementPlayer (player of PC movement in schieben mode)
  function getShortestPCMovement(restorePuzzle) {
  if (!state.restorePuzzle && !restorePuzzle) {
    movement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
    verschiebenPC();
  }
  wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
  setTimeout(function () {
    // create misstingDistinct
    distinctMoves = JSON.parse(JSON.stringify(movement.move));
    var distinctPositions = [];
    var change;
    var firstRunThrough = true;
    playerMovement = movement.move;
    do {
      change = false;
      var leftBeginning = 1;
      for (let i = 0; i < movement.move.length; i++) {
        var move = JSON.stringify(playMovementPos(i, true, true));
      if (distinctPositions.includes(move) || JSON.stringify(movement.startPosition) == move) {
        for (let i1 = leftBeginning; i1 < /*movement.move.length*/i; i1++) {
          if (JSON.stringify(playMovementPos(i1, true, true)) == move && distinctMoves[i1] != undefined && distinctMoves[i] != undefined) {
            distinctPositions.splice(i1, (i - i1));
            // distinctMoves.splice(i1, (i - i1));
            // console.log('lösche ' + i1 + ' bis ' + (i-1));
            distinctMoves.fill(undefined, i1, i);
            leftBeginning = i1 + (i - i1);
            // i1 = i1 + (i - i1);
            change = true;
            break;
          }
        }
        }
        if (firstRunThrough) distinctPositions.push(move);
      }
      firstRunThrough = false;
    } while (change)
    distinctMoves = distinctMoves.filter(x => x != undefined);
    if (distinctMoves[0] && ((Math.abs(distinctMoves[0].x) == Math.abs(distinctMoves[1].x) || Math.abs(distinctMoves[0].y) == Math.abs(distinctMoves[1].y)) && distinctMoves[0].tile == distinctMoves[1].tile)) distinctMoves.splice(0, 2);
    positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
    movementStepsChanged(distinctMovement.checked);
    state.redoI1 = undefined;
  }, 500);
  movementPlayer.style.display = 'inline';
  movementPlayerTextur.width = textur.width;
  movementPlayerTextur.height = textur.height;
}
  var userMovement = {index: 0, moves: []};
  function movementStepsChanged(checked, doNotSetChecked) {
    if (!doNotSetChecked)  distinctMovement.checked = checked;
    if (checked) playerMovement = distinctMoves;
    else playerMovement = movement.move;
    movementPosition.max = playerMovement.length;
  }
  function playPauseMovement() {
    if (movementPlayButton.innerHTML == "play") {
      movementPlayButton.innerHTML = "pause";
      playMovementFunction();
    }
    else movementPlayButton.innerHTML = "play";
  }
  var playerMovement = [];
  function playMovementFunction() {
    if (movementPlayButton.innerHTML == "pause") {
      if (JSON.parse(movementPosition.value) < playerMovement.length || JSON.parse(movementPosition.value) + objMovementPlayer.direc < 0) playMovementPos(JSON.parse(movementPosition.value) + objMovementPlayer.direc);
      else movementPlayButton.innerHTML = "play";
      setTimeout(function () {
        playMovementFunction();
      }, JSON.parse(movementPlayerSpeed.value));
    }
  }
  var objMovementPlayer = {pause: false, position: 0, direc: 1};
  function getPlayerPosition(backToBeginningIfNeeded, easySteps) {
    for (let i = 0; i < playerMovement.length; i++) {
      if (JSON.stringify(playMovementPos(i, true, true)) == JSON.stringify(movement.playerPosition)) {
        return i;
      }
    }
    if (easySteps != undefined) {
      movementStepsChanged(easySteps);
    }
    else {
      movementStepsChanged(false, true);
      getPlayerPosition(false, distinctMovement.checked);
    }
    if (backToBeginningIfNeeded) return 0;
    else return JSON.parse(movementPosition.value);
  }
  var wrongPosition;
  function playMovementPos(position, pReturn, doNotChangeVal, pPlayerMovement) {
    var isUserMovement = pPlayerMovement != undefined;
    if (!pPlayerMovement) pPlayerMovement = playerMovement;
    else {
      if (goBackAsTurns.checked) stats.turns += Math.abs(position - playerMovementSlider.value);
      playerMovementSlider.value = position;
      state.changedPos = true;
      userMovement.index = position;
      setTimeout(() => {
        movement.playerPosition = positions.wrong;
        storePuzzle();
      }, 100);
    }
    if (position < 0) position = 0;
    if (position > pPlayerMovement.length) position = pPlayerMovement.length;
    if (!doNotChangeVal) movementPosition.value = position;
    if (!isUserMovement) positions.wrong = JSON.parse(JSON.stringify(movement.startPosition));
    else positions.wrong = JSON.parse(JSON.stringify(userMovement.startPosition));
    for (let i = pPlayerMovement.length - 1; i >= position; i--) {
      if (isUserMovement) missing[pPlayerMovement[i].i1] = positions.wrong[pPlayerMovement[i].tile].edit.x + ' - ' + positions.wrong[pPlayerMovement[i].tile].edit.y;
      positions.wrong[pPlayerMovement[i].tile].edit.x += pPlayerMovement[i].x;
      positions.wrong[pPlayerMovement[i].tile].edit.y += pPlayerMovement[i].y;
    }
    if (pReturn) return positions.wrong;
    // PC movement player
    if (!isUserMovement) {
      canvas = movementPlayerTextur.getContext('2d');
      objMovementPlayer.position = JSON.parse(position);
    }
    layout(true, true);
  }
  // end section 2.1
    // backTobar button clicked
    var offline = false;
    function posInBarSelected(i) {
      if (tutorial.state == "BackToTileBarTutorial") goTutorialSteps(1);
      if (Array.from(document.getElementsByClassName('backToTileB')).filter(x => x.style.backgroundColor != "").length && i == state.backToBar) {
        state.backToBar = "unselect " + i;
      }
    for (const elm of document.getElementsByClassName('backToTileB')) {
      elm.style.backgroundColor = '';
    }
    if (tileSelectionBar.tiles.length != positions.wrong.length && state.backToBar != "unselect " + i) {
      state.backToBar = i; 
      document.getElementsByClassName('backToTileB')[i].style.backgroundColor = 'red';
    }
    if (typeof state.backToBar === "string" && state.backToBar.includes("unselect")) state.backToBar = false;
    tileSelectionBar.selectedTile = undefined;
    layout();
  }
  // section 2.2: handle input data (picture, video, URL)
  // load selected file
  function readImg(input) {
    var cancelLoading = false;
    sourceCheckboxes.style.display = 'none';
    var reader = new FileReader();
    stopLiveFeed();
    if (!state.restorePuzzle || state.restorePuzzle.fileName == input.files[0].name || confirm("You have probably selected the wrong puzzle. If you still want to continue, click on OK or similar (otherwise click on Cancel or similar and again on the name of the picture to select the correct picture). )")) {
      reader.onload = function (e) {
        if (sourceIsPicture.checked) {
          document.getElementById('preview').setAttribute("src", e.target.result);
          videoControls.style.display = "none";
        }
        else {
          video.setAttribute("src", e.target.result);
          loadImage(video.videoWidth, video.videoHeight);
        }
      };
    }
      else if (state.restorePuzzle) {
        cancelLoading = true;
      }
    reader.readAsDataURL(input.files[0]);
    if (input.files[0].type.includes('video')) sourceIsVideo.checked = true;
    else sourceIsPicture.checked = true;
    for (const puzzle of Object.keys(puzzles)) {
      if (!state.restorePuzzle && puzzles[puzzle].fileName == input.files[0].name && confirm('You have already started a puzzle with this file in the mode "' + puzzles[puzzle].mode + '"! You have saved it under the name "' + puzzle + '". Would you like to load it?')) {
        restorePuzzleSource(puzzle, true);
        break;
      }
    }
    if (!cancelLoading && sourceIsPicture.checked) loadImage();
    fileName = input.files[0].name;
    setTimeout(() => {
      if (state.waitForPictureSelection) startTutorial();
      editCanvasDiv.insertBefore(textur, videoControls)
    }, 1111);
  }
  function adaptVideoControlElements() {
    if (!sourceIsVideo.checked) return;
    if (!useLiveCam.checked) videoControls.style.display = 'block';
    editCanvasDiv.style.display = "block";
    videoPosition.max = video.duration;
    settings.style.display = 'block';
    videoPosition.style.width = window.innerWidth;
    while (timeText.getBoundingClientRect().x < videoPosition.getBoundingClientRect().x + convertStyle(videoPosition.style.width)) {
      videoPosition.style.width = (convertStyle(videoPosition.style.width) - 1) + 'px';
    }
    videoPosition.style.width = (convertStyle(videoPosition.style.width) - 15) + 'px';
    playVideo.style.width = playVideo.getBoundingClientRect().width;
    settings.style.display = 'none';
    editCanvasDiv.style.display = "none"
    if (video.srcObject) {
      for (const elm of timeChangeDiv) {
        elm.style.display = 'none';
      }
    }
  }
  var fileName;
  var video = document.createElement("video");
  function useURL() {
    useURLCheck.checked = true;
    sourceCheckboxes.style.display = 'none';
    if (sourceURL.value.includes('.mp4') || sourceURL.value.includes('.move')) sourceIsVideo.checked = true;
    else if (sourceURL.value.includes('.png') || sourceURL.value.includes('.jpg') || sourceURL.value.includes('.jpeg')) {
      sourceIsPicture.checked = true;
      videoControls.style.display = "none";
    }
    else {
     document.getElementById('sourceIs' + state.userSource).checked = true;
     sourceCheckboxes.style.display = 'block';
  }
    stopLiveFeed();
    for (const puzzle of Object.keys(puzzles)) {
      if (!state.restorePuzzle && sourceURL.value == puzzles[puzzle].URL && confirm('You have already started a puzzle with this link/URL in the mode "' + puzzles[puzzle].mode + '"! You have saved it under the name "' + puzzle + '". Would you like to load it?')) {
        restorePuzzleSource(puzzle, true);
        break;
      }
    }
    if (sourceIsPicture.checked) {
        preview.src = sourceURL.value;
    loadImage();
  }
  else {
    video.src = sourceURL.value;
  }
  adaptVideoControlElements();
  }
  function startVideo() {
    video.play();  // start playing
    updateVideo(); //Start rendering
  }
  video.addEventListener('loadeddata', function() {
    startVideo();
    adaptVideoControlElements();
    // TODO: vereinheitlichen?
    preview.width = video.videoWidth;
    preview.height = video.videoHeight;
    originalSize.width = video.videoWidth;
    originalSize.height = video.videoHeight;
    selectSourceHeader.style.color = "green";
    createPuzzleButton.style.backgroundColor = "green";
    loadPuzzle();
    // TODO: kann weg? (KA wofür)
    // loadImage(video.videoWidth, video.videoHeight);
  }, false);
  var originalSize = {};
  function loadPuzzle() {
    if (state.restorePuzzle) {
        größeAnpassenX.max =  state.restorePuzzle.width;
        größeAnpassenY.max =  state.restorePuzzle.height;
        größeAnpassenX.value = state.restorePuzzle.width;
        größeAnpassenY.value = state.restorePuzzle.height;
        if (state.restorePuzzle.tileBarTiles) shuffleStyle.value = "listTiles";
        else shuffleStyle.value = "nextToEachOther";
        create();
        shufflePuzzle();
        restorePuzzle(state.restorePuzzle);
        delete state.restorePuzzle;
      }
  }
  function loadImage(width, height) {
    setTimeout(function () {
      URLInfo.style.display = 'none';
      // videoPosition.style.width = window.innerWidth - 33 - timeText.getBoundingClientRect().width - 126.234375*2;
      if (!width) {
        width = preview.width;
        height = preview.height;
      }
      originalSize = {width: width, height: height};
      try {
        canvas.drawImage(document.getElementById('preview'), 0, 0);
      } catch (err) {
        if (useURLCheck.checked) {
          URLInfo.style.display = 'block';
          selectSourceHeader.style.color = "red";
          createPuzzleButton.style.backgroundColor = "red";
        }
        // TODO: kann auch passieren, wenn URL nicht auf Bild/Video zeigt
        offline = true;
      }
      if (aufgebenId.style.display != "inline") {
        changeAdaptedSizeMax(width, height);
        zuAngepassterBildschirmgröße();
      } 
      loadPuzzle();
    }, 500);
    selectSourceHeader.style.color = "green";
    createPuzzleButton.style.backgroundColor = "green";
  }
  // end section 2
  // section 3: handle videos

  // returns string with UI time
// @param: pTime: total time in seconds
function getTimeString(pTime) {
  pTime = Math.floor(pTime);
  var sec, mins, hours;
  hours = Math.floor(pTime / 60 / 60);
  mins = Math.floor(pTime / 60) - hours*60;
  sec = pTime - mins*60 - hours*60*60;
  if (sec < 10) sec = '0' + sec; 
  if (mins < 10) mins = '0' + mins; 
  if (hours < 10) hours = '0' + hours;
  return `${hours}:${mins}:${sec}`;
}
// converts time string back into time in seconds
// @param: 
  // value: String with UI time layout
  // id: undefined or loopEnding (value then is time stamp of loop ending)
  function convertTime(value, id){
  var time = 0;
  var sec = value.split(':')[2];
  var mins = value.split(':')[1];
  var hours = value.split(':')[0];
  if (sec < 10) sec = sec[1];
  if (mins < 10) mins = mins[1];
  if (hours < 10) hours = hours[1];
  if (value.split(':')[3]) time += parseInt(value.split(':')[3])/100;
    try {
      time += JSON.parse(sec);
      time += JSON.parse(mins)*60;
      time += JSON.parse(hours)*60*60;
      if (time > video.duration || time < 0) console.log(abc);
    }
    catch (e) {
      if (id == 'loopEnding') time = video.duration;
      else time = 0;
    }
  return time;
}
// draw changes in the video on the canvas and changes the current position in the video
function updateVideo(){
    videoPosition.value = video.currentTime;
    timeText.innerHTML = getTimeString(video.currentTime) + ' / ' + getTimeString(video.duration);
    canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
    if (aufgebenId.style.display == "inline") {
      for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
        var i = i1;
        if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
        if (shuffleStyle.value == "listTiles" && tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], false, i, tileSelectionBar.canvas);
        else drawPictureSegment(positions.wrong[i], positions.right[i], false, i);
      }
    }
    else  if (state.removeTile) {
      for (let i = 0; i < amountX.value; i++) {
        for (let i1 = 0; i1 < anzahlY.value; i1++) {
          canvas.drawImage(video, positions.wrong[i1*amountX.value + i].original.x, positions.wrong[i1*amountX.value + i].original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, i*lengthPerTeil.edit.x + 3*i, i1*lengthPerTeil.edit.y + 3*i1, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
        }
      }
    }
    else {
      canvas.drawImage(video,0,0, größeAnpassenX.value, größeAnpassenY.value);
      drawTileGrid(true);
    }
    videoPreview.getContext('2d').drawImage(video, 0, 0, größeAnpassenX.value, größeAnpassenY.value);
    showSelected();
    showClippingOptions();
    if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')  && loop.checked) {
      video.currentTime = convertTime(loopBeginning.value);
      if (loopEnding.value > loopBeginning.value || loopEnding.value == "" || loopBeginning.value == "") video.play();
    }
    else if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')) {
      // TODO: stoppt automatisch, kann also weg?
      // if (stopAtEnd.checked) playPauseVideo('pause');
      /*else */if(video.currentTime >= video.duration) playVideo.innerHTML = 'play';
    }
    if (sourceIsVideo.checked) requestAnimationFrame(updateVideo); // wait for the browser to be ready to present another animation fram.
    else video.pause();
}
// section 3.1: live camera
// Prefer camera resolution nearest to 1280x720.
var constraints = { /*audio: true, */video: { width: 1280, height: 720 } };
var pMediaStream;
// stop live feed, so another one can start
function stopLiveFeed() {
  if (pMediaStream) {
    pMediaStream.getTracks().forEach(track => {
      track.stop();
    });
    video.srcObject = undefined;
  }
  // pMediaStream = undefined;
}
// changes camera source
async function changeCamera(index) {
  for (const puzzle of Object.keys(puzzles)) {
    if (!state.restorePuzzle && index == puzzles[puzzle].liveCam && confirm('You have already started a puzzle with this camera in "' + puzzles[puzzle].mode + '" mode! You have saved it under the name "' + puzzle + '". Would you like to load it?')) {
      restorePuzzleSource(puzzle, true);
      break;
    }
  }
  sourceCheckboxes.style.display = 'none';
  sourceIsVideo.checked = true;
  stopLiveFeed();
  var Test = await navigator.mediaDevices.enumerateDevices();
  constraints.video.deviceId = Test[index].deviceId;
  navigator.mediaDevices.getUserMedia(constraints)
  .then(function(mediaStream) {
    video.srcObject = mediaStream;
    pMediaStream = mediaStream;
  })
}

// gets available cameras
navigator.mediaDevices.enumerateDevices()
.then(function(devices) {
  var option = 0;
  devices.forEach( (device, i) => {
    console.log(device.kind + ": " + device.label + " id = " + device.deviceId);
    if (device.kind == "videoinput") {
      option++;
      opt = document.createElement("option");
      opt.text = device.label;
      if (opt.text == "") opt.text = "option " + option;
      opt.value = i;
      document.getElementById("cameraSelection").options.add(opt);
    }
  });
  if (cameraSelection.options.length < 2) cameraSelection.style.display = 'none';
  if (!cameraSelection.options.length) useLiveCam.style.display = 'none';
})
// end section 3
var puzzles = {};
  getPuzzles();
  function getPuzzles() {
    while (puzzleSelection.getElementsByTagName('li').length) {
      puzzleSelection.getElementsByTagName('li')[0].remove();
    }
    puzzles = JSON.parse(localStorage.getItem('puzzleCreatorPuzzles'));
    if (!puzzles) puzzles = {};
    for (const puzzle of Object.keys(puzzles)) {
      var option = document.createElement('li');
      option.innerHTML = puzzle;
      option.value = puzzle;
      option.id = 'select ' + puzzle;
      option.onclick = () => {
        selected.puzzle = puzzle;
        if (editPuzzleManager.style.display == "none") editPuzzleManager.style.display = "inline";
        else editPuzzleManager.style.display = "none";
        editPuzzleManager.style.top = document.getElementById('select ' + puzzle).getBoundingClientRect().bottom;
      };
      puzzleSelection.appendChild(option);
    }
  }
  function restorePuzzleSource(name, sourceLoaded) {
    var puzzle = puzzles[name];
    state.restorePuzzle = true;
    amountX.value = puzzle.tileAmount.x;
    anzahlY.value = puzzle.tileAmount.y;
    modeSelected(puzzle.mode);
    if (!sourceLoaded) {
      if (puzzle.fileName) {
        alert('Please select the file "' + puzzle.fileName + '". you were using');
        fileB.click();
      }
      if (puzzle.URL) {
        sourceURL.value = puzzle.URL;
        useURL();
      }
      if (puzzle.liveCam) {
        cameraSelection.value = puzzle.liveCam;
        changeCamera(puzzle.liveCam);
      }
    }
    state.restorePuzzle = puzzle;
    puzzleName.value = name;
    doStorePuzzle.checked = true;
  }
  function restorePuzzle(puzzle) {
    setTimeout(() => {
        positions = puzzle.positions;
        stats = puzzle.stats;
        if (sourceIsVideo.checked) {
          loopBeginning.value = puzzle.loopBeginning;
          loopEnding.value = puzzle.loopEnding;
          video.currentTime = convertTime(loopBeginning.value);
        } 
        if (puzzle.mode == "schieben") {
          movement = puzzle.movement;
          missing = puzzle.missing;
          getShortestPCMovement(true);
          movement.playerPosition = positions.wrong;
          userMovement = puzzle.userMovement;
          userMovement.index++;
          playerMovementSlider.max = userMovement.moves.length;
          playerMovementSlider.value = userMovement.index + 1;
          playMovementPos(puzzle.movementPlayerPosition, null, null, userMovement.moves);
        }
        if (puzzle.mode == "traditional") {
          rotateTiles.checked = puzzle.settings.rotateTiles;
          if (puzzle.tileBarTiles) tileSelectionBar.tiles = puzzle.tileBarTiles;
          mirrorInput.checked = puzzle.settings.mirrorInput;
          mirrorCanvas(mirrorInput.checked);
          restoreClipped();
        while (positions.wrong.filter(x => x.edit.x < -lengthPerTeil.edit.x/2).length) {
          expandSide('left');
        }
        while (positions.wrong.filter(x => x.edit.x > textur.width + lengthPerTeil.edit.x/2).length) {
          expandSide('right');
        }
        while (positions.wrong.filter(x => x.edit.y < -lengthPerTeil.edit.y/2).length) {
          expandSide('top');
        }
        while (positions.wrong.filter(x => x.edit.y > textur.height + lengthPerTeil.edit.y/2).length) {
          expandSide('bottom');
        }
      }
      layout(true, true);
    }, 500);
    stopClock.completionTime.time = puzzle.completionTime;
    stopClock.viewOriginal.time = puzzle.viewOriginalTime;
  }
  function restoreClipped() {
    for (let i = 0; i < positions.wrong.length; i++) {
      getConnectedTiles(i, true, null, true);
    }
  }
  // scroll TileSelectionBar (translate)
  function scrollTileSelection(direc, calledBy) {
    if (tutorial.state == "scrollArrowTileBarTutorial" && calledBy == "elm") goTutorialSteps(1);
    if (tutorial.state == "ScrollkeyTileBarTutorial" && calledBy == "arrowKey") goTutorialSteps(1);
    var screenScrollX = window.visualViewport.width/lengthPerTeil.sizeAdapted.x*lengthPerTeil.edit.x;
    if (screenScrollX/lengthPerTeil.edit.x > positions.wrong.length) screenScrollX = positions.wrong.length*lengthPerTeil.edit.x;
    tileSelectionBar.leftOffScreenTiles += direc;
    var scrollXBefore = tileSelectionBar.scrollX;
    tileSelectionBar.scrollX += (lengthPerTeil.edit.x + 5)*(direc*(-1));
    if (tileSelectionBar.scrollX >= lengthPerTeil.edit.x + 5) {
      tileSelectionBar.offset = 0;
      tileSelectionBar.scrollX = lengthPerTeil.edit.x + 5;
      tileSelectionBar.leftOffScreenTiles = -1;
    }
    if (tileSelectionBar.scrollX >= 0) scrollTileSelectionLeft.style.display = 'none';
    else scrollTileSelectionLeft.style.display = 'inline';
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX) {
      if (!tileSelectionBar.offset) {
        tileSelectionBar.offset = - (scrollXBefore - (-((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX));
        tileSelectionBar.elmleftBefore = document.getElementsByClassName('backToTileB')[0].style.left;
      }
      tileSelectionBar.scrollX = -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX + 1;
      tileSelectionBar.leftOffScreenTiles = tileSelectionBar.tiles.length - Math.ceil(screenScrollX/lengthPerTeil.sizeAdapted.x) + 1;
    }
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length)) + screenScrollX) scrollTileSelectionRight.style.display = 'none';
    else scrollTileSelectionRight.style.display = 'inline';
    layout(true, true);
    positionBackToTileBarButtons();
  }
  var tileSelectionBar = {canvas: tileSelectionCanvas.getContext('2d'), tiles: [], scrollX: 1, height: 0, leftOffScreenTiles: 0, offset: 0};
  tileSelectionBar.collidesMouse = () => {
    var obj = tileSelectionCanvas.getBoundingClientRect();
    return collides({x: mausx, y: mausy - scrollY + texturTop, width: 1, height: 1}, obj).boolean;
  }
  tileSelectionBar.getTilePosition = (generalPosition) => {
    for (const tile of tileSelectionBar.tiles) {
      if (tile == generalPosition) return tile;
    }
  }
  // get amount of tiles on x and y-axis to equal width and height
  function getSizeTileAmoutAdaption() {
    for (let i = 0; i < 1000; i++) {
      for (let i1 = 0; i1 < 1000; i1++) {
        if (i > 1 && i1 > 1 && !Math.abs(Math.abs(Math.round(größeAnpassenX.value/i)) - Math.abs(Math.round(größeAnpassenY.value/i1))) && i*i1 > minTileAmount.value) {
          return {x: i, y: i1};
        }
      }
    }
  }
  // adapt amount of tiles on x and y-axis to equal width and height
  function adaptTileAmount(adaptionStyleChanged) {
    if (modeSelection.value == 'traditional' && rotateTiles.checked) {
      var data = getSizeTileAmoutAdaption();
      if (data) {
        amountX.value = data.x;
        anzahlY.value = data.y;
      }
    }
  }
  function addElement(attr, elm, childOf, asElement) {
      var newElement = document.createElement(/*'span'*/elm);
      if (childOf && !asElement) document.getElementById(childOf).appendChild(newElement);
      else if (childOf) childOf.appendChild(newElement);
      else tests.appendChild(newElement);
      for (attrNow of Object.keys(attr)) {
        if (attrNow == 'innerText') newElement.innerText = attr[attrNow];
        else newElement.setAttribute(attrNow/*'style'*/, /*'color:' + word[i].colour*/attr[attrNow]);
      }
    }
  var lengthPerTeil = {};
  var positions = {right: [], wrong: []};
  var finished = false;
  var missing = [];
  var distinctMoves = [];
  function convertDirection(direc, degr) {
    var directions = ['top', 'right', 'bottom', 'left'];
    var direcObj = {top: 0, right: 1, bottom: 2, left: 3};
    while (degr > 0) {
      direc = directions[direcObj[direc] - 1];
      if (!direc) direc = directions[0];
      degr -= 90;
    }
    return direc;
  }
  // section 4: layout
  function showSelectedTile(tile, color) {
    canvas.fillStyle = color;
    canvas.save();
    if (state.removeTile || (!state.removeTile && modeSelection.value == "exchange")/* && modeSelection.value != "schieben"*/) canvas.translate(positions.wrong[tile].edit.x + lengthPerTeil.edit.x/2, positions.wrong[tile].edit.y + lengthPerTeil.edit.y/2);
    else canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
    canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
    canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.restore();
  }
  function showSelected() {
    for (var tile of selected.tiles) {
      showSelectedTile(tile, "rgba(255, 0, 0, 0.3)");
    }
    for (var tile of doNotChange) {
      showSelectedTile(tile, "rgba(0, 76, 255, 0.3)");
    }
  }
  function showClippingOptions() {
    for (var clip of selected.clip) {
      pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
      if ([90, 270].includes(positions.wrong[clip.sI].original.degree)) {
        pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
        pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
      }
      canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
      if (markWrong.checked && (JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) canvas.fillStyle = 'rgba(255, 0, 0, 0.83)';
      if (!tileSelectionBar.tiles.includes(clip.i)) {
        canvas.save();
        if (highHitboxVisibility.checked) {
          canvas.translate(clip.original.x, clip.original.y);
          canvas.fillRect(-((pLengthPerTeil.edit.x)/2), -((pLengthPerTeil.edit.y)/2), clip.original.width, clip.original.height);
        }
        else {
          canvas.translate(clip.x, clip.y);
          canvas.fillRect(-((pLengthPerTeil.edit.x)/2), -((pLengthPerTeil.edit.y)/2), clip.width, clip.height);
        }
        canvas.restore();
      }
    }
  }
  function layout(withoutAlert, clear, pReturn, removeTilesScreen) {
    if (state.removeTile) removeTilesScreen = true;
    if (clear && (aufgebenId.style.display == 'inline' || state.removeTile)) canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
    if (lengthPerTeil.sizeAdapted) tileSelectionCanvas.width = positions.wrong.length*(lengthPerTeil.edit.x*(lengthPerTeil.edit.x/lengthPerTeil.sizeAdapted.x));
    else if (positions.wrong.length) tileSelectionCanvas.width = positions.wrong.length*lengthPerTeil.edit.x;
    if (lengthPerTeil.sizeAdapted && (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*tileSelectionBar.tiles.length < window.innerWidth) tileSelectionBar.scrollX = 0;
    richtige = 0;
    if (modeSelection.value == "schieben") {
      for (const position of positionsBeginning) {
        if (showRemovedTiles.checked) drawPictureSegment(position, position, removeTilesScreen, null, null, null, 0.5);
      }
    }
    for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
      var i = i1;
      if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
      if (!tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i);
    }
    for (var i1 = 0; i1 < tileSelectionBar.tiles.length; i1++) {
      var i = tileSelectionBar.tiles[i1];
      drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i, tileSelectionBar.canvas, i1);
    }
    showClippingOptions();
    showSelected();
    if (stats.highestRight.right < richtige && !withoutAlert) {
      stats.highestRight = {right: richtige, turns: stats.turns};
    }
    if (stats.preOrdered == "pending") stats.preOrdered = richtige;
    if (richtige == positions.wrong?.length && !removeTilesScreen && !finished && !state.restorePuzzle && imageSettings.style.display == "none") {
      if (doStorePuzzle.checked && settings.style.display != "inline") {
        delete puzzles[puzzleName.value];
        localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
      }
      stopClock.completionTime.running = 0;
      richtige = 0;
      if(!withoutAlert) {
        if (tutorial.state == "completePuzzleTutorial") goTutorialSteps(1);
        selected.tiles = [];
        finished = true;
        if (pReturn) return "noChange!";
        if (modeSelection.value == "schieben") alert("You did it in " + stats.turns + " moves (you could have done it in " + distinctMoves.length + " moves or less) and a total of " + stats.completionTime + " minutes! It took the computer " + movement.move.length + " moves to slide the original image into the formation you saw in the beginning. Whether you can be proud of that, you have to decide for yourself ;)");
        if (modeSelection.value == "exchange") alert(`You made it in ${stats.turns} moves and a total of ${stats.completionTime} minutes! (You could have done it in ${positions.wrong.length - stats.preOrdered} moves). You had ${stats.preOrdered} parts of the total ${positions.wrong.length} parts in the right position from the start.`);
        if (modeSelection.value == "traditional") alert(`Great! You have completed the puzzle in ${stats.completionTime} minutes! You have connected pieces ${stats.turns} times (you can do it with at least ${amountX.value*numberY.value - 1} times) and pulled pieces apart again ${stats.unclipped} times. You have connected parts incorrectly ${stats.wrongClipped} times. The sum of your piece rotations is ${stats.rotated}. You could have done it with at least ${stats.minimumRotations} times.`);
        if (stats.viewOriginal.times > 0) alert(`You have also looked at the original image ${stats.viewOriginal.times} times for a total of ${stats.viewOriginal.time} minutes.`.replace('undefined', '0'));
        if (reloadWhenFinished.checked) {
          setTimeout(function () {
            window.location.reload(false);
          }, 3000);
        }
        else alert("Please reload the page if you want to create another puzzle!");
        layout(true);
    }
  }
}
  var richtige = 0;
  function drawPictureSegment(position, segmentPosition, removeTilesScreen, i, pCanvas, i1, tileTransparency) {
    if (i1 == undefined) i1 = tileSelectionBar.getTilePosition(i);
    if (!pCanvas) pCanvas = canvas;
    else if (!state.modelEmptybar) {
      position.edit = {x: 5 + (lengthPerTeil.edit.x + 5)*i1 + lengthPerTeil.edit.x/2, y: tileSelectionBar.height/2/*5 + lengthPerTeil.edit.y/2*/, degree: 0};
    }
    pCanvas.save();
    if (modeSelection.value == "traditional" && !removeTilesScreen) pCanvas.translate(position.edit.x, position.edit.y);
    else pCanvas.translate(position.edit.x + lengthPerTeil.edit.x/2, position.edit.y + lengthPerTeil.edit.y/2);
    if (pCanvas.canvas.id == "tileSelectionCanvas") {
      pCanvas.translate(tileSelectionBar.scrollX, 0);
      tileSelectionBar.canvas.fillStyle = "red";
      if (tileSelectionBar.selectedTile?.tileI == i) {
        if ([90, 270].includes(position.original.degree)) tileSelectionBar.canvas.fillRect(-(lengthPerTeil.edit.y/2) - 5, -(lengthPerTeil.edit.x/2) - 5, lengthPerTeil.edit.y + 10, lengthPerTeil.edit.x + 10);
        else tileSelectionBar.canvas.fillRect(-(lengthPerTeil.edit.x/2) - 5, -(lengthPerTeil.edit.y/2) - 5, lengthPerTeil.edit.x + 10, lengthPerTeil.edit.y + 10);
      }
    }
    pCanvas.rotate(position.original.degree*Math.PI/180);
    if (tileTransparency) canvas.globalAlpha = tileTransparency;
    if (modeSelection.value == "traditional") canvas.globalAlpha = parseFloat(tileTransparencySlider.value);
    if (sourceIsPicture.checked) pCanvas.drawImage(document.getElementById('preview'), /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    else pCanvas.drawImage(video, /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // pCanvas.restore();
    canvas.globalAlpha = 1;
    // #potentialErrorCause
    if (tileTransparency != 0.5 && (((modeSelection.value != "traditional" && position.edit.x == segmentPosition.edit.x && position.edit.y == segmentPosition.edit.y) || (modeSelection.value == "traditional" && angular.equals(position.original, segmentPosition.original) && connectedTilesRotationRight(position.original))) && !removeTilesScreen && !state.removeTile && !finished)) {
      var rgbColor = hexTorgb(markRightColor.value);
      pCanvas.fillStyle = `rgba(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]}, ${rightMarkerTransparence.value})`
      if (richtigPlazierte.checked) {
        pCanvas.fillRect(-(lengthPerTeil.edit.x*rightMarkerRadius.value)/2, -(lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
      }
      richtige++;
    }
    pCanvas.restore();
    var rgbColor = hexTorgb(borderColor.value);
    pCanvas.fillStyle = `rgba(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]}, ${borderTransparency.value})`;
    if (raender.checked) {
      pCanvas.save();
      if (modeSelection.value == "traditional" && !state.removeTile) pCanvas.translate(position.edit.x, position.edit.y);
      else pCanvas.translate(position.edit.x + (lengthPerTeil.edit.x)/2, position.edit.y + (lengthPerTeil.edit.y)/2);
      pCanvas.rotate((position.original.degree)*Math.PI/180);
      if (position.border.includes("right")) pCanvas.fillRect((lengthPerTeil.edit.x)/2 - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("left")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2) + JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("top")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2) + JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      if (position.border.includes("bottom")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), ((lengthPerTeil.edit.y)/2) - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      pCanvas.restore();
    }
  }
  // end section 4
  function connectedTilesRotationRight(positionOriginal) {
    for (const direc of ['right', 'bottom', 'left', 'top']) {
      if (positionOriginal[direc]) {
        var connectedTile = getTile(positionOriginal[direc]);
        if (connectedTile != undefined && positions.wrong[connectedTile].original.degree) return false;
      }
    }
    return true;
  }
  var selected = {boolean: false, position: {x: 0, y: 0}, tiles: [], objTiles: [], clip: []};
  var lastCoord;
  function moveTile(i, i1) {
    console.log("schiebe...");
    possibleMissing = [];
    pMissing = missing[i1];
    stats.turns++;
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i]));
    if (userMovement.index < userMovement.moves.length - 1) {
      userMovement.moves.splice(userMovement.index, userMovement.moves.length - userMovement.index);
    }
    userMovement.moves.push({x: -(JSON.parse(pMissing.split(' - ')[0]) - positions.wrong[i].edit.x), y: -(JSON.parse(pMissing.split(' - ')[1]) - positions.wrong[i].edit.y), tile: i, i1: i1});
    userMovement.index++;
    playerMovementSlider.max = userMovement.moves.length;
    playerMovementSlider.value = userMovement.index + 1;
    positions.wrong[i].edit = {x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0};//.splice(side, 1);
    missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
    selected.boolean = false;
    movement.playerPosition = positions.wrong;
    userMovement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
    if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
  }
  var doNotChange = [];
  var possibleMissing = [];
  // select tiles to be removed or ignored
  function removeTile(first, calledBy) {
    if (!first && (!state.tileRemoved || calledBy == "touchmove" || calledBy == "mousemove")) {
      state.tileRemoved = true;
      setTimeout(function () {
        state.tileRemoved = false;
      }, 133);
    positions.wrong.forEach((position, i) => {
      if (position.x == checkSelected(true).x && position.y == checkSelected(true).y/*position.edit.x/lengthPerTeil.edit.x == checkSelected().x && position.edit.y/lengthPerTeil.edit.y == checkSelected().y*/) {
        if (pRemoveTile.checked && !selected.tiles.includes(i)) {
          selected.tiles.push(i);
          doNotChange = doNotChange.filter(x => x != i);
          selected.objTiles.push(JSON.stringify({x: position.edit.x - 3*position.x, y: position.edit.y - 3*position.y, degree: 0}));
        }
        else if (doNotMoveTile.checked && !doNotChange.includes(i)) {
          doNotChange.push(i);
          selected.tiles = selected.tiles.filter(x => x != i);
        }
        else if (pRemoveTile.checked && selected.tiles.includes(i)) {
          for (var i1 = 0; i1 < selected.tiles.length; i1++) {
            if (selected.tiles[i1] == i) {
              selected.tiles.splice(i1, 1);
              selected.objTiles.splice(i1, 1);
              }
            }
          }
          else if (doNotMoveTile.checked && doNotChange.includes(i)) {
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
            if (doNotChange[i1] == i) {
              doNotChange.splice(i1, 1);
              }
            }
          }
        }
    });
  }
  if (first && modeSelection.value != "schieben" && !state.restorePuzzle && tutorial.state == "") alert("Here you can now click on the pieces you don't want to have in the puzzle! You can hold down and swipe to select multiple!");
    layout(true, true, undefined, true);
    state.removeTile = true;
  }
  // lists coordinates of all entered tiles
  function listCoordinates(tiles) {
    var list = [];
    for (const tile of tiles) {
      list.push(positions.wrong[tile].edit.x + ' - ' + positions.wrong[tile].edit.y);
    }
    return list;
  }
  // PC moving the tiles in schieben mode
  function verschiebenPC() {
    var missingArray = [];
    var workingNumbers = [];
    var maleZurrück = {number: 0, normalSlide: 0};
    for (var i = 0; i < positions.wrong.length; i++) {
      if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i);
    }
    var counter = 0;
    for (var i = 0; (i < /*positions.wrong.length + */JSON.parse(anzahlVerschieben.value) || (richtigeCheck.checked && richtige > anzahlRichtige.value)) && (!zurrückVermeiden.checked || counter < 100000 || counter < anzahlVerschieben.value); i++) {
      var side = workingNumbers[Math.round(Math.random()*(workingNumbers.length - 1))];
      if (!workingNumbers.length) break;
      missing.forEach((pMissing, i1) => {
      try {
      if (!listCoordinates(doNotChange).includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y) && (((zurrückVermeiden.checked && ((missingArray.length < 1 || workingNumbers.length == 0/*positions.wrong[side].edit.x != missingBefore.data.edit.x && positions.wrong[side].edit.y != missingBefore.data.edit.y*/) || ((maleZurrück.number < anzahlVerboten.value && !((maleZurrück.normalSlide/5 + "").includes("."))) || !(missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y)/*missingBefore.data.edit.x != missing.data.edit.x && missingBefore.data.edit.y != missing.data.edit.y*/)))) || !zurrückVermeiden.checked) && ((pMissing == (positions.wrong[side].edit.x + lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y) /*right*/ || (pMissing ==
      (positions.wrong[side].edit.x - lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y)/*left*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y + lengthPerTeil.edit.y))/*down*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y - lengthPerTeil.edit.y))/*up*/))) {
      if (zurrückVermeiden.checked && (missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y))) {
        maleZurrück.number++;
      }
      else maleZurrück.normalSlide++;
      missingArray.push(pMissing);
      //console.log(missingArray);
      // movement.positions.unshift(JSON.parse(JSON.stringify(positions)));
      var ablage = JSON.parse(JSON.stringify(positions.wrong[side]));
      movement.move.unshift({x: (pMissing.split(' - ')[0] - ablage.edit.x), y: (pMissing.split(' - ')[1] - ablage.edit.y), tile: side});
      // movement.missing.unshift(JSON.parse(JSON.stringify(missingArray)));
      positions.wrong[side].edit = JSON.parse(JSON.stringify({x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0}));//.splice(side, 1);
      textur.width = textur.width;
      layout(true);
      // for (var i1 = 0; difficultSchieben.checked && i1 < movement.positions.length; i1++) {
        //   if (angular.equals(positions, movement.positions[i1])/* && angular.equals(missing, movement.missing[i1])*/) {
          //     positions = JSON.parse(JSON.stringify(movement.positions[1]));
          //     missing = JSON.parse(JSON.stringify(movement.missing[1]));
          //     movement.positions.splice(0, 1);
          //     movement.missing.splice(0, 1);
          //     maleZurrück.number++;
          //     i1 = movement.positions.length;
          //     i--;
          //     for (var i2 = 0; i2 < workingNumbers.length; i2++) {
            //       if (workingNumbers[i2] == side) workingNumbers.splice(i2, 1);
            //     }
            //   }
            // }
            // if (i1 != movement.positions.length + 1) {
      missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
      workingNumbers = [];
      for (var i1 = 0; i1 < positions.wrong.length; i1++) {
        if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i1);
      }
      // }
    }
      else {
        i--;
        for (var i1 = 0; i1 < workingNumbers.length; i1++) {
          if (workingNumbers[i1] == side) workingNumbers.splice(i1, 1);
        }
      }
    } catch (e) {
      //console.log("ein Error bei der if Abfrage!!! + (" + e + ")");
      i = positions.wrong.length;
    }
  });
    counter++;
    }
    if (layout(undefined, true, true) != undefined) verschiebenPC();
  }
  var movement = {move: [], startPosition: []};
  var mausx;
  var mausy;
  var stats = {turns: 0, highestRight: {turns: 0, right: 0}, rotated: 0, unclipped: 0, wrongClipped: 0, viewOriginal: {times: 0}, minimumRotations: 0};
  document.onmousemove = readMouseMove
  var originalMausX;
  // section 5: most user inputs
  var pcScrolls = false;
  window.addEventListener('scroll',()=>{
    if (pcScrolls) pcScrolls = false;
    else {
      selected.position = {x: selected.position.x + (state.scrollX - scrollX), y: selected.position.y + (state.scrollY - scrollY), manualScrolling: true};
      if (["manuallyScrollingTutorial", "scrollMobileScrollingTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    } 
    if (scrollY < texturTop - (showSettings.getBoundingClientRect().bottom + scrollY) && settings.style.display == "block") selectBackToBarB.style.display = 'none';
    else if (['inline', ''].includes(tileSelectionCanvas.style.display) && shuffleStyle.value == "listTiles") selectBackToBarB.style.display = 'inline';
    adaptMobileControlsPosition();
    if (keepScrolling.checked) folgenMouseMove();
    state.scrollX = scrollX;
    state.scrollY = scrollY;
  });
  window.visualViewport.addEventListener("resize", resized);
  var scale = 1;
  function resized (event) {
    if (scale != visualViewport.scale) {
      setTimeout(() => {
        state.shift = false;
        state.shiftBySwipe = false;
      }, 500);
      if ((scale < visualViewport.scale && tutorial.state == "zoomInTutorial") || (scale > visualViewport.scale && tutorial.state == "zoomOutTutorial")) goTutorialSteps(1);
      scale = visualViewport.scale;
      if (state.rightScroll < 0 && (positions.wrong.reduce((acc, val) => val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 < acc ? val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 : acc, textur.width)) > visualViewport.pageLeft) {
      var distance = (positions.wrong.reduce((acc, val) => val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 < acc ? val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 : acc, textur.width)) - visualViewport.pageLeft;
      state.rightScroll += distance;
      if (mirrorInput.checked) canvas.translate(distance, 0);
      else canvas.translate(-distance, 0);
    }
    if (state.rightScroll > 0 && (visualViewport.pageLeft + visualViewport.width - texturLeft) > positions.wrong.reduce((acc, val) => val.edit.x + lengthPerTeil.edit.x - state.rightScroll > acc ? val.edit.x + lengthPerTeil.edit.x - state.rightScroll : acc, 0)) {
      var distance = (visualViewport.pageLeft + visualViewport.width - texturLeft) - positions.wrong.reduce((acc, val) => val.edit.x + lengthPerTeil.edit.x - state.rightScroll > acc ? val.edit.x + lengthPerTeil.edit.x - state.rightScroll : acc, 0)
      state.rightScroll -= distance;
      if (mirrorInput.checked) canvas.translate(-distance, 0);
      else canvas.translate(distance, 0);
    }
    if (state.upScroll < 0 && (positions.wrong.reduce((acc, val) => val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 < acc ? val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 : acc, textur.height)) > visualViewport.pageTop) {
      var distance = (positions.wrong.reduce((acc, val) => val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 < acc ? val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 : acc, textur.height)) - visualViewport.pageTop;
      state.upScroll += distance;
      canvas.translate(0, -distance);
    }
    if (state.upScroll > 0 && (visualViewport.pageTop + visualViewport.height - texturTop) > positions.wrong.reduce((acc, val) => val.edit.y + lengthPerTeil.edit.y - state.upScroll > acc ? val.edit.y + lengthPerTeil.edit.y - state.upScroll : acc, 0)) {
      var distance = (visualViewport.pageTop + visualViewport.height - texturTop) - positions.wrong.reduce((acc, val) => val.edit.y + lengthPerTeil.edit.y - state.upScroll > acc ? val.edit.y + lengthPerTeil.edit.y - state.upScroll : acc, 0)
      state.upScroll -= distance;
      canvas.translate(0, distance);
    }
    layout(true, true);
   }
  }
  function adaptTitlesPosition() {
    var vis = {rotateLeft: rotateLeftTitle.style.display, rotateRight: rotateRightTitle.style.display, selectMultiple: selectMultipleTitle.style.display, swipe: swipeTitle.style.display};
    rotateLeftTitle.style.display = "inline";
    rotateRightTitle.style.display = "inline";
    selectMultipleTitle.style.display = "inline";
    rotateLeftTitle.style.top = rotateLeftSymbol.getBoundingClientRect().bottom + scrollY + 20;
    rotateRightTitle.style.top = rotateRightSymbol.getBoundingClientRect().bottom + scrollY + 20;
    selectMultipleTitle.style.top = selectMultipleSymbol.getBoundingClientRect().bottom + scrollY + 20;
    rotateLeftTitle.style.left = rotateLeftSymbol.getBoundingClientRect().left + rotateLeftSymbol.getBoundingClientRect().width/2 - rotateLeftTitle.getBoundingClientRect().width/2;
    rotateRightTitle.style.left = rotateRightSymbol.getBoundingClientRect().left + rotateRightSymbol.getBoundingClientRect().width/2 - rotateRightTitle.getBoundingClientRect().width/2;
    selectMultipleTitle.style.left = selectMultipleSymbol.getBoundingClientRect().left + selectMultipleSymbol.getBoundingClientRect().width/2 - selectMultipleTitle.getBoundingClientRect().width/2;
    swipeTitle.style.display = "inline";
    swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + scrollY + 20;
    swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
    rotateLeftTitle.style.display = vis.rotateLeft;
    rotateRightTitle.style.display = vis.rotateRight;
    selectMultipleTitle.style.display = vis.selectMultiple;
    swipeTitle.style.display = vis.swipe;
  }
  function adaptMobileControlsPosition() {
    mobileControls.style.top = (visualViewport.offsetTop/* - 7*/ + 2) + 'px';
    mobileControls.style.left = (visualViewport.offsetLeft + 300/visualViewport.scale) + 'px';
    mobileControls.style.fontSize =  (5/visualViewport.scale) + 'vh';
    for (const elm of document.getElementsByClassName('mobileControlsElm')) {
      elm.style.width = 44/(visualViewport.scale); 
      elm.style.height = 44/(visualViewport.scale); 
    }
    closeMobileControls.style.fontSize = 33/(visualViewport.scale);
    closeMobileControls.style.width = 33/(visualViewport.scale);
    var pos = {x: visualViewport.offsetLeft, y: visualViewport.offsetTop};
    setTimeout(() => {
      if (pos.x != visualViewport.offsetLeft || pos.y != visualViewport.offsetTop) adaptMobileControlsPosition();
      else {
        for (const elm of document.getElementsByClassName('speech')) {
          elm.style.fontSize = 25/visualViewport.scale + 'px';
          elm.style.maxWidth = visualViewport.width/4 + 'px';
          elm.style.padding = 20/visualViewport.scale + 'px';
        }
        adaptTitlesPosition();
      }
    }, 40);
    document.getElementById('tutorial').style.maxHeight = window.innerHeight - mobileControls.getBoundingClientRect().bottom - 10;
    if (modeSelection.value != "traditional") document.getElementById('tutorial').style.maxHeight = window.innerHeight;
  }
  function changeControlMode(device) {
    if (gerät == device) return;
    if (device == "PC") mouseSupported = true;
    gerät = device;
    mobileControls.style.display = "none";
    rotateControls.style.display = "none";
    automaticTileSelectionReset.disabled = false;
    if (localStorage.getItem("automaticTileSelectionResetPuzzleCreator")) automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
    selectBackToBarB.style.fontSize = '';
    if (gerät == "Handy") {
      mobileControls.style.display = "inline";
      selectBackToBarB.style.fontSize = '5vh';
      // zoom out: 
      // var newElm = document.createElement('meta');
      // newElm.name = "viewport";
      // newElm.id = "zoomLevelControler";
      // newElm.content = "initial-scale=1";
      // document.getElementsByTagName('head')[0].appendChild(newElm);
      // TODO: add "x" to close them
      rotateControls.style.display = "inline";
      // adaptMobileControlsPosition();
      automaticTileSelectionReset.checked = true;
      automaticTileSelectionReset.disabled = true;
      if (localStorage.getItem('tileListVisHybridDevice')) mobileControls.style.display = localStorage.getItem('tileListVisHybridDevice');
      if (mobileControls.style.display == "none") showMobileControls.style.display = 'inline';
      adaptTitlesPosition();
    }
    else showMobileControls.style.display = 'none';
    document.querySelector("#closeMobileControls").disabled = !mouseSupported
  }
  document.addEventListener('pointerdown', (event) => {
    if (event.pointerType == "mouse") changeControlMode("PC");
    else changeControlMode("Handy");
  });
  // #importantUserInputs
  function readMouseMove(e) {
    mausx = e.clientX + scrollX - texturLeft + state.rightScroll;
    mausy = e.clientY + scrollY - texturTop + state.upScroll;
    if (selected.position.manualScrolling) {
      selected.position = {x: mausx, y: mausy};
      selected.position.manualScrolling = false;
    }
    if (gerät != "Handy") originalMausX = e.clientX;
    if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width) - mausx; // - scrollX;
    // /*96*/32// - 43;
    // if (scrollY > 32) mausy += 32;
    if (gerät == "PC") folgenMouseMove("mousemove");
  }
  window.scroll(0, 0);
  var texturTop = textur.getBoundingClientRect().top + scrollY;
  var state = {mouse: "up", shift: false, newTileSelected: false, buttons: {}, coord: {x: 0, y: 0}, backToBar: false, rightScroll: 0, upScroll: 0, userSource: 'Picture', scrollX: 0, scrollY: 0};
  var texturLeft = textur.getBoundingClientRect().left;
  // #importantUserInputs
  // if (gerät == "Handy") {
    textur.addEventListener('touchmove', touch, {passive:false});
    textur.addEventListener('touchstart', touch);
    textur.addEventListener('touchend', touch);
    tileSelectionCanvas.addEventListener('touchmove', touch, {passive:false});
    tileSelectionCanvas.addEventListener('touchstart', touch);
    tileSelectionCanvas.addEventListener('touchend', touch);
    function touch(ev) {
      if (!scrollable.checked && ev.type == "touchmove" && settings.style.display != "inline" && (aufgebenId.style.display == "inline" || state.removeTile) && (!scrollOnBlanc.checked || selected.tiles.length)) {
        if (event.cancelable) ev.preventDefault();
        else console.log("event not cancable!");
      }
      if ((aufgebenId.style.display == "inline" || removeTilesFinishedB.style.display == "inline") && (!ev.touches[0] || (ev.touches[0] && !collides({x: ev.touches[0]["pageX"] - scrollX, y: ev.touches[0]["pageY"] - scrollY, width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean))) {
    if (ev.touches[1] && aufgebenId.style.display == "inline") {
      state.shift = true;
      state.shiftBySwipe = true;
      selected.tiles = [];
      mouseDown();
    }
    if (ev.type == "touchend") {
      console.log('touchEnd');
    }
    // #potentialErrorCause
    if ((state.removeTile || ((swipeSteuerung.checked || modeSelection.value != "exchange"))) && ev.touches[0]) {
      var pTexturLeft = textur.getBoundingClientRect().left + scrollX;
      if (pTexturLeft < 0) pTexturLeft = 0;
      mausx = ev.touches[0]["pageX"] - pTexturLeft + state.rightScroll;
      mausy = ev.touches[0]["pageY"] - texturTop + state.upScroll;// - 32;
      if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width + scrollX) - mausx;
      // TODO: if statement needed?
      if (tileSelectionBar.collidesMouse() || gerät == "Handy") originalMausX = ev.touches[0]["pageX"];
    }
    if (!scrollable.checked) {
    if (ev.type == "touchstart" && !ev.touches[2] && !collides({x: mausx, y: mausy + texturTop, width: 1, height: 1}, selectBackToBarB.getBoundingClientRect()).boolean) {
      mouseDown(null, ev.touches[0] == undefined && collides({x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"], width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean);
    }
    if (ev.type == "touchend") {
      // #potentialErrorCause
      // setTimeout(function () {
        mouseUp();
        layout(true, true);
      // }, 100);
    }
    if (ev.type == "touchmove" && (modeSelection.value == "traditional" || state.removeTile || tutorial.state != "")) {
      folgenMouseMove("touchmove");
    }
  }
    }
    adaptMobileControlsPosition();
    // rotaiton gesture
    // if (ev.type == "touchstart") rotationGesture = [{x: 0, y: 0}, {x: 0, y: 0}];
    // if (ev.type == "touchmove" && ev.touches[1] && !ev.touches[2]) {
    //   if (rotationGesture[0].x) {
    //     var positions = {start: [rotationGesture[0], rotationGesture[1]], now: [{x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"]}, {x: ev.touches[1]["pageX"], y: ev.touches[1]["pageY"]}]};
    //     if (rotationGesture[0].y > rotationGesture[1].y) {
    //       positions = {start: [rotationGesture[1], rotationGesture[0]], now: [{x: ev.touches[1]["pageX"], y: ev.touches[1]["pageY"]}, {x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"]}]};
    //     }
    //     if (positions.now[0]["pageX"] - position.start[0].x < -30 && positions.now[0]["pageY"] - position.start[0].y > 30 && /*TODO: weiter checken*/ positions.now[1]["pageX"] - position.start[1].x > 30 && positions.now[1]["pageY"] - position.start[1].y < -30) {
    //       console.log("rotate left");
    //     }
    //     if (positions.now[0]["pageX"] - position.start[0].x > 30 && positions.now[0]["pageY"] - position.start[0].y > 30 && positions.now[1]["pageX"] - position.start[1].x < -30 && positions.now[1]["pageY"] - position.start[1].y < -30) {
    //       console.log("rotate right");
    //     }
    //   }
    //   else rotationGesture = [{x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"]}, {x: ev.touches[1]["pageX"], y: ev.touches[1]["pageY"]}];
    // }
    // try {
    //   console.log(ev.touches[0]["pageX"] + " - " + ev.touches[0]["pageY"]);
    //   // console.log(ev.touches[1]["pageX"] + " - " + ev.touches[1]["pageY"]);
    // } catch (e) {}
  }
  // }
  var rotationGesture = [{x: 0, y: 0}, {x: 0, y: 0}];
  function tileSelected() {
    for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
      var i = positions.layoutOrder[i1];
      var coord = positions.wrong[i].edit;
      var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
      if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
      if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
        return true;
      }
    }
  }
  var tutorial = {state: "", index: 0};
  function mouseDown(elmCalled, touchStart) {
    state.tileChanged = false;
    if (gerät == "PC" || !elmCalled) {
      selected.tile = checkSelected();
    if (swipeSteuerung.checked && modeSelection.value == "exchange" && selected.tile && !selected.boolean.click && !scrollable.checked) {
      selected.coord = {x: selected.tile.x, y: selected.tile.y};
        selected.tiles = [getTileIByCoord(selected.tile)];
        layout();
      selected.boolean.swipe = true;
    }
    delete state.rorated;
    tileSelectionBar.swipePosition = originalMausX;
    if (modeSelection.value == "traditional") {
    if (state.mouse == "up" && !automaticTileSelectionReset.checked && state.removeTile) state.mouse = "downNow";
    if (state.mouse != "downNow") state.mouse = "down";
    if (((selected.tiles.length && !state.shift) || state.removeTile) && !automaticTileSelectionReset.checked && state.mouse != "downNow") {
      trackActivity.mouseDown = {position: {x: mausx, y: mausy}};
      mouseUp(true);
      if ((tutorial.state == "clickUnselectMoveTutorial" && !state.removeTile && selected.tiles.length) || ["unselectUnclippStandardTutorial", "unselecTileAfterTileBarTilePlacementTutorial"].includes(tutorial.state)) {
        goTutorialSteps(1);
        if (tutorial.state != "SecondPlaceTileTutorial" && !state.helpTutorial) automaticTileSelectionReset.checked = true;
      }
      if (["getClippingOptionConnectTileTutorial", "manuallyScrollingTutorial", "automaticScrollingTutorial", "moveMouseMoveTutorial"].includes(tutorial.state)) {
        goTutorialSteps(-1);
      }
      if (tutorial.state == "rotateTileTutorial") goTutorialSteps(-2);
      if (!state.removeTile) selected.tiles = [];
      else state.mouse = "up";
      state.shiftBefore = false;
    }
    else {
      if (state.mouse = "downNow") state.mouse = "down";
      if (gerät == "Handy" && selectMultiple.checked) state.shift = true;
      state.coord = checkSelected(true);
      if (modeSelection.value == "traditional") {
        // tile on field
        if (tileSelectionBar.selectedTile?.tileI != undefined && ((tileSelectionBar.selectedTile.byUser && autoSelectTileBar.checked) || !tileSelected()) && !tileSelectionBar.collidesMouse() && state.backToBar === false) {
          if (["placeTileOnFiledTutorial", "SecondPlaceTileTutorial"].includes(tutorial.state)) goTutorialSteps(1);
          var i = tileSelectionBar.selectedTile;
          selected.tiles.push(i.tileI);
          positions.layoutOrder = positions.layoutOrder.filter(x => x != i.tileI);
          positions.layoutOrder.push(i.tileI);
          tileSelectionBar.tiles.splice(i.i, 1);
          // tileSelectionBar.tiles = tileSelectionBar.tiles.filter(x => x != undefined);
          if (!autoSelectTileBar.checked || !tileSelectionBar.tiles.length) tileSelectionBar.selectedTile = undefined;
            else {
              setTimeout(function () {
                tileSelectionBar.selectedTile.byUser = false;
                if (tileSelectionBar.selectedTile.i >= tileSelectionBar.tiles.length) tileSelectionBar.selectedTile.i--;
                tileSelectionBar.selectedTile.tileI = tileSelectionBar.tiles[tileSelectionBar.selectedTile.i];
                layout();
              }, 10);
            }
          positions.wrong[i.tileI].edit = {x: mausx, y: mausy, degree: 0};
          state.placeTile = true;
          scrollTileSelection(0);
        }
        // selected.tiles = [];
        selected.position = {x: mausx, y: mausy};
        for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
          var i = positions.layoutOrder[i1];
          var coord = positions.wrong[i].edit;
          var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
          if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
          if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height) {
            state.oldTileSelected = true;
          }
          if (tutorial.state == "twoFingersDownUnclippTutorial" && state.shiftBySwipe && getConnectedTiles(selected.tiles[0], true).length >= 2) goTutorialSteps(1);
          if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && (!selected.tiles.includes(i) || (gerät == "Handy" && (rotatesLeft.checked || rotatesRight.checked))) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
            if (!state.placeTile) {
              if (!selected.tiles.includes(i)) selected.tiles.push(i);
              positions.layoutOrder = positions.layoutOrder.filter(x => x != i);
              positions.layoutOrder.push(i);
              if (["tileClickMoveTutorial", "holdMouseMoveTutorial", "moveMouseMoveTutorialAlternative", "selectTileConnectTileTutorial", "selectTileScrollingTutorial", "selectTileAutomaticScrollingTutorial", "selectTileMobileTurorial", "selectTileConnectTileMobileTutorial", "selectTileMobileTwoFingersUnclippTutorial"].includes(tutorial.state) || (["selectTileMobileShiftMultipleUnclippTutorial"].includes(tutorial.state) && selected.tiles.length >= 2 && getConnectedTiles(selected.tiles[0], true).length >= 3) || (["selectTileStandardUnclippTutorial", "selectTileAlternativeUnclippTutorial", "selectTileMobileShiftUnclippTutorial"].includes(tutorial.state) && getConnectedTiles(selected.tiles[0], true).length >= 2)) {
                goTutorialSteps(1);
              }
              if (!elmCalled && !touchStart && rotateTiles.checked) {
                if (rotatesRight.checked) {
                  rotateSelected(90);
                  if (tutorial.state == "rotateRightMobileTutorial") goTutorialSteps(1);
                }
                if (rotatesLeft.checked) {
                  rotateSelected(-90);
                  if (tutorial.state == "rotateLeftMobileTutorial") goTutorialSteps(1);
                }
              }
            }
            if (state.backToBar !== false) {
              if (["backToTileBarPlusBTutorial", "selectBackToBarTileZurückInLeisteTutorial"].includes(tutorial.state)) goTutorialSteps(1);
              // tileSelectionBar.tiles.push(i);
              tileSelectionBar.tiles.splice(state.backToBar, 0, i);
              if (autoSelectTileBar.checked && tileSelectionBar.tiles.length == 1) {
                state.setSelected = {i: state.backToBar, tileI: i};
                setTimeout(function() {
                  tileSelectionBar.selectedTile = state.setSelected;
                }, 10);
              }
              document.getElementsByClassName('backToTileB')[state.backToBar].style.backgroundColor = '';
              selectBackToBarB.style.backgroundColor = '';
              state.backToBar = false;
              unclipp(i);
              mouseDown();
            }
            layout(true);
            state.newTileSelected = true;
          }
        }
        if (!state.newTileSelected && !state.oldTileSelected && !automaticTileSelectionReset.checked && !state.removeTile) selected.tiles = [];
        state.placeTile = false;
        tileSelectionBar.tiles.forEach((tileI, i) => {
          var tile = positions.wrong[tileI];
          if (mausx > (5 + lengthPerTeil.sizeAdapted.x)*i + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && mausx < (5 + lengthPerTeil.sizeAdapted.x)*(i + 1) + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && tileSelectionBar.collidesMouse()) {
            tileSelectionBar.selectedTile = {i: i, tileI: tileI, byUser: true};
            if (rotatesLeft.checked) rotateTile(tileI, -90);
            if (rotatesRight.checked) rotateTile(tileI, 90);
            if (["MouseDownScrollTileBarTutorial", "selectTileBarTileTutorial", "selectTileTileBarBackToBarTutorial"].includes(tutorial.state)) goTutorialSteps(1);
            layout();
          }
        });
        folgenMouseMove("mouseDown");
      }
    }
  }
  else {
    state.coord = checkSelected(true);
    state.mouse = "down";
    if (state.removeTile) folgenMouseMove("mouseDown");
    if (tutorial.state == "mouseMoveExchangeAlternativeTutorial") goTutorialSteps(-1);
    if (["mouseDownSelectFirstExchangeAlternativeTutorial", "mouseDownUnselectAlternativeTutorial"].includes(tutorial.state)) {
      goTutorialSteps(1);
    }
  }
  }
  if (selected.tiles.length > 0 && !automaticTileSelectionReset.checked) {
    trackActivity.mouseDown = {position: {x: mausx, y: mausy}};
  }
}
var trackActivity = {mouseDown: {position: {x: 0, y: 0}}, unclipp: {counter: 0, tiles: []}}
  // #importantUserInput
  function folgenMouseMove(calledBy) {
    if (modeSelection.value == "exchange" && JSON.stringify(checkSelected()) != JSON.stringify(selected.coord)) {
      state.tileChanged = true;
      if (["mouseMoveExchangeAlternativeTutorial", "moveMouseOutUnselectAlternativeTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
    if (state.tileChanged && JSON.stringify(checkSelected()) == JSON.stringify(selected.coord) && tutorial.state == "moveMouseInUnselectAlternativeTutorial") goTutorialSteps(1);
    if ((["moveMouseMoveTutorialAlternative", "moveMouseMoveTutorial", "moveTileMobileTutorial", "moveTileShiftUnclippTutorial", "moveTileShiftMultipleUnclippTutorial", "moveTileTwoFingersUnclippTutorial"].includes(tutorial.state) || (tileSelectionBar.collidesMouse() && tutorial.state == "moveMouseScrollTileSelectionBarTutorial")) && (calledBy == "mousemove" || calledBy == "touchmove") ) {
      if ((tutorial.state == "moveMouseMoveTutorial" && rotateTileTutorial.checked) || (tutorial.state == "moveMouseMoveTutorialAlternative" && rotateTileTutorialAlternative.checked)) goTutorialSteps(1);
      goTutorialSteps(1);
    }
    if (state.mouse == "down" && tileSelectionBar.collidesMouse() && tutorial.state == "MouseDownScrollTileBarTutorial" && calledBy != "mousedown") goTutorialSteps(1);
    if (tileSelectionBar.collidesMouse()) mausx = originalMausX;
    selected.clip = [];
    if (state.mouse == "down" && state.removeTile) canvasClicked(calledBy);
    positionBackToTileBarButtons(true);
    if (state.mouse == "down" && !state.removeTile && modeSelection.value == "traditional") {
      if (calledBy != "mouseDown") selectMultiple.checked = false;
      // select clipped
      for (var tile of selected.tiles) {
        var objTile = positions.wrong[tile];
        if (gerät == "PC") {
        if (mirrorInput.checked && originalMausX - lengthPerTeil.edit.x/2 < 0) {
          textur.width += 15;
          expandSide('right', true); 
        }
        if (!mirrorInput.checked && objTile.edit.x + lengthPerTeil.edit.x > textur.width) expandSide('right'); // textur.width += lengthPerTeil.edit.x;
        if (objTile.edit.y + lengthPerTeil.edit.y > textur.height) expandSide('bottom'); // textur.height += lengthPerTeil.edit.y;
      }
        for (var clipp of clipped) {
          var newTile = clipp.split(' - ').filter(x => !selected.tiles.includes(JSON.parse(x)))[0];
          if (!state.shift && !state.shiftBefore && clipp.split(' - ').includes(tile + "") && newTile) {
            selected.tiles.push(JSON.parse(newTile));
            positions.layoutOrder = positions.layoutOrder.filter(x => x != JSON.parse(newTile));
            positions.layoutOrder.push(JSON.parse(newTile));
          }
        }
        // unclipp
        if (((state.shift && automaticTileSelectionReset.checked) || (!automaticTileSelectionReset.checked && !state.shift && state.shiftBefore)) && calledBy != "mouseDown") {
          unclipp(tile);
          state.shiftBySwipe = false;
        }
        // positions.wrong.forEach((position, i) => {
        //   if (((objTile.original?.left?.x == position.original?.x && objTile.original?.left?.x != undefined && objTile.original?.left?.y == position.original?.y) || (objTile.original?.top?.x == position.original?.x && objTile.original?.top?.x != undefined && objTile.original?.top?.y == position.original?.y) || (objTile.original?.wrong?.x == position.original?.x && objTile.original?.wrong?.x != undefined && objTile.original?.wrong?.y == position.original?.y) || (objTile.original?.bottom?.x == position.original?.x && objTile.original?.bottom?.x != undefined && objTile.original?.bottom?.y == position.original?.y)) && !selected.tiles.includes(i)) {
        //     selected.tiles.push(i);
        //   }
        // });
        if ((automaticTileSelectionReset.checked || !state.shift)) {
          positions.wrong[tile].edit.x += mausx - selected.position.x;
          positions.wrong[tile].edit.y += mausy - selected.position.y;
          // check clicking
          checkPossibleClipping(tile);
       }
      }
      if ((automaticTileSelectionReset.checked || !state.shift)) {
        deleteFurtherClipOptions();
        playClippingSound();
        selected.position = {x: mausx, y: mausy, manualScrolling: selected.position.manualScrolling};
        layout(false, true);
      }
    }
  }
  // deletes clip options that apply to the same tile but are further away
  function deleteFurtherClipOptions() {
    nearestTile = {};
    selected.clip.forEach((clip, i1) => {
      if (!getConnectedTiles(clip.sI, true).includes(nearestTile[clip.i]?.clip.sI)) {
        if (!nearestTile[clip.i] || clip.distance < nearestTile[clip.i].clip.distance) {
          if (nearestTile[clip.i]) selected.clip.splice(nearestTile[clip.i].i, 1);
          nearestTile[clip.i] = {clip: clip, i: i1};
        }
        else if (clip.distance >= nearestTile[clip.i].clip.distance) {
          selected.clip.splice(i1, 1);
        }
      }
      // sI
      if (!getConnectedTiles(clip.i, true).includes(nearestTile[clip.sI]?.clip.i)) {
      if (!nearestTile[clip.sI] || (clip.distance < nearestTile[clip.sI].clip.distance)) {
        if (nearestTile[clip.sI]) selected.clip.splice(nearestTile[clip.sI].i, 1);
        nearestTile[clip.sI] = {clip: clip, i: i1};
      }
      else if (clip.distance > nearestTile[clip.sI].clip.distance) {
        selected.clip.splice(i1, 1);
      }
    }
    });
    for (let i1 = 0; i1 < selected.clip.length; i1++) {
      if (selected.clip[i1 + 1] && !getConnectedTiles(selected.clip[i1].i, true).includes(selected.clip[i1 + 1].i)) {
        if (selected.clip[i1].distance <= selected.clip[i1 + 1].distance) selected.clip.splice(i1 + 1, 1);
        else selected.clip.splice(i1, 1);
      }
    }
  }
  var nearestTile = {};
  // #importantUserImput
  function mouseUp(byUnselection) {
    if (selected.tiles.length > 0 && !automaticTileSelectionReset.checked && Math.abs(trackActivity.mouseDown.position.x - mausx) > 7 && Math.abs(trackActivity.mouseDown.position.y - mausy) > 7 && confirm('Your game controls indicate that you want to use the drag and drop controls. Do you want to change the control mode? \n You can change this at any time in the settings. You can also click on "Help (Show controls)" or press f1 to understand the currently selected control mode.')) {
      automaticTileSelectionReset.checked = true;
    }
    trackActivity.mouseDown = {position: {x: mausx, y: mausy}};
    console.log(selected.tiles);
    if (selected.tiles.length > 1 && (JSON.stringify(selected.tiles) == JSON.stringify(trackActivity.unclipp.tiles) || !trackActivity.unclipp.tiles.length) && !byUnselection) {
      trackActivity.unclipp.counter++;
      trackActivity.unclipp.tiles = JSON.parse(JSON.stringify(selected.tiles));
      if (trackActivity.unclipp.counter > 2) {
        if (mobileControls.style.display == "inline") showTitle("selectMultipleSymbol", "none");
        else {
          unclippPCHelp.style.display = "inline";
          unclippPCHelp.style.opacity = 1;
          setTimeout(() => {
            unclippPCHelp.style.opacity = 0;
            setTimeout(() => {
              unclippPCHelp.style.display = "none";
            }, 1000);
          }, 5555);
        }
        trackActivity.unclipp.counter = 0;
        trackActivity.unclipp.tiles = [];
      }
    }
    if (JSON.stringify(selected.tiles) != JSON.stringify(trackActivity.unclipp.tiles) && selected.tiles.length > 0) {
      trackActivity.unclipp.counter = 0;
      trackActivity.unclipp.tiles = [];
    }
    if (["moveMouseMoveTutorialAlternative", "moveMouseScrollTileSelectionBarTutorial", "moveTileMobileTutorial", "getClippingOptionConnectTileMobileTutorial", "moveTileShiftUnclippTutorial", "moveTileTwoFingersUnclippTutorial"].includes(tutorial.state)) {
      if (tutorial.state == "moveTileTwoFingersUnclippTutorial") selected.tiles = [];
      goTutorialSteps(-1);
    }
    if (tutorial.state == "rotateTileTutorialAlternative") goTutorialSteps(-2);
    if (tutorial.state == "releaseMoveTutorial") {
      goTutorialSteps(1);
    }
    if (["getClippingOptionConnectTileTutorial", "manuallyScrollingTutorial", "automaticScrollingTutorial", "moveMouseOutUnselectAlternativeTutorial"].includes(tutorial.state) && (automaticTileSelectionReset.checked || modeSelection.value != "traditional")) {
      goTutorialSteps(-1);
    }
    setTimeout(() => {
      if (tutorial.state == "selectSecondExchangeNormalTutorial" && !selected.boolean.click) goTutorialSteps(-1);
    }, 500);
    if (tutorial.state == "unselectAlternativeUnclippTutorial" && !state.helpTutorial) {
      automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
    }
    if (["mouseMoveExchangeAlternativeTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
    if (["moveMouseInUnselectAlternativeTutorial"].includes(tutorial.state)) goTutorialSteps(-2);
    if (["unselectAlternativeUnclippTutorial", "unselectTileScrollingTutorial", "stopScrollingAutomaticScrollingTutorial", "stopScrollingTileBarTutorial", "releaseTileMobileTutorial", "releaseFingerMobileShiftTutorial", "releaseFingerMobileMultiShiftTutorial", "releaseFingerMobileTwoFingersTutorial", "mouseUpExchangeAlternativeTutorial"].includes(tutorial.state) || (automaticTileSelectionReset.checked && tutorial.state == "unselecTileAfterTileBarTilePlacementTutorial") || (tutorial.state == "releaseTwoFingersUnclippTutorial" && state.shiftBySwipe)) {
      goTutorialSteps(1);
    }
    if (swipeSteuerung.checked && modeSelection.value == "exchange" && checkSelected()) {
      canvasClicked('mouseup');
    }
    if (automaticTileSelectionReset.checked || !selected.tiles.length || (state.removeTile && (automaticTileSelectionReset.checked)) || modeSelection.value != "traditional") {
      state.mouse = "up";
      if (tutorial.state == "releaseShiftAlternativeUnclippTutorial" && !state.helpTutorial) {
        unselectAlternativeUnclippTutorial.checked = true;
        automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
      }
    }
    if (gerät == "Handy" && !selectMultiple.checked && !state.shiftBySwipe) state.shift = false;
    if (automaticTileSelectionReset.checked) state.shiftBefore = false;
    if (modeSelection.value == "traditional" && (!state.rotated || gerät == "PC")) {
      state.newTileSelected = false;
      state.oldTileSelected = false;
      if (automaticTileSelectionReset.checked || byUnselection || gerät == "Handy") {
      var bClipped = false;
      for (var clip of selected.clip) {
        if (!tileSelectionBar.tiles.includes(clip.i)) {
        if ((JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) stats.wrongClipped++;
        var directionOpposite = {left: 'right', top: 'bottom', right: 'left', bottom: 'top'};
        positions.wrong[clip.i].original[clip.direction] = {x: positions.right[clip.sI].original.x, y: positions.right[clip.sI].original.y};
        positions.wrong[clip.sI].original[directionOpposite[clip.direction]] = {x: positions.right[clip.i].original.x, y: positions.right[clip.i].original.y};
        var differ = {x: (clip.selected.x - positions.wrong[clip.sI].edit.x), y: (clip.selected.y - positions.wrong[clip.sI].edit.y)};
        for (var tile of selected.tiles) {
          positions.wrong[tile].edit.x += differ.x;
          positions.wrong[tile].edit.y += differ.y;
        }
        clipped.push(clip.i + ' - ' + clip.sI);
        bClipped = true;
        for (var tile of selected.tiles) {
        // do more clipping if needed
        checkPossibleClipping(tile, true);
      }
      deleteFurtherClipOptions();
      }
    }
    if (selected.clip.length && bClipped) {
      new Audio('https://adi.nicolaiweitkemper.de/Sounds/helpTheTrain/weiche.mp3').play();
      console.log("clipping...");
      if ((["clipTileTutorial", "clipTileMobileTutorial"].includes(tutorial.state)) || (tutorial.state == "clippSecondTutorial" && getConnectedTiles(selected.tiles[0], true).length >= 4) || (tutorial.state == "clippSecondMobileTutorial" && getConnectedTiles(selected.tiles[0], true).length >= 5)) {
        if (!tutorial.state.includes('Mobile') && !state.helpTutorial) automaticTileSelectionReset.checked = false;
        goTutorialSteps(1);
      }
      stats.turns++;
      // selectMultiple.checked = false;
      state.shift = false;
      selected.tiles = [];
    }
  }
  selected.clip = [];
}
if (selected.tiles.length && !state.shift && !state.removeTile && automaticTileSelectionReset.checked && modeSelection.value == "traditional") selected.tiles = [];
delete state.rotated;
layout(false, true);
  if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
  if (tutorial.state == "unclippTileAlternativeUnclippTutorial" && state.mouse == "up") {
    goTutorialSteps(-1);
    selected.tiles = [];
  }
}
  function rotateTile(tile, direction) {
    if (mirrorInput.checked) direction *= -1;
    positions.wrong[tile].original.degree = getDegreeAfterRotation(positions.wrong[tile].original.degree, direction);
    stats.rotated++;
  }
  function getDegreeAfterRotation(degree, direction) {
    degree += direction;
    if (degree < 0) degree = 270;
    if (degree > 270) degree = 0;
    return degree;
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  document.onkeyup = function(event) {
    if (event.key == "shift" && state.shift) {
      state.shift = false;
      if (automaticTileSelectionReset.checked) selected.tiles = [];
      if (["selectTileStandardUnclippTutorial", "selectTileAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
      if (tutorial.state == "releaseShiftStandardUnclippTutorial") goTutorialSteps(1);
      if (tutorial.state == "unclippTileAlternativeUnclippTutorial") goTutorialSteps(-2);
      if (tutorial.state == "releaseShiftAlternativeUnclippTutorial") {
        goTutorialSteps(1);
        if (unselectAlternativeUnclippTutorial.checked) {
          goTutorialSteps(1);
        }
      }
    }
    if (event.key == "Escape") {
      selected.tiles = [];
    }
    // if (aufgebenId.style.display == "none") layout();
  }
  // end section 5
  // section 6: rotate tile(s)
    // #importantUserInputs
    document.onkeydown = function(event) {
      if (event.key == "F1") {
        if (tutorial.state == "") {
          if (!event.changeElement) {
            state.helpTutorial = true;
            startTutorial(true);
            showTutorialB.innerHTML = showTutorialB.innerHTML.replace('show', 'hide');
          }
          if (shuffleStyle.value != "listTiles") tileSelectionBarTutorial.style.display = "none";
          // traditional mode: standard/alternative visibility
          completePuzzleTutorialDiv.style.display = "none";
          moveStandardPC.style.display = "block";
          moveAlternativePC.style.display = "block";
          moveStyleStandardUnclipp.style.display = "block";
          moveStyleAlternativeUnclipp.style.display = "block";
          if (automaticTileSelectionReset.checked) {
            moveStandardPC.style.display = "none";
            moveStyleStandardUnclipp.style.display = "none";
            moveStyleAlternative.checked = true;
            unclippAlternative.checked = true;
          }
          else {
            moveAlternativePC.style.display = "none";
            moveStyleAlternativeUnclipp.style.display = "none";
            moveStyleStandard.checked = true;
            unclippStandard.checked = true;
          }
          // exchange mode: standard/alternative visibility
          moveStyleStandardExchangeDiv.style.display = "block";
          moveStyleAlternativeExchange.style.display = "block";
          standardUnselectExchangeTutorial.style.display = "block";
          alternativeUnselectExchangeTutorial.style.display = "block";
          if (swipeSteuerung.checked) {
            moveStyleStandardExchangeDiv.style.display = "none";
            standardUnselectExchangeTutorial.style.display = "none";
          }
          else {
            moveStyleAlternativeExchange.style.display = "none";
            alternativeUnselectExchangeTutorial.style.display = "none";
          }

          moveStyleSettingChosenDiv.style.display = "none";
          // if (tutorialSteps.length) tutorial.state = tutorialSteps[tutorial.index].id;
        }
       else {
        showTutorialB.innerHTML = showTutorialB.innerHTML.replace('show', 'hide');
         tutorial.state = "";
         document.getElementById('tutorial').style.display = "none";
        }
        return false;
      }
      if (event.key == "shift") {
        state.shift = true;
        state.shiftBefore = true;
        selected.tiles = [];
        if (["pressShiftStandardUnclippTutorial", "pressShiftAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(1);
      }
      var collidesTilesBar = tileSelectionBar.collidesMouse();
      if (rotateTiles.checked) {
        if (event.key == "ArrowRight") {
          if (collidesTilesBar && state.mouse == "up") {
            scrollTileSelection(1, "arrowKey");
          }
          else if (collidesTilesBar) rotateTile(tileSelectionBar.selectedTile.tileI, 90);
          else rotateSelected(90);
        }
        if (event.key == "ArrowLeft") {
          if (collidesTilesBar && state.mouse == "up") scrollTileSelection(-1, "arrowKey");
          else if (collidesTilesBar) rotateTile(tileSelectionBar.selectedTile.tileI, -90);
          else rotateSelected(-90);
        }
      }
      if (event.key?.includes("Arrow")) layout(true);
      if ((event.key == "ArrowRight" || event.key == "ArrowLeft") && modeSelection.value == "traditional" && ((selected.tiles.length && rotateTiles.checked) || collidesTilesBar)) return false;
  }
  function rotateSelected(direction) {
    if (tutorial.state == "moveMouseMoveTutorial") rotateTileTutorial.checked = true;
    if (tutorial.state == "moveMouseMoveTutorialAlternative") rotateTileTutorialAlternative.checked = true;
    if (["rotateTileTutorial", "rotateTileTutorialAlternative"].includes(tutorial.state)) goTutorialSteps(1);
    if (!state.removeTile) {
      if (selected.tiles.length == 1 && getConnectedTiles(selected.tiles[0], true).length > 1 && gerät == "PC") {
        rotateTile(selected.tiles[0], direction);
      }
      else {
        state.rotated = [];
        if (!state.shift) {
          rotateAround(selected.tiles[0], direction);
          if (lengthPerTeil.edit.x != lengthPerTeil.edit.y && getConnectedTiles(selected.tiles[0], true).length > 1) {
            state.rotated = [];
            rotateAround(selected.tiles[0], direction);
          }
        }
        else {
          for (const tile of selected.tiles) {
            rotateTile(tile, direction);
          }
        }
        // layout(true, true);
        folgenMouseMove();
      }
    }
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  // end section 6
  function storePuzzle() {
    getPuzzles();
    var puzzle = puzzles[puzzleName.value];
    if (!puzzle) puzzle = {};
    puzzle.settings = {};
    puzzle.tileAmount = {x: amountX.value, y: anzahlY.value};
    puzzle.positions = positions;
    puzzle.stats = stats;
    puzzle.mode = modeSelection.value;
    if (modeSelection.value == "schieben") {
      puzzle.movement = JSON.parse(JSON.stringify(movement));
      delete puzzle.movement.playerPosition;
      puzzle.missing = missing;
      puzzle.userMovement = userMovement;
      puzzle.movementPlayerPosition = playerMovementSlider.value;
    }
    if (modeSelection.value == "traditional") {
      puzzle.settings.rotateTiles = rotateTiles.checked;
      if (shuffleStyle.value == "listTiles") puzzle.tileBarTiles = tileSelectionBar.tiles;
    }
    puzzle.settings.mirrorInput = mirrorInput.checked;
    if (sourceIsFile.checked) {
      puzzle.fileName = fileName;
    }
    if (useURLCheck.checked) {
      puzzle.URL = sourceURL.value;
    }
    if (useLiveCam.checked) {
      puzzle.liveCam = cameraSelection.options[cameraSelection.value - 1].value;
    }
    puzzle.width = größeAnpassenX.value;
    puzzle.height = größeAnpassenY.value;
    puzzle.completionTime = stopClock.completionTime.time;
    puzzle.viewOriginalTime = stopClock.viewOriginal.time;
    puzzles[puzzleName.value] = puzzle;
    if (sourceIsVideo.checked) {
      puzzle.loopBeginning = loopBeginning.value;
      puzzle.loopEnding = loopEnding.value;
    } 
    localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
  }
  // returns pixel as a number
  function convertStyle(value) {
    return JSON.parse(value.replace('px', ''));
  }
  // adapts the position of the backToTileBarButtons
  function positionBackToTileBarButtons(calledByMouseDown) {
    if (!calledByMouseDown || (aufgebenId.style.display == "inline" && shuffleStyle.value == "listTiles" && state.mouse == "down" && tileSelectionBar.collidesMouse() && !selected.tiles.length)) {
      if (calledByMouseDown) tileSelectionBar.scrollX += (mausx - tileSelectionBar.swipePosition);
      tileSelectionBar.leftOffScreenTiles = - (Math.floor(tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5)));
      if (((tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5)) tileSelectionBar.offset = - (JSON.parse("0." + (tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5));
      else tileSelectionBar.offset = 0;
      if (tileSelectionBar.scrollX >= 0) tileSelectionBar.offset = -(tileSelectionBar.offset);
      else tileSelectionBar.leftOffScreenTiles--;
      for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
        elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
      }
      tileSelectionBar.swipePosition = mausx;
      if (calledByMouseDown) scrollTileSelection(0);
    }
  }
  function unclipp(tile) {
    var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
    var objTile = positions.wrong[tile];
    for (const direc of ['left', 'top', 'right', 'bottom']) {
      if (objTile.original[direc] && !selected.tiles.includes(getTile(objTile.original[direc]))) {
        delete positions.wrong[getTile(objTile.original[direc])].original[directionConverter[direc]];
        delete objTile.original[direc];
      }
    }
    var unclipped = false;
    for (let i = 0; i < clipped.length; i++) {
      if (clipped[i].split(' - ').includes(tile + "") && (!selected.tiles.includes(parseInt(clipped[i].split(' - ')[0])) || !selected.tiles.includes(parseInt(clipped[i].split(' - ')[1])))) {
        clipped.splice(i, 1);
        unclipped = true;
        i--;
      }
    }
    if (unclipped) {
      stats.unclipped++;
      if (["unclippStandardTutorial", "unclippTileAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
  }
  function checkPossibleClipping(tile, afterClipping) {
    pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
    pCollider = {width: parseInt(hitboxWidth.value), height: parseInt(hitboxHeight.value)};
    if ([90, 270].includes(positions.wrong[tile].original.degree) && lengthPerTeil.edit.x != lengthPerTeil.edit.y) {
      pCollider = {width: parseInt(hitboxHeight.value), height: parseInt(hitboxWidth.value)};
      pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
      pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
    }
    var nearest = {left: {area: 1000}, top: {area: 1000}, right: {area: 1000}, bottom: {area: 1000}, overAll: {area: 1000, i: -1}};
    for (let i = 0; i < positions.wrong.length; i++) {
      positions.wrong[i].tempI = i;
    }
    var possiblePositions = positions.wrong.filter(x => Math.abs(x.edit.x - positions.wrong[tile].edit.x) < pLengthPerTeil.edit.x + 11 && Math.abs(x.edit.y - positions.wrong[tile].edit.y) < pLengthPerTeil.edit.y + 11);
    for (const pos of possiblePositions) {
      var obj = {all: pos.edit, slc: positions.wrong[tile].edit};
      var selectedObj = {
        right: {x: obj.slc.x - 10, y: obj.slc.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2},
        left: {x: obj.slc.x + pLengthPerTeil.edit.x, y: obj.slc.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2},
        bottom: {x: obj.slc.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.slc.y - 10, width: pCollider.width - 2, height: 10},
        top: {x: obj.slc.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.slc.y + pLengthPerTeil.edit.y, width: pCollider.width - 2, height: 10}
      };
      if (!clipped.includes(pos.tempI + ' - ' + tile) && !clipped.includes(tile + ' - ' + pos.tempI)) {
        var nearTile = {
          right: collides(selectedObj.right, {x: obj.all.x + pLengthPerTeil.edit.x - parseInt(connectableSlightOverlap.value), y: obj.all.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10 + parseInt(connectableSlightOverlap.value), height: pCollider.height - 2}),
          left: collides(selectedObj.left, {x: obj.all.x - 10, y: obj.all.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10 + parseInt(connectableSlightOverlap.value), height: pCollider.height - 2}),
          bottom: collides(selectedObj.bottom, {x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y + pLengthPerTeil.edit.y - parseInt(connectableSlightOverlap.value), width: pCollider.width - 2, height: 10 + parseInt(connectableSlightOverlap.value)}),
          top: collides(selectedObj.top, {x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y - 10, width: pCollider.width - 2, height: 10 + parseInt(connectableSlightOverlap.value)})
        };
        for (var side of Object.keys(nearTile)) {
          if (nearTile[side].boolean && nearTile[side].area < nearest[side].area) {
            nearest[side] = {area: nearTile[side].area, i: pos.tempI};
          }
        }
      }
    }
    if (nearest) {
      // console.log("new check");
      for (const near of Object.values(nearest)) {
        // console.log(near.area);
        if (near.area < nearest.overAll.area) {
          nearest.overAll = {area: near.area, i: near.i};
        }
      }
    }
    var acceptedI = getConnectedTiles(nearest.overAll.i, true);
    screenObj = {x: visualViewport.pageLeft - texturLeft + state.rightScroll, y: visualViewport.pageTop - texturTop + state.upScroll, width: window.visualViewport.width, height: window.visualViewport.height};
    if (mirrorInput.checked) screenObj = {x: textur.width - (visualViewport.pageLeft - texturLeft + state.rightScroll), y: visualViewport.pageTop - texturTop + state.upScroll, width: window.visualViewport.width, height: window.visualViewport.height};
    canvas.fillStyle = "blue";
    // canvas.fillRect(screenObj.x, screenObj.y, screenObj.width, screenObj.height);
    var clipLength = selected.clip.length;
    var filteredClip = JSON.stringify(filter(selected.clip, false, true));
    var obj = {all: positions.wrong[nearest?.right.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.left && !filteredClip.includes(JSON.stringify({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y, width: 10, height: pLengthPerTeil.edit.y, selected: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y}}))) {
      selected.clip.push({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height, original: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y}, selected: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.right.area});
    }
    obj = {all: positions.wrong[nearest?.left.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.right && !filteredClip.includes(JSON.stringify({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y, width: 10, height: pLengthPerTeil.edit.y, selected: {x: obj.all.x - pLengthPerTeil.edit.x, y: obj.all.y}}))) {
      selected.clip.push({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height, original: {x: obj.all.x - 10, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y}, selected: {x: obj.all.x - pLengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.left.area});
    }
    obj = {all: positions.wrong[nearest?.bottom.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.top && !filteredClip.includes(JSON.stringify({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y, width: pLengthPerTeil.edit.x, height: 10, original: {x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y, width: pLengthPerTeil.edit.x, height: 10}, selected: { x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y}}))) {
      selected.clip.push({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y + pLengthPerTeil.edit.y, width: pCollider.width, height: 10, original: {x: obj.all.x + 1, y: obj.all.y + pLengthPerTeil.edit.y, width: lengthPerTeil.edit.x, height: 10}, selected: { x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y}, distance: nearest.bottom.area});
    }
    obj = {all: positions.wrong[nearest?.top.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.bottom && !filteredClip.includes(JSON.stringify({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x, y: obj.all.y - 10, width: pLengthPerTeil.edit.x, height: 10, selected: {x: obj.all.x, y: obj.all.y - pLengthPerTeil.edit.y}}))) {
      selected.clip.push({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y - 10, width: pCollider.width, height: 10, original: {x: obj.all.x, y: obj.all.y - 10, width: lengthPerTeil.edit.x, height: 10}, selected: {x: obj.all.x, y: obj.all.y - pLengthPerTeil.edit.y}, distance: nearest.top.area});
    }
    checkedTiles = [];
    for (var i = 0; i < selected.clip.length - clipLength; i++) {
      var clip = selected.clip[selected.clip.length - 1 - i];
      var clipCollider = JSON.parse(JSON.stringify(clip));
      clipCollider.x -= state.rightScroll;
      clipCollider.y -= state.upScroll;
      if (selected.clip.length > clipLength && ((selected.clip[selected.clip.length - 1 - i - 1] && angular.equals(clip, selected.clip[selected.clip.length - 1 - i - 1])) ||  (state.rotated && gerät == "Handy") || (positions.wrong[clip.i].original.degree != positions.wrong[clip.sI].original.degree && getDegreeAfterRotation(getDegreeAfterRotation(positions.wrong[clip.i].original.degree, 90), 90) /*total: 180°*/ != positions.wrong[clip.sI].original.degree && pLengthPerTeil.edit.x != pLengthPerTeil.edit.y) || tileSelectionBar.tiles.includes(clip.i) || ((/*selectedCollidesOthers(clip, tile) || */!collides(addTolerance(clipCollider, 3), screenObj).boolean || selectedCollideOther(clip.i) || clipCollidesLowerTile(clip) || !acceptedI.includes(clip.i)) && !afterClipping))) {
        selected.clip.pop();
        i--;
      }
    }
  }
  // returns a list with the indizes (plural index) of all tiles the entered tile ('tile') is connected to
  function getConnectedTiles(tile, firstCall, connectedTiles, restoreClipped) {
    if (!connectedTiles) connectedTiles = [];
    connectedTiles.push(tile);
    var tileObj = positions.wrong[tile];
    for (const side of ['left', 'top', 'right', 'bottom']) {
      if (tileObj && tileObj.original[side] && !connectedTiles.includes(getTile(tileObj.original[side]))) {
        if (restoreClipped && !clipped.includes(tile + ' - ' + getTile(tileObj.original[side])) && !clipped.includes(getTile(tileObj.original[side]) + ' - ' + tile)) {
          clipped.push(tile + ' - ' + getTile(tileObj.original[side]));
        }
        getConnectedTiles(getTile(tileObj.original[side]), false, connectedTiles, restoreClipped);
      }
    };
    if (firstCall) return connectedTiles;
  }
  function playClippingSound() {
    for (const option of selected.clip) {
      // new option
      if (!clipOptionsBefore || !JSON.stringify(clipOptionsBefore).includes(JSON.stringify(filter([option], true, true)[0]))) {
        if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseDown%20(click)_V3.mp3').play();
        clipOptionsBefore = (filter(selected.clip, true, true));
        if (vibrate.checked) window.navigator.vibrate(33);
        if (["getClippingOptionConnectTileTutorial", "getClippingOptionConnectTileMobileTutorial"].includes(tutorial.state))goTutorialSteps(1);
      }
    }
    if (clipOptionsBefore) {
      for (const option of clipOptionsBefore) {
        if (!JSON.stringify(filter(selected.clip, true, true)).includes(JSON.stringify(option))) {
          if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseUp%20(click).mp3').play();
          clipOptionsBefore = (filter(selected.clip, true, true));
          if (vibrate.checked) {
            setTimeout(function () {
              window.navigator.vibrate(27);
            }, 100);
          }
          if (["clipTileTutorial", "clipTileMobileTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
        }
      }
    }
  }
  // remove sI out of the entered obj
  function filter(clipOptions, sI, distance) {
    var stored = JSON.parse(JSON.stringify(clipOptions));
    for (const elm of stored) {
      if (sI) delete elm.sI;
      if (distance) delete elm.distance;
    }
    return stored;
  }
  var clipOptionsBefore;
  // checks collision of tiles with the clip options marker
  function selectedCollidesOthers(pClip,  tile) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (collides(transformToObj(i), addTolerance(pClip, 3)).boolean && !tileSelectionBar.tiles.includes(i) && !selected.tiles.includes(i) && tile != i) {
        return true;
      }
    }
  }
  var checkedTiles = [];
  // checks if selected tiles collide tiles which are (connected to) tiles you want to clip to
  function selectedCollideOther(pClipIndex) {
    var connected = getConnectedTiles(pClipIndex, true);
    for (const clipIndex of connected) {
      for (const tile of selected.tiles) {
        if (collides(transformToObj(clipIndex, 3), transformToObj(tile, 3)).boolean) {
          return true;
        }
      }
    }
  }
  // checks collision between clip marker and tiles on top of c.clipI (tile you want to clip to)
  function clipCollidesLowerTile(clip) {
    var clipIReached = false;
    for (const position of positions.layoutOrder.filter(x => !selected.tiles.includes(x))) {
      if (position == clip.i) clipIReached = true;
      else if (clipIReached && collides(clip, transformToObj(position, 3)).boolean && collideClip.checked) {
        return true;
      }
    }
  }
  var clipped = [];
  function collides(a, b) {
    try {
      return {boolean: !(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        ), area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)};

    } catch (e) {
      console.log('err: ' + e);
    }
  }
  // checks if potentiallySelected collides with any other tile (not used anymore due to more advanced collision detection (TODO: optional?))
  function selectedCollides(potentiallySelected) {
    for (var tile of selected.tiles) {
      if (collides(transformToObj(tile), transformToObj(potentiallySelected)).boolean) return tile;
    }
  }
  // transforms index of tile into an obj that can be used for collision checks (tolerance can be added)
  function transformToObj(i, tolerance) {
    pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
    if ([90, 270].includes(positions.wrong[i].original.degree)) {
      pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
      pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
    }
    var obj =  positions.wrong[i].edit;
    if (!tolerance) tolerance = 0;
    return {x: obj.x + tolerance, y: obj.y + tolerance, width: pLengthPerTeil.edit.x - tolerance*2, height: pLengthPerTeil.edit.y - tolerance*2};
  }
  // adds tolerance by decreacing the size of the entered hitbox (obj)
  function addTolerance(obj, tolerance) {
    return {...obj, x: obj.x + tolerance, y: obj.y + tolerance, width: obj.width - tolerance*2, height: obj.height - tolerance*2};
  }
  // returns the index of the tile which has the entered original coordinates
  function getTile(originalCoord) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (positions.wrong[i].original.x == originalCoord.x && positions.wrong[i].original.y == originalCoord.y) return i;
    };
  }
  // exchanges two tiles (positions)
  function vertauscheZwei(i, i1) {
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i].edit));
    positions.wrong[i].edit = JSON.parse(JSON.stringify(positions.wrong[i1].edit));
    positions.wrong[i1].edit = JSON.parse(JSON.stringify(ablage));
    if (positions.wrong[i1].edit == undefined) positions.wrong.splice(i1, 1);
  }
  // returns the coordinates of a selected tile (schieben and exchange mode)
  function checkSelected(removeTile) {
    // try {
        for (var i = 0; i < amountX.value; i++) {
          for (var i1 = 0; i1 < anzahlY.value; i1++) {
            if ((removeTile && mausx > lengthPerTeil.edit.x*i + 3*i && mausx < lengthPerTeil.edit.x*(i + 1) + 3*(i + 1) && mausy > lengthPerTeil.edit.y*i1 + 3*(i1) && mausy < lengthPerTeil.edit.y*(i1 + 1) + 3*(i1 + 1)) || (lengthPerTeil.edit && !removeTile && mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1))) {
              return {x: i, y: i1};
            }
            // if (!removeTile && mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1)) return {x: i, y: i1};
          }
        }
  // } catch (e) {
  //   console.log("pleaseDebug :)");
  // }
  }

// section 7: stop clock:
var stopClock = {viewOriginal: {time: 0, running: 0}, completionTime: {time: 0, running: 0}};
var time = 0;
var running = 0;

function startPause(type) {
if (stopClock[type].running == 0) {
  stopClock[type].running = 1;
  // time = 0;
  increment(type);
}
else {
  stopClock[type].running = 0;
}
}
function reset(type) {
running = 0;
timer = 0;
}
function increment(type) {
if (stopClock[type].running == 1) {
setTimeout(function () {
  stopClock[type].time++;
  var time = stopClock[type].time;
  var mins = Math.floor(time/10/60);
  var secs = Math.floor(time/10);
      secs -= 60*mins;
  var tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  if (type == "viewOriginal") stats[type].time = mins + ":" + secs + ":" + "0" + tenths;
  else stats[type] = mins + ":" + secs + ":" + "0" + tenths;
  increment(type);
}, 100);
}
}
// end section 7
function getSectionElm(elm) {
  try {
    while (!elm.className.includes("section")) {
      elm = elm.parentElement;
    }
    
  } catch (err) {
    console.err(err);
  }
  return elm;
}
function setupTutorial() {
  sourceURL.value = "https://adi.nicolaiweitkemper.de/Bilder/puzzleCreatorLogo.png";
    useURL();
    setTimeout(() => {
      if (!offline) startTutorial();
      else {
        alert('Please upload an image or a video from this device (for example select "file (photo or video)") in order to start the tutorial with the image.');
        state.waitForPictureSelection = true;
      }
      }, 777);
  }
  var tutorialSteps = [];
  function showUnclippTutorial() {
    document.onkeydown({key: 'F1'}); 
    setTimeout(() => {
      goToTutorialIndex(document.getElementById('contineTutorialUnclipp' + gerät));
    }, 1000);
  }
function startTutorial() {
  showTutorialB.innerHTML = "hide tutorial";
  var mode = modeSelection.value;
  document.getElementById('tutorial').style.display = "inline";
  // document.getElementById(mode + 'Tutorial').style.display = "inline";
  document.getElementById(mode + 'Tutorial' + gerät).style.display = "inline";
  document.getElementById(mode + 'Tutorial' + gerät).appendChild(completePuzzleTutorialDiv);
  tutorial.state = "starting";
  setTimeout(() => {
    // tutorialSteps = Array.from(document.getElementById('tutorial').querySelectorAll('input[type="checkbox"]')).filter(x => x.style.display != "none");
    document.getElementById('tutorial').style.display = "inline";
    tutorialSteps = Array.from(document.getElementById('tutorial').querySelectorAll('input[type="checkbox"]')).filter(x => x.offsetWidth > 0 || x.offsetHeight > 0);
    if (settings.style.display != "none") document.getElementById('tutorial').style.display = "none";
    goTutorialSteps(0);
  }, 777);
  if (mode == "traditional" && !state.helpTutorial) {
    shuffleStyle.value = "listTiles";
    emptyTileBar.checked = true;
  }
  if (state.helpTutorial && missing.length == 1) {
    moveMultipleOptionsSchiebenTutorial.style.display = "none";
  }
  setTimeout(() => {
      if (!state.helpTutorial) {
      create();
      if (mode != "schieben") shufflePuzzle();
      if (mode == "traditional") {
        for (const elm of document.getElementsByClassName('backToTileB')) {
          elm.style.display = "none";
        }
        tileSelectionCanvas.style.display = "none";
        selectBackToBarB.style.display = "none";
      }
      automaticTileSelectionReset.disabled = true;
      doStorePuzzle.disabled = true;
      doStorePuzzle.disabled = true;
      puzzleName.disabled = true;
      keepScrolling.disabled = true;
      swipeSteuerung,disabled = true; 
      listTilesS.style.display = "none";
    }
  }, 500);
  setTimeout(() => {
    if (gerät == "Handy"  && modeSelection.value == "traditional") document.getElementById('tutorial').style.top = mobileControls.getBoundingClientRect().bottom + 10;
  }, 777);
  document.getElementById('tutorial').style.maxHeight = window.innerHeight - mobileControls.getBoundingClientRect().bottom - 10;
  if (modeSelection.value != "traditional") document.getElementById('tutorial').style.maxHeight = window.innerHeight;
}
function goTutorialSteps(steps) {
  var direction = 1;
  if (steps < 0) direction = -1;
  if (steps == 0) direction = 0;
  if (tutorial.state != "starting") document.getElementById(tutorial.state + 'Div').className = "";
  try {
    if (direction > 0) tutorialSteps[tutorial.index].checked = true;
    else if (tutorialSteps.length) tutorialSteps[tutorial.index].checked = false;
    if (steps > 0)  {
     if (!angular.equals(getSectionElm(document.getElementById(tutorial.state + 'Div')), getSectionElm(tutorialSteps[tutorial.index + direction]))) {
      state.scrollToSection = true;
      setTimeout(() => {
        getSectionElm(tutorialSteps[tutorial.index + direction]).scrollIntoView();
        setTimeout(() => {
          state.scrollToSection = false;
        }, 1000);
      }, 100);
    }
  }
  // if (document.getElementById('tutorial').style.display == "inline") {
    tutorial.index += direction;
    tutorial.state = tutorialSteps[tutorial.index].id;
  // }
  if (!tutorialSteps.filter(x => document.getElementById(x.id + 'Div').className.includes('currentTutorialStep')).length) document.getElementById(tutorial.state + 'Div').className = "currentTutorialStep cardGeneral";
    setTimeout(() => {
        if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height - 40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
            document.getElementById(tutorial.state + 'Div').parentElement.parentElement.scrollIntoView();
          setTimeout(() => {
            if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height - 40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
                document.getElementById(tutorial.state + 'Div').parentElement.scrollIntoView();
              setTimeout(() => {
              if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height -40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
                  document.getElementById(tutorial.state + 'Div').scrollIntoView();
              }
            }, 1000);
          }
          }, 1000);
      }
    }, 300);
    if (tutorial.state == "tileClickMoveTutorial" && !state.helpTutorial) automaticTileSelectionReset.checked = false;
    if (steps != 0) {
      if (tutorial.state == "completePuzzleTutorial") alert("If you now want to create a puzzle from your own image/video, reload the page.");
      if (tutorial.state == "scrollArrowTileBarTutorial") window.scroll(0, 0);
      if (tutorial.state == "selectTileBarTileTutorial" && tileSelectionBar.selectedTile != undefined && steps == 1) goTutorialSteps(1);
      if (tutorial.state == "stopScrollingAutomaticScrollingTutorial") checkAutoscrollStop({x: scrollX, y: scrollY});
      if (tutorial.state == "schiebenSelectTileMoveMultipleTurorial" && !state.helpTutorial) {
        try {
          setTimeout(() => {
            missing.push("0 - 0");
            // positionsBeginning.push(positions.wrong[getTileIByCoord({x: 0, y: 0})]);
            positions.right.splice(getTileIByCoord({x: 0, y: 0}), 1);
            positions.wrong.splice(getTileIByCoord({x: 0, y: 0}), 1);
            missing.push(lengthPerTeil.edit.x*2 + " - 0");
            // positionsBeginning.push(positions.wrong[getTileIByCoord({x: 2, y: 0})]);
            positions.right.splice(getTileIByCoord({x: 2, y: 0}), 1);
            positions.wrong.splice(getTileIByCoord({x: 2, y: 0}), 1);
            layout(true, true);
          }, 1000);
        } catch (e) {}
      }
      if (tutorial.state == "pressShiftMobileUnclippTutorial") {
        selectMultipleTitle.innerHTML = "shift key";
        selectMultipleTitle.style.display = "inline";
      }
      else selectMultipleTitle.style.display = 'none';
      if (tutorial.state == "activateRotateLeftTutorial") rotateLeftTitle.style.display = "inline";
      else rotateLeftTitle.style.display = "none";
      if (tutorial.state == "activateRotateRightTutorial") rotateRightTitle.style.display = "inline";
      else rotateRightTitle.style.display = "none";
      if (moveStyleSettingChosen.checked && tutorial.state == "moveStyleSettingChosen" && steps == 1) goTutorialSteps(1);
      if (steps < 0 && ["pressShiftMobileUnclippTutorial", "selectTileMobileShiftUnclippTutorial"].includes(tutorial.state)) {
        selected.tiles = [];
        layout(true);
      }
      if (tutorial.state == "scrollArrowTileBarTutorial" && !state.helpTutorial) {
        for (const elm of document.getElementsByClassName('backToTileB')) {
          elm.style.display = "inline";
        }
        tileSelectionCanvas.style.display = "inline";
        selectBackToBarB.style.display = "inline";
        listTilesS.style.display = "block";
        for (var i = 0; i < 16; i++) {
          tileSelectionBar.tiles.splice(0, 0, i);
          unclipp(i);
          mouseDown();
        }
        setTimeout(() => {
          scrollTileSelectionRight.style.bottom = (lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionRight.getBoundingClientRect().height/2) + "px";
          scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionLeft.getBoundingClientRect().height/2 + "px";
        }, 777);
      }
      if (tutorial.state == "scrollArrowTileBarTutorial") {
        scrollTileSelection(1, 'arrowKey');
        tileSelectionBar.leftOffScreenTiles = 1;
        scrollTileBarTitle.style.display = "inline";
        scrollTileBarTitle.style.left = scrollTileSelectionLeft.getBoundingClientRect().left + scrollTileSelectionLeft.getBoundingClientRect().height/2;
        scrollTileBarTitle.style.top = scrollTileSelectionLeft.getBoundingClientRect().top - scrollTileSelectionLeft.getBoundingClientRect().height/2 - 11;
      }
      else scrollTileBarTitle.style.display = "none";
      if (tutorial.state == "mouseDownSelectFirstExchangeAlternativeTutorial") swipeSteuerung.checked = true;
      if (tutorial.state == "selectTileUnselectStandardTutorial") {
        setTimeout(() => {
          swipeSteuerung.checked = false;
        }, 10);
      }
      if (tutorial.state == "mouseDownUnselectAlternativeTutorial") swipeSteuerung.checked = true;
    }
    if (steps != 0) goTutorialSteps(steps + direction*(-1));
  }
  catch (err) {
    if (!state.helpTutorial) {
      console.log('tutorial finished!');
      console.log(tutorial.state);
      console.error(err)
      tutorial.state = "finished";
    }
  }
}
</script>
