<meta charset="utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<p id="imageSettings">
<input type="text" value="4" id="anzahl" onchange="anzahlVerschieben.value = value*value" placeholder="Puzzle Teile je x und y achse">
<input type="file" onchange="imageLoaded(this);">
<br>
<input type="range" width="window.innerWidth" oninput="zeigeGröße();" placeholder="Pixelanzahl x achse" id="größeAnpassenX"> Breite des Bildes
<br>
<input type="range" width="window.innerHeight"  max="window.innerHeight" onInput="zeigeGröße();" placeholder="Pixelanzahl y achse" id="größeAnpassenY"> Höhe des Bildes
<br>
<button type="button" onclick="zuBildschirmgröße();" name="button">Größe auf Bildschirmgröße anpassen</button>
<button type="button" onclick="zuAngepassterBildschirmgröße();" name="button">Größenverhältnis angleichen</button>
<button type="button" onclick="zuOptimalerBildschirmgröße();" name="button">Größenverhältnis optimieren</button>
<br>
<button type="button" onclick="create();" name="button">create puzzle</button>
</p>
<button type="button" id="showSettings" onclick="if (settings.style.display == 'none') settings.style.display = 'inline'; else settings.style.display = 'none'" name="button">mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)</button>
<div id="settings">
  <br>
  <br>
  <select onchange="modeSelected(value);" id="modeSelection">
    <option value="traditional">traditionell</option>
    <option value="exchange">austauschen</option>
    <option value="schieben">nur schieben</option>
  </select>
  <br>
  <div id="traditionalSettings">
    <p style="margin-bottom: 6px;" id="rotateTilesP"> <input id="rotateTiles" checked="true" type="checkbox"> drehe Teile</p>
    <input id="markWrong" type="checkbox" > markiere nicht passende
  </div>
  <div id="exchangeSettings">
  <p id="swipeSteuerungP"><input type="checkbox"  id="swipeSteuerung"> beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen</p>
  </div>
  <p id="schiebenSettings">
    <br>
    <strong style="font-size:15px;">mit der Anzahl der Schiebevorgänge, die der PC vornimmt, kann die Schwierigkeit am leichtesten kontrolliert werden</strong>
    <br>
    <input type="text" id="anzahlVerschieben" placeholder="Male PC verschieben">
    <br>
    <input type="checkbox" onchange="if (checked) {anzahlVerschieben.style.display = 'none'; innerHTML.replace('_', ''); if (zurrückVermeiden.checked) alert('WARNUNG: die Seite könnte sich aufhängen, weil zufällig verschoben wird und eine Verschiebung immer rückgängig gemacht werden kann! Bitte aktivieren sie << niemals eine Verschiebung rükgängig machen >> um dies (bei einer niedrigen Zahl)) zu vermeiden. Auch << leeres Feld 2 Mal an selber Stelle verboten >> kann Aufhänger verursachen, da das verschieben dadurch sehr stark eingeschrenkt wird und wharscheinlich gar nicht mehr richtig geschoben werden kann!');} else {anzahlVerschieben.style.display = 'inline'; innerHTML += '__'}" id="richtigeCheck"> verschieben, bis höchstens<input type="text" style="width:25px;" id="anzahlRichtige" value="10"> an origineller Stelle
    <br>
    <input type="checkbox" id="zurrückVermeiden" onchange="if (checked) anzahlVerboten.style.display = 'inline'; else anzahlVerboten.style.display = 'none';" checked="true"> <font size="5">leeres Feld 2 Mal an selber Stelle verboten (einfacher, weil immer direkt nebeneinander)</font>
    <br>
    <input type="text" id="anzahlVerboten" value="3" placeholder="Male bevor verboten">
    <!-- <input type="checkbox" id="difficultSchieben"> niemals eine verschiebng rückgängig machen (schwierig, weil immer viel verändert wird) -->
  </p>
  <br>
  <br>
  <br>
  <input type="checkbox" onchange="layout(true); if (checked) rightMarkerSettings.style.display = 'inline'; else rightMarkerSettings.style.display = 'none';" id="richtigPlazierte" checked="true"> markiere richtig plazierte
  <!-- <h3>general</h3> -->
  <p id="rightMarkerSettings">
  <input type="range" step="0.01" value="1" oninput="layout(true);" min="0.01" max="1" id="rightMarkerRadius"> radius von Mitte (in %)
  <br>
  <input min="0.01" max="1" step="0.01" value="0.3" oninput="layout(true)" id="rightMarkerTransparence" type="range"> Transparenz (in %)
</p>
  <br>
  <input type="checkbox" id="raender" onchange="if (checked) randSettings.style.display = 'inline'; else randSettings.style.display = 'none'; if (preview.src != '') layout();"> <font size="5"> zeige Ränder</font>
  <p id="randSettings">
    <br>
    <input type="range" min="1" value="13" oninput="randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - value; layout();" id="breiteRand"> Breite des Randes
    <br>
    <input type="range" min="0" value="0" oninput="layout();" id="randPosition"> Position des Randes
  </p>
  <br>
  <!-- <input type="checkbox" onchange="if (checked == true) {schiebenSettings.style.display = 'inline'; swipeSteuerungP.style.display = 'none';} else {schiebenSettings.style.display = 'none'; swipeSteuerungP.style.display = 'inline';}" id="schieben"> <font size="5">nur schieben</font> -->
  <br>
  <input id="reloadWhenFinished" onchange="localStorage.setItem('reloadWhenFinished', checked)" type="checkbox">Lade die Seite automatisch neu, kurz nachdem das Puzzle fertig ist
  <br>
  <br>
  <button type="button" id="aufgebenId" onclick="aufgeben(modeSelection.value);" name="button">aufgeben</button>
</div>
<br>
<canvas onmousedown="mouseDown();" onmouseup="mouseUp();" id="textur" width="1840" onclick="canvasClicked();" height="700"></canvas>
<p><img id="preview"></p>
<script>
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
  } else {
    var gerät = "PC"
    console.log("PC");
    swipeSteuerungP.style.display = "none";
  }
  reloadWhenFinished.checked = localStorage.getItem("reloadWhenFinished");
  anzahlVerschieben.value = anzahl.value*anzahl.value;
  settings.style.display = "none";
  aufgebenId.style.display = "none";
  // schiebenSettings.style.display  = "inline"
  randSettings.style.display = "none";
  schiebenSettings.style.display = "none";
  größeAnpassenX.max = window.innerWidth
  größeAnpassenY.max = window.innerHeight
  var canvas = textur.getContext('2d');
  function aufgeben(mode) {
    // if (mode == "schieben") {
      alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + höchstRichtige + " von " + (anzahl.value*anzahl.value - 1) + " Teilen");
      // }
  }
  function zuBildschirmgröße() {
    größeAnpassenX.value = window.innerWidth;
    größeAnpassenY.value = window.innerHeight;
    zeigeGröße();
  }
  function zuAngepassterBildschirmgröße(noShowing) {
    größeAnpassenX.value = [window.innerWidth, window.innerHeight].sort()[0];
    größeAnpassenY.value = [window.innerWidth, window.innerHeight].sort()[0];
    if (!noShowing) zeigeGröße();
  }
  function zuOptimalerBildschirmgröße() {
    größeAnpassenX.value = preview.width;
    größeAnpassenY.value = preview.height;
    while (größeAnpassenX.value > window.innerWidth || größeAnpassenY.value > window.innerHeight) {
      größeAnpassenX.value--;
      größeAnpassenY.value--;
    }
    zeigeGröße();
  }
  function zeigeGröße() {
    textur.width = größeAnpassenX.value;
    textur.height = größeAnpassenY.value
    // canvas.clearRect(0, 0, textur.width, textur.height);
    if (preview.src == "") {
    canvas.fillStyle = "blue";
    canvas.fillRect(0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  else {
    canvas.drawImage(document.getElementById('preview'), 0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  }
  function modeSelected(value) {
    traditionalSettings.style.display = 'none';
    exchangeSettings.style.display = 'none';
    schiebenSettings.style.display = 'none';
    document.getElementById(value + 'Settings').style.display = 'inline';
  }
  var originalSize = {width: 0, height: 0};
  function create() {
    //finished = false;
    // if (swipeSteuerung.checked) textur.style.touchAction = 'none';
    /*if (swipeSteuerung.checked) {
      alert("Please zoom out as far as possible! You have 5 sec. for that!");
      // textur.style.touchAction = '';
      setTimeout(function () {
        textur.style.touchAction = 'none';
        create2();
      }, 5000);
    }
    else */create2();
  }
  function create2() {
    if (modeSelection.value == "traditional" && rotateTiles.checked) zuAngepassterBildschirmgröße(true);
    aufgebenId.style.display = "inline";
    showSettings.innerHTML = "Einstellungsmöglichkeiten und Möglichkeit Aufzugeben";
    imageSettings.style.display = "none";
    modeSelection.style.display = "none";
    schiebenSettings.style.display = "none";
    rotateTilesP.style.display = "none";
    missing = undefined;
    settings.style.display = 'none';
    originalSize.width = preview.width;
    originalSize.height = preview.height;
    preview.width = größeAnpassenX.value;
    preview.height = größeAnpassenY.value;
    textur.width = preview.width// + 111;
    textur.height = preview.height// + 111;
    var anzahl = document.getElementById('anzahl').value;
    lengthPerTeil = {original: {x: Math.round(originalSize.width/anzahl), y: Math.round(originalSize.height/anzahl)}, edit: {x: Math.round(preview.width/anzahl), y: Math.round(preview.height/anzahl)}};
    breiteRand.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3;
    randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - breiteRand.value;
    positions = {right: []};
    for (var i = 0; i < anzahl; i++) {
      for (var i1 = 0; i1 < anzahl; i1++) {
        if (modeSelection.value == "traditional") {
          var newTile = {original: {x: lengthPerTeil.original.x*i, y: lengthPerTeil.original.y*i1, degree: 0}};
          if (i) newTile.original.left = {x: positions.right[i*anzahl + i1 - anzahl]?.original.x, y: positions.right[i*anzahl + i1 - anzahl]?.original.y};
          if (i1) newTile.original.top = {x: positions.right[i*anzahl + i1 - 1]?.original.x, y: positions.right[i*anzahl + i1 - 1]?.original.y};
          positions.right.push(newTile);
          if (i1) positions.right[i*anzahl + i1 - 1].original.bottom = {x: newTile.original.x, y: newTile.original.y};
          if (i) positions.right[i*anzahl + i1 - anzahl].original.right = {x: newTile.original.x, y: newTile.original.y};
        }
        else {
          positions.right.push({original: {x: lengthPerTeil.original.x*i, y: lengthPerTeil.original.y*i1}, edit: {x: lengthPerTeil.edit.x*i, y: lengthPerTeil.edit.y*i1}})
        }
        positions.right[positions.right.length - 1].border = [];
        if (i == 0) positions.right[positions.right.length - 1].border.push("left");
        if (i == anzahl - 1) positions.right[positions.right.length - 1].border.push("right");
        if (i1 == 0) positions.right[positions.right.length - 1].border.push("up");
        if (i1 == anzahl - 1) positions.right[positions.right.length - 1].border.push("down");
      }
    }
    positions.wrong = JSON.parse(JSON.stringify(positions.right));
    if (modeSelection.value == "traditional") {
      textur.width += 500;
      textur.height += 500;
    for (var position of positions.wrong) {
      position.edit = {x: Math.round(Math.random()*(textur.width - lengthPerTeil.edit.x)), y: Math.round(Math.random()*(textur.height - lengthPerTeil.edit.y))};
      position.original = {x: position.original.x, y: position.original.y, degree: [0, 90, 180, 270][Math.round(Math.random()*3)]};
      if (!rotateTiles.checked) position.original.degree = 0;
    }
  }
    for (i = positions.wrong.length - 1; modeSelection.value == "exchange" && i > 0; i--) {
      j = Math.floor(Math.random() * (i + 1));
      x = positions.wrong[i].edit;
      positions.wrong[i].edit = positions.wrong[j].edit;
      positions.wrong[j].edit = x;
    }
    //canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/200, /*yFromPicture*/200, 200, 200, /*xFromPlacement*/0, /*yFromPlacement*/0, 200, 200);
    window.scroll(0, /*96 50*/32);
    if (modeSelection.value == "schieben") {
      alert("Bitte wählen sie ein Teilstück aus, das entfernt wird. Im besten Fall ist es ein unwichtiger Teil de Bildes!");
      layout(true);
    }
    else layout();
  }
  function imageLoaded(input) {
    var reader = new FileReader();
    reader.onload = function (e) {
      document.getElementById('preview').setAttribute("src", e.target.result)
    };
    reader.readAsDataURL(input.files[0])
    setTimeout(function () {
       canvas.drawImage(document.getElementById('preview'), 0, 0);
       textur.width = preview.width// + 111;
       textur.height = preview.height// + 111;
       größeAnpassenX.max = preview.width;
       größeAnpassenY.max = preview.width;
       größeAnpassenX.value = preview.width;
       größeAnpassenY.value = preview.height;
       zeigeGröße();
    }, 500);
  }
  var lengthPerTeil = {};
  var positions = {right: []};
  var finished = false;
  var missing;
  function convertDirection(direc, degr) {
    var directions = ['top', 'right', 'bottom', 'left'];
    var direcObj = {top: 0, right: 1, bottom: 2, left: 3};
    while (degr > 0) {
      direc = directions[direcObj[direc] + 1];
      if (!direc) direc = directions[0];
      degr -= 90;
    }
    return direc;
  }
  function layout(withoutAlert, clear, pReturn) {
    if (clear) canvas.clearRect(0, 0, 10000, 10000);
    richtige = 0;
    for (var i = 0; i < positions.wrong?.length; i++) {
      drawPictureSegment(positions.wrong[i], positions.right[i]);
    }
    for (var clip of selected.clip) {
      canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
      if (markWrong.checked && (JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) canvas.fillStyle = 'rgba(255, 0, 0, 0.83)';
      canvas.save();
      canvas.translate(clip.x, clip.y);
      // canvas.rotate((positions.wrong[clip.sI].original.degree + 180)*Math.PI/180);
      canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), clip.width, clip.height);
      canvas.restore();
    }
    for (var tile of selected.tiles) {
      canvas.fillStyle = "rgba(255, 0, 0, 0.2)";
      canvas.save();
      canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
      canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
      canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
      canvas.restore();
    }
    if (höchstRichtige < richtige && !withoutAlert) {
      höchstRichtige = JSON.parse(JSON.stringify(richtige));
    }
    if (richtige == positions.wrong?.length) {
      richtige = 0;
      finished = true;
      layout(true);
      finished = false;
      if(!withoutAlert) {
        if (pReturn) return "noChange!";
        if (modeSelection.value == "schieben") alert("Sie haben es in " + playerMoved + " Zügen geschafft! Zum Umschieben vom Originalbild hat der Computer " + movement.positions.length + " Züge benötigt, um es zu zerwuseln. Ob du darauf jetzt stolz sein kannst, musst du selber entscheiden ;)");
        if (reloadWhenFinished.checked) {
          setTimeout(function () {
            window.location.reload(false);
          }, 3000);
        }
        else alert("Bitte laden sie die Seite neu, wenn sie ein weiteres Puzzle erstellen wollen!");
    }
  }
}
  var richtige = 0;
  function drawPictureSegment(position, segmentPosition) {
    canvas.save();
    if (modeSelection.value == "traditional") canvas.translate(position.edit.x, position.edit.y);
    else canvas.translate(position.edit.x + lengthPerTeil.edit.x/2, position.edit.y + lengthPerTeil.edit.y/2);
    canvas.rotate(position.original.degree*Math.PI/180);
    canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // canvas.restore();
    if (((modeSelection.value != "traditional" && position.edit.x == segmentPosition.edit.x && position.edit.y == segmentPosition.edit.y) || (modeSelection.value == "traditional" && angular.equals(position.original, segmentPosition.original))) && !finished) {
      canvas.fillStyle = "rgba(0, 255, 0, " + rightMarkerTransparence.value + ")";
      if (richtigPlazierte.checked) {
        // canvas.fillRect(position.edit.x + lengthPerTeil.edit.x/2 - (lengthPerTeil.edit.x*rightMarkerRadius.value)/2, position.edit.y + lengthPerTeil.edit.y/2 - (lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
        // canvas.save();
        // canvas.translate(position.edit.x, position.edit.y);
        // canvas.rotate(position.original.degree*Math.PI/180);
        canvas.fillRect(-(lengthPerTeil.edit.x*rightMarkerRadius.value)/2, -(lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
      }
      richtige++;
    }
    canvas.restore();
    canvas.fillStyle = "rgba(0, 0, 255, 0.35)";
    if (raender.checked) {
      canvas.save();
      canvas.translate(position.edit.x, position.edit.y);
      canvas.rotate((position.original.degree)*Math.PI/180);
      // if (position.borderincludes("right")) canvas.fillRect(position.edit.x - JSON.parse(breiteRand.value) + lengthPerTeil.edit.x - JSON.parse(randPosition.value) - ((lengthPerTeil.edit.x)/2), position.edit.y - ((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y, position.original.degree);
      // if (position.borderincludes("left")) canvas.fillRect(position.edit.x + JSON.parse(randPosition.value) - ((lengthPerTeil.edit.x)/2), position.edit.y - ((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y, position.original.degree);
      // if (position.borderincludes("up")) canvas.fillRect(position.edit.x - ((lengthPerTeil.edit.x)/2), position.edit.y + JSON.parse(randPosition.value) - ((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, JSON.parse(breiteRand.value), position.original.degree);
      // if (position.borderincludes("down")) canvas.fillRect(position.edit.x - ((lengthPerTeil.edit.x)/2), position.edit.y - JSON.parse(breiteRand.value) + lengthPerTeil.edit.y - JSON.parse(randPosition.value) - ((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, JSON.parse(breiteRand.value), position.original.degree);
      if (position.border.includes("right")) canvas.fillRect((lengthPerTeil.edit.x)/2 - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("left")) canvas.fillRect(-((lengthPerTeil.edit.x)/2) + JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("up")) canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2) + JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      if (position.border.includes("down")) canvas.fillRect(-((lengthPerTeil.edit.x)/2), ((lengthPerTeil.edit.y)/2) - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      canvas.restore();
    }
  }
  var selected = {boolean: false, position: {x: 0, y: 0}, tiles: [], clip: []}
  function canvasClicked() {
    settings.style.display = "none"
    if (checkSelected() && settings.style.display == "inline") settings.style.display = "none";
    if (checkSelected() && selected.boolean && modeSelection.value != "schieben") {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
          for (var i1 = 0; i1 < positions.wrong.length; i1++) {
            if (positions.wrong[i1].edit.x/lengthPerTeil.edit.x == selected.position.x && positions.wrong[i1].edit.y/lengthPerTeil.edit.y == selected.position.y) {
              console.log("vertausche " + checkSelected().x + "-" + checkSelected().y + " mit " + selected.position.x + "-" + selected.position.y);
              playerMoved++;
              vertauscheZwei(i, i1);
              i = positions.wrong.length;
              i1 = positions.wrong.length;
            }
          }
        }
      }
      selected.boolean = false;
    }
    else if (modeSelection.value == "schieben" && checkSelected()/* && selected.boolean*/ && missing) {
        if ((missing.data.edit.x == checkSelected().x*lengthPerTeil.edit.x + lengthPerTeil.edit.x && missing.data.edit.y == checkSelected().y*lengthPerTeil.edit.y) /*right*/ || (missing.data.edit.x == checkSelected().x*lengthPerTeil.edit.x - lengthPerTeil.edit.x && missing.data.edit.y == checkSelected().y*lengthPerTeil.edit.y)/*left*/ || (missing.data.edit.y == checkSelected().y*lengthPerTeil.edit.y + lengthPerTeil.edit.y && missing.data.edit.x == checkSelected().x*lengthPerTeil.edit.x)/*down*/ || (missing.data.edit.y == checkSelected().y*lengthPerTeil.edit.y - lengthPerTeil.edit.y && missing.data.edit.x == checkSelected().x*lengthPerTeil.edit.x)/*up*/) {
          for (var i = 0; i < positions.wrong.length; i++) {
            if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
              console.log("schiebe...");
              playerMoved++;
              var ablage = JSON.parse(JSON.stringify(positions.wrong[i]));
              positions.wrong[i].edit = JSON.parse(JSON.stringify(missing.data.edit));//.splice(side, 1);
              missing.data = ablage;
              i = positions.wrong.length;
              selected.boolean = false;
            }
          }
        }
        // canvas.clearRect(0, 0, 10000, 10000);
        // layout();
    }
    else if (checkSelected() && (modeSelection.value != "schieben"/* || missing*/)) {
      selected.position = {x: checkSelected().x, y: checkSelected().y};
      selected.boolean = true;
    }
    if (checkSelected() && modeSelection.value == "schieben" && !missing) {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == checkSelected().x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == checkSelected().y) {
          missing = {data: JSON.parse(JSON.stringify(positions.wrong[i]))};
          positions.wrong.splice(i, 1);
          positions.right.splice(i, 1);
        }
      }
      verschiebenPC();
      }
      else {
        layout(true, true);
      }
  }
  function verschiebenPC() {
    var missingArray = [];
    var workingNumbers = [];
    var maleZurrück = {number: 0, normalSlide: 0};
    for (var i = 0; i < positions.wrong.length; i++) {
      workingNumbers.push(i);
    }
    var counter = 0;
    for (var i = 0; i < /*positions.wrong.length + */JSON.parse(anzahlVerschieben.value) || (richtigeCheck.checked && richtige > anzahlRichtige.value) && (counter < 99999 || confirm('mixing the cards takes longer than expected and might crash this website. Still continue?')); i++) {
      var side = workingNumbers[Math.round(Math.random()*(workingNumbers.length - 1))];
      try {
      if (((zurrückVermeiden.checked && ((missingArray.length < 1 || workingNumbers.length == 0/*positions.wrong[side].edit.x != missingBefore.data.edit.x && positions.wrong[side].edit.y != missingBefore.data.edit.y*/) || ((maleZurrück.number < anzahlVerboten.value && !((maleZurrück.normalSlide/5 + "").includes("."))) || !(missingArray.includes(positions.wrong[side].edit.x + "-" + positions.wrong[side].edit.y)/*missingBefore.data.edit.x != missing.data.edit.x && missingBefore.data.edit.y != missing.data.edit.y*/)))) || !zurrückVermeiden.checked) && ((missing.data.edit.x == positions.wrong[side].edit.x + lengthPerTeil.edit.x && missing.data.edit.y == positions.wrong[side].edit.y) /*right*/ || (missing.data.edit.x ==
      positions.wrong[side].edit.x - lengthPerTeil.edit.x && missing.data.edit.y == positions.wrong[side].edit.y)/*left*/ || (missing.data.edit.y == positions.wrong[side].edit.y + lengthPerTeil.edit.y && missing.data.edit.x == positions.wrong[side].edit.x)/*down*/ || (missing.data.edit.y == positions.wrong[side].edit.y - lengthPerTeil.edit.y && missing.data.edit.x == positions.wrong[side].edit.x)/*up*/)) {
      if (zurrückVermeiden.checked && (missingArray.includes(positions.wrong[side].edit.x + "-" + positions.wrong[side].edit.y))) {
        maleZurrück.number++;
      }
      else maleZurrück.normalSlide++;
      missingArray.push(missing.data.edit.x + "-" + missing.data.edit.y);
      //console.log(missingArray);
      movement.positions.unshift(JSON.parse(JSON.stringify(positions)));
      movement.missing.unshift(JSON.parse(JSON.stringify(missing)));
      var ablage = JSON.parse(JSON.stringify(positions.wrong[side]));
      positions.wrong[side].edit = JSON.parse(JSON.stringify(missing.data.edit));//.splice(side, 1);
      textur.width = textur.width;
      layout(true);
      // for (var i1 = 0; difficultSchieben.checked && i1 < movement.positions.length; i1++) {
      //   if (angular.equals(positions, movement.positions[i1])/* && angular.equals(missing, movement.missing[i1])*/) {
      //     positions = JSON.parse(JSON.stringify(movement.positions[1]));
      //     missing = JSON.parse(JSON.stringify(movement.missing[1]));
      //     movement.positions.splice(0, 1);
      //     movement.missing.splice(0, 1);
      //     maleZurrück.number++;
      //     i1 = movement.positions.length;
      //     i--;
      //     for (var i2 = 0; i2 < workingNumbers.length; i2++) {
      //       if (workingNumbers[i2] == side) workingNumbers.splice(i2, 1);
      //     }
      //   }
      // }
      // if (i1 != movement.positions.length + 1) {
          missing.data = ablage
          var workingNumbers = [];
          for (var i1 = 0; i1 < positions.wrong.length; i1++) {
            workingNumbers.push(i1);
          }
      // }
    }
      else {
        i--;
        for (var i1 = 0; i1 < workingNumbers.length; i1++) {
          if (workingNumbers[i1] == side) workingNumbers.splice(i1, 1);
        }
      }
    } catch (e) {
      //console.log("ein Error bei der if Abfrage!!! + (" + e + ")");
      i = positions.wrong.length;
    }
    counter++;
    }
    if (layout(undefined, true, true) != undefined) verschiebenPC();
  }
  var movement = {missing: [], positions: []};
  var mausx;
  var mausy;
  var playerMoved = 0;
  var höchstRichtige = 0;
  document.onmousemove = readMouseMove
  function readMouseMove(e) {
    mausx = e.clientX + scrollX;
    mausy = e.clientY + scrollY - /*96*/32// - 43;
    // if (scrollY > 32) mausy += 32;
    folgenMouseMove();
  }
  var state = {mouse: "up", shift: false, newTileSelected: false};
  function mouseDown() {
    if (modeSelection.value == "traditional") {
      // selected.tiles = [];
      selected.position = {x: mausx, y: mausy};
      state.mouse = "down";
      folgenMouseMove();
    }
  }
  function folgenMouseMove() {
    if (state.mouse == "down") {
      for (var i = positions.wrong?.length - 1; i >= 0; i--) {
        var coord = positions.wrong[i].edit;
        var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
        if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
        if (!state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
          selected.tiles.push(i);
          layout(true);
          state.newTileSelected = true;
        }
      }
      // select clipped
      for (var tile of selected.tiles) {
        for (var clipp of clipped) {
          var newTile = clipp.split(' - ').filter(x => !selected.tiles.includes(JSON.parse(x)))[0];
          if (!state.shift && clipp.split(' - ').includes(tile + "") && newTile) selected.tiles.push(JSON.parse(newTile));
        }
        // unclipp
        if (state.shift) {
          positions.wrong[tile].original = {x: positions.wrong[tile].original.x, y: positions.wrong[tile].original.y, degree: positions.wrong[tile].original.degree};
          clipped.forEach((clipp, i) => {
            if (clipp.split(' - ').includes(tile + "")) clipped.splice(i, 1);
          });
        }
        // positions.wrong.forEach((position, i) => {
        //   if (((positions.wrong[tile].original?.left?.x == position.original?.x && positions.wrong[tile].original?.left?.x != undefined && positions.wrong[tile].original?.left?.y == position.original?.y) || (positions.wrong[tile].original?.top?.x == position.original?.x && positions.wrong[tile].original?.top?.x != undefined && positions.wrong[tile].original?.top?.y == position.original?.y) || (positions.wrong[tile].original?.wrong?.x == position.original?.x && positions.wrong[tile].original?.wrong?.x != undefined && positions.wrong[tile].original?.wrong?.y == position.original?.y) || (positions.wrong[tile].original?.bottom?.x == position.original?.x && positions.wrong[tile].original?.bottom?.x != undefined && positions.wrong[tile].original?.bottom?.y == position.original?.y)) && !selected.tiles.includes(i)) {
        //     selected.tiles.push(i);
        //   }
        // });
      }
      if (selected.tiles.length) {
        positions.wrong.forEach((pos, i) => {
          if (selected.tiles.includes(i)) {
            pos.edit.x += mausx - selected.position.x;
            pos.edit.y += mausy - selected.position.y;
          }
        });
        // check clicking
        selected.clip = [];
        for (var tile of selected.tiles) {
          checkPossibleClipping(tile);
        }
        selected.position = {x: mausx, y: mausy};
        layout(false, true);
      }
    }
  }
  function checkPossibleClipping(tile) {
    var nearest = {left: {area: 1000}, top: {area: 1000}, right: {area: 1000}, bottom: {area: 1000}};
    positions.wrong.forEach((pos, i) => {
      var obj = {all: pos.edit, slc: positions.wrong[tile].edit};
      // canvas.fillStyle = "yellow";
      // canvas.fillRect(obj.all.x + lengthPerTeil.edit.x, obj.all.y, 10, lengthPerTeil.edit.y);
      // canvas.fillStyle = "orange";
      // canvas.fillRect(obj.slc.x - 10, obj.slc.y, 10, lengthPerTeil.edit.y);
      var selectedObj = {
        right: {x: obj.slc.x - 10, y: obj.slc.y + 1, width: 10, height: lengthPerTeil.edit.y - 2},
        left: {x: obj.slc.x + lengthPerTeil.edit.x, y: obj.slc.y + 1, width: 10, height: lengthPerTeil.edit.y - 2},
        bottom: {x: obj.slc.x + 1, y: obj.slc.y - 10, width: lengthPerTeil.edit.x - 2, height: 10},
        top: {x: obj.slc.x + 1, y: obj.slc.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x - 2, height: 10}
      };
      if (!clipped.includes(i + ' - ' + tile) && !clipped.includes(tile + ' - ' + i)) {
        var nearTile = {
          right: collides(selectedObj.right, {x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y + 1, width: 10, height: lengthPerTeil.edit.y - 2}),
          left: collides(selectedObj.left, {x: obj.all.x - 10, y: obj.all.y + 1, width: 10, height: lengthPerTeil.edit.y - 2}),
          bottom: collides(selectedObj.bottom, {x: obj.all.x + 1, y: obj.all.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x - 2, height: 10}),
          top: collides(selectedObj.top, {x: obj.all.x + 1, y: obj.all.y - 10, width: lengthPerTeil.edit.x - 2, height: 10})
        };
        for (var side of Object.keys(nearTile)) {
          if (nearTile[side].boolean && nearTile[side].area < nearest[side].area) {
            nearest[side] = {area: nearTile[side].area, i: i};
          }
        }
      }
    });
    var screenObj = {x: scrollX, y: scrollY, width: window.innerWidth - 22, height: window.innerHeight};
    var clipLength = selected.clip.length;
    var obj = {all: positions.wrong[nearest?.right.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.left && collides(transformToObj(nearest?.right.i), screenObj).boolean) {
      selected.clip.push({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y, selected: {x: obj.all.x + lengthPerTeil.edit.x, y: obj.all.y}});;
    }
    obj = {all: positions.wrong[nearest?.left.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.right && collides(transformToObj(nearest?.left.i), screenObj).boolean) {
      selected.clip.push({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y, selected: {x: obj.all.x - lengthPerTeil.edit.x, y: obj.all.y}});
    }
    obj = {all: positions.wrong[nearest?.bottom.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.top && collides(transformToObj(nearest?.bottom.i), screenObj).boolean) {
      selected.clip.push({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x, y: obj.all.y + lengthPerTeil.edit.y, width: lengthPerTeil.edit.x, height: 10, selected: { x: obj.all.x, y: obj.all.y + lengthPerTeil.edit.y}});
    }
    obj = {all: positions.wrong[nearest?.top.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.bottom && collides(transformToObj(nearest?.top.i), screenObj).boolean) {
      selected.clip.push({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x, y: obj.all.y - 10, width: lengthPerTeil.edit.x, height: 10, selected: {x: obj.all.x, y: obj.all.y - lengthPerTeil.edit.y}});
    }
    if (selected.clip.length > clipLength && selectedCollidesOthers(selected.clip[selected.clip.length - 1], tile)) selected.clip.pop();
  }
  function selectedCollidesOthers(pClip, tile) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (collides(transformToObj(i), addTolerance(pClip, 3)).boolean && !selected.tiles.includes(i) && tile != i) return true;
    }
  }
  var clipped = [];
  function mouseUp() {
    if (modeSelection.value == "traditional") {
      state.mouse = "up";
      state.newTileSelected = false;
      if (selected.clip.length > 0) new Audio('https://adi.nicolaiweitkemper.de/Sounds/helpTheTrain/weiche.mp3').play();
      for (var clip of selected.clip) {
        var directionOpposite = {left: 'right', top: 'bottom', right: 'left', bottom: 'top'};
        positions.wrong[clip.i].original[clip.direction] = {x: positions.right[clip.sI].original.x, y: positions.right[clip.sI].original.y};
        positions.wrong[clip.sI].original[directionOpposite[clip.direction]] = {x: positions.right[clip.i].original.x, y: positions.right[clip.i].original.y};
        var differ = {x: (clip.selected.x - positions.wrong[clip.sI].edit.x), y: (clip.selected.y - positions.wrong[clip.sI].edit.y)};
        for (var tile of selected.tiles) {
          positions.wrong[tile].edit.x += differ.x;
          positions.wrong[tile].edit.y += differ.y;
        }
        clipped.push(clip.i + ' - ' + clip.sI);
        // do more clipping if needed
        checkPossibleClipping(clip.sI);
    }
    selected.clip = [];
    if (selected.tiles.length && !state.shift) selected.tiles = [];
    }
  }
  function collides(a, b) {
    try {
      return {boolean: !(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        ), area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)};

    } catch (e) {
      console.log('err: ' + e);
    }
  }
  function selectedCollides(potentiallySelected) {
    for (var tile of selected.tiles) {
      // if (collides({x: positions.wrong[tile].edit.x, y: positions.wrong[tile].edit.y, width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y}, potentiallySelected)
      if (collides(transformToObj(tile), transformToObj(potentiallySelected)).boolean) return tile;
    }
  }
  function transformToObj(i, tolerance) {
    var obj =  positions.wrong[i].edit;
    if (!tolerance) tolerance = 0;
    return {x: obj.x + tolerance, y: obj.y + tolerance, width: lengthPerTeil.edit.x - tolerance*2, height: lengthPerTeil.edit.y - tolerance*2};
  }
  function addTolerance(obj, tolerance) {
    return {...obj, x: obj.x + tolerance, y: obj.y + tolerance, width: obj.width - tolerance*2, height: obj.height - tolerance*2};
  }
  // if (gerät == "Handy") {
    document.addEventListener('touchmove', touch);
    document.addEventListener('touchstart', touch);
    document.addEventListener('touchend', touch);
  // }
  document.onkeydown = function(event) {
    if (event.shiftKey) {
      state.shift = true;
    }
    if (event.key == "ArrowRight") rotateSelected(90);
    if (event.key == "ArrowLeft") rotateSelected(-90);
    if (event.key.includes("Arrow")) layout(true);
  }
  function rotateSelected(direction) {
    for (var tile of selected.tiles) {
      positions.wrong[tile].original.degree += direction;
      if (positions.wrong[tile].original.degree < 0) positions.wrong[tile].original.degree = 270;
      else if (positions.wrong[tile].original.degree >= 360) positions.wrong[tile].original.degree = 0;
    }
  }
  document.onkeyup = function(event) {
    if (!event.shiftKey && state.shift) {
      state.shift = false;
      selected.tiles = [];
    }
  }
  function touch(ev) {
    if (ev.touches[2]) {
      textur.style.touchAction = '';
    }
    else if (ev.type == "touchmove") textur.style.touchAction = 'none';
    if (ev.touches[1]) {
      state.shift = true;
      selected.tiles = [];
    }
    else if (ev.type == "touchmove") state.shift = false;
    if ((ev.type == "touchend" && swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && (textur.style.touchAction == 'none') && (swipeSteuerung.checked ))) {
      // textur.style.touchAction = '';
      canvasClicked();
    }
    else if ((swipeSteuerung.checked || modeSelection.value == "traditional") && modeSelection.value != "schieben" && ev.touches[0]) {
      mausx = ev.touches[0]["pageX"]// + scrollX;
      mausy = ev.touches[0]["pageY"] - 32// + scrollY;
    }
    if (ev.type == "touchstart") {
      mouseDown();
    }
    if (ev.type == "touchend") {
      mouseUp();
      layout(true, true);
    }
    if (ev.type == "touchmove" && modeSelection.value == "traditional") {
      folgenMouseMove();
    }
    if (!ev.touches[0]) {
      console.log(":((()))");
    }
      if (ev.type == "touchstart" && swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && ev.touches[0]) {
        if (textur.style.touchAction != 'none') {
        setTimeout(function () {
          window.scroll(0, /*96 50*/32);
          textur.style.touchAction = 'none';
          selected.position = {x: checkSelected().x, y: checkSelected().y};
          selected.boolean = true;
        }, 3000);
      }
      else {
        selected.position = {x: checkSelected().x, y: checkSelected().y};
        selected.boolean = true;
      }

      }
  }
  function vertauscheZwei(i, i1) {
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i].edit));
    positions.wrong[i].edit = JSON.parse(JSON.stringify(positions.wrong[i1].edit));
    positions.wrong[i1].edit = JSON.parse(JSON.stringify(ablage));
    if (positions.wrong[i1].edit == undefined) positions.wrong.splice(i1, 1);
  }
  function checkSelected() {
    try {
    for (var i = 0; i < anzahl.value; i++) {
      for (var i1 = 0; i1 < anzahl.value; i1++) {
        if (mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1)) return {x: i, y: i1};
      }
    }
  } catch (e) {
    console.log("pleaseDebug :)");
  }
  }
  function scrollDownFunction() {
  if (mausy - scrollY > window.innerHeight - 10 && (modeSelection.value != "traditional" || state.mouse == "down"))  {
  window.scroll(scrollX, scrollY + 3);
  mausy += 3;
}
}
scrollDownInt = setInterval(scrollDownFunction, 10);
scrollUpInt = setInterval(function () {
  if ((mausy - scrollY < 50 && (state.mouse == "down" || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    window.scroll(scrollX, scrollY - 3);
    mausy -= 3;
}
}, 10);
</script>
