<meta charset="utf-8">
<meta name="viewport" id="preventAutomaticZoom">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<div id="puzzleManager" class="card cardGeneral">
  <h1>Puzzle verwalten</h1>
  <img src="https://adi.nicolaiweitkemper.de/Bilder/database_import_icon.png" title="Bereits erstellte Puzzle fortfahren" draggable="false" >
  <li id="puzzleSelection"></li>
  <img src="https://adi.nicolaiweitkemper.de/Bilder/saveicon.png" title="im Folgenden erstellte Puzzle speichern" draggable="false" >
  <div style="display: none;" onmouseout="checkOut();"  class="dropdown-content" id="editPuzzleManager">
    <a onclick="restorePuzzleSource(selected.puzzle);">öffnen/fortfahren</a>
    <a onclick="editPuzzleName();">Name bearbeiten</a>
    <a onclick="deletePuzzle();">löschen</a>
    <a onclick="showInformation();">mehr Informationen</a>
  </div>
  <br>
  <a id="storePuzzleManager">
    <input id="doStorePuzzle" type="checkbox"> im Folgenden erstellte Puzzle unter dem Namen 
    <input oninput="if (Object.keys(puzzles).includes(value)) puzzleNameWarning.style.display = 'inline'; else puzzleNameWarning.style.display = 'none'; doStorePuzzle.checked = true;" id="puzzleName" type="text"> 
    automatisch speichern
    <br>
  </a>
  <p id="puzzleNameWarning" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
    Sie haben ein Puzzle bereits so benannt. Bitte wählen Sie einen anderen Namen! Andernfalls wird das Puzzle das bisher so hieß überschrieben bzw. gelöscht!!!
  </p>
</div>
<div id="imageSettings">
<div class="card cardGeneral">
<h1 id="selectSourceHeader" style="color: red;">Quelle auswählen</h1>
<br>
<input type="file" onchange="readImg(this);" style="position: absolute; left: -10000px;" id="fileB">
<input id="sourceIsFile" onclick="fileB.click();" style="font-size: 55px;" type="radio" name="source"><a onclick="fileB.click(); sourceIsFile.checked = true;">Datei (Foto oder Video) auswählen</a></input>
<br>
<input onchange="useURL();" id="useURLCheck" type="radio" name="source">
<input type="text" style="height: 50px;" oninput="useURL();" height="100px" placeholder="URL (drag and drop möglich)" id="sourceURL">
<br>
<p id="URLInfo" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
  Die URL muss direkt auf das Bild/Video verweisen! Führen Sie dafür einen Rechtsklick auf das gewünschte Bild aus und klicken Sie auf "Bildadresse kopieren", um die richtige Adresse/URL zu kopieren! Alternativ können Sie das Bild in das obrige Feld ziehen oder stattdessen auf "Bild im neuen Tab öffnen" klicken, und dort die Adresse/URL kopieren.
  <br>
</p>
<a style="display: none; border-radius: 3px; border-style: double; background-color: darkorange; width: max-content; height: max-content;" id="sourceCheckboxes">
  <input id="sourceIsPicture" onchange="state.userSource = 'Picture';" checked="true" name="mediaType" type="radio">Bild
  <input id="sourceIsVideo" onchange="state.userSource = 'Video';" name="mediaType" type="radio">Video
  <br>
</a>
<input id="useLiveCam" type="radio" name="source" onchange="changeCamera(cameraSelection.value);"><a onclick="useLiveCam.checked = true; changeCamera(cameraSelection.value);">nutze live Kamera</a></button>
<select id="cameraSelection" onchange="changeCamera(value);"></select>
</div>
<div id="tilesSizeDiv" class="card cardGeneral">
  <h3>Anzahl der Puzzleteile</h3>
  <input type="number" min="0" value="4" style="width: 44px;" id="anzahlX" onchange="anzahlVerschieben.value = value*anzahlY.value; anzahlRichtige.max = value*anzahlY.value - 2; drawTileGrid();"> Teile x-Achse
  <br>
  <input type="number" min="0" value="4" style="width: 44px;" id="anzahlY" onchange="anzahlVerschieben.value = anzahlX.value*value; anzahlRichtige.max = anzahlX.value*value - 2; drawTileGrid();"> Teile y-Achse
</div>
<div id="editCanvasDiv" class="card cardGeneral">
<h2>Bild bearbeiten</h2>
<input id="mirrorInput" onclick="mirrorCanvas(checked);" type="checkbox"> Bild/Video spiegeln
<br>
<p1 id="screenIsMaxP"><input id="screenIsMax" onchange="changeAdaptedSizeMax(originalSize.width, originalSize.height);" checked="true" type="checkbox"> maximale Größe des Bildes: Bildschirmgröße</p1>
<br>
<input id="percentSizeAdaption" oninput="größeAnpassenX.value = größeAnpassenX.max*value; größeAnpassenY.value = größeAnpassenY.max*value; zeigeGröße(true);" min="0.01" step="0.01" max="1" type="range"> Breite und Höhe prozentual anpassen
<br>
<input type="range" oninput="zeigeGröße(true);" placeholder="Pixelanzahl x achse" id="größeAnpassenX"> Breite des Bildes
<br>
<input type="range" max="window.innerHeight" oninput="zeigeGröße(true);" placeholder="Pixelanzahl y achse" id="größeAnpassenY"> Höhe des Bildes
<br>
<button type="button" onclick="resetImageSize();" name="button">⟲ Originalgröße des Bildes</button>
<button type="button" onclick="zuBildschirmgröße();" name="button">Größe auf Bildschirmgröße anpassen</button>
<button type="button" onclick="zuAngepassterBildschirmgröße();" name="button">Größenverhältnis angleichen (quadratische Teile)</button>
<button type="button" onclick="zuOptimalerBildschirmgröße();" title="verkelinert sowohl Höhe als auch Breite des Bildes solange, bis beides auf den Bildschirm passt. " name="button">Größenverhältnis optimieren</button>
<br>
<a id="rotateTilesAdaptionSettings">
  <button type="radio" id="bAdaptAmount" onclick="if (checked) adaptTileAmount(true); drawTileGrid();" name="adaptionStyle"> Anzahl Puzzleteile anpassen, sodass Breite und Höhe der Teile übereinstimmen (quadratische Teile)</button>
    und insgesamt mindestens <input id="minTileAmount" oninput="adaptTileAmount();" style="width: 45px;" value="16" min="2" type="number"> Teile erstellt werden.
  <br>
</a>
<br>
<canvas onmousedown="mouseDown(true);" onmouseup="mouseUp();" style="border-width: 3px; border-style: solid; touch-action: manipulation;" id="textur" width="1" onclick="canvasClicked('elm');" height="1"></canvas>
</div>
<button type="button" style="font-size: 33px;color: white; background-color: red; border: 10px;border-style: double;" onclick="create();" id="createPuzzleButton" name="button">erstelle Puzzle</button>
</div>
<!-- <button type="button" id="showSettings" onclick="changeSettingsVis();" name="button">mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)</button> -->
<button id="showTutorialB" style="display: none;" onclick="document.onkeydown({key: 'F1'});">Hilfe (Steuerung anzeigen)</button>
<br>
<img src="https://adi.nicolaiweitkemper.de/Bilder/settings.png" id="showSettings" class="button" title="mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)" onmouseup="changeSettingsVis();"  draggable="false" >
<br>
<button style="position: fixed; display: none; z-index: 3;" id="selectBackToBarB" onclick="generalBackToBar(this);">zurück in Leiste</button>
<p2 style="position: fixed; top: -7px; left: 377px; background-color: rgba(205, 218, 199, 0.77); font-size: 5vh; padding-bottom: 15px; border-radius: 5px; z-index: 2;" id="mobileControls">
  <p id="rotateControls" style="display: none;">
    <a style="display: none;" id="traditionalModeMobileControls">
      <input class="mobileControlsElm" type="radio" onclick="rotateLeftModeChanged();" name="rotateB" id="rotatesLeft" name="button"><a1 onclick="showTitle(id, style.display);" id="rotateLeftSymbol">⟲</a1>
      <input class="mobileControlsElm" type="radio" onclick="rotateRightModeChanged();" name="rotateB" id="rotatesRight"  name="button"><a1 onclick="showTitle(id, style.display);" id="rotateRightSymbol">⟳</a1>
      <!-- <button class="mobileControlsElm" onclick="state.shift = true;"><==></button> -->
      <input type="checkbox" id="selectMultiple" class="mobileControlsElm" onchange="state.shift = true; if (['pressShiftMobileUnclippTutorial', 'pressShiftMobileMultipleUnclippTutorial'].includes(tutorial.state)) {goTutorialSteps(1);} if (['selectTileMobileShiftUnclippTutorial', 'selectTileMobileShiftMultipleUnclippTutorial'].includes(tutorial.state) && !checked) goTutorialSteps(-1);"><a1 onclick="showTitle(id, style.display);" id="selectMultipleSymbol">⇧</a1>
    </a>
  </p>
    <input class="mobileControlsElm" type="checkbox" id="scrollable" onclick=" if ((tutorial.state == 'selectScrollScrollingTutorial' && checked) || (tutorial.state == 'unselectScrollScrollingTutorial' && !checked)) goTutorialSteps(1); if (tutorial.state == 'scrollMobileScrollingTutorial' && !checked) goTutorialSteps(-1); if (tutorial.state == 'zoomInTutorial' && !checked) goTutorialSteps(-2); if (tutorial.state == 'zoomOutTutorial' && !checked) goTutorialSteps(-3);" name="button"><a onclick="showTitle(id, style.display);" id="swipeSymbol">scroll</a>
</p2>
<div id="tileElements">
  <div id="rotateLeftTitle" style="display: none;" class="speech top">
    Teil pro Klick um 90° nach links drehen 
  </div>
  <div id="rotateRightTitle" style="display: none;" class="speech top">
    Teil pro Klick um 90° nach rechts drehen 
  </div>
  <div id="selectMultipleTitle" style="display: none;" class="speech top">
    Mehrfachauswahl durch Klicken auf Teile und Teile abtrennen durch Bewegen eines der ausgewählten Teile
  </div>
  <div id="swipeTitle" style="display: none;" class="speech top">
    Scrollen und Zoomen ermöglichen
  </div>
  <div id="scrollTileBarTitle" style="display: none;" class="speech bottom">
    Pfeil
  </div>
</div>
<style>
  .button {
    width: 50px; 
    border: 3px solid hsla(0, 0%, 2%, 0.4); 
    background: rgb(200, 200, 200);
  }
  .mobileControlsElm {
    width: 44;
    height: 44;
    top: 7px;
    padding: 100px;
  }
</style>
<div id="settings" style="display: none;" class="card cardGeneral">
  <h2 id="modeHeadline">Modus: </h2>
  <div id="modeDiv" class="card cardGeneral">
  <select onchange="modeSelected(value);" id="modeSelection">
    <option value="traditional">traditionell</option>
    <option value="exchange">austauschen</option>
    <option value="schieben">nur schieben</option>
  </select>
  <br>
  <p id="traditionalDescription">Die Puzzleteile werden verteilt. Nun müssen Sie die Teile wieder zusammensetzen. 
    <br>
    Wo die Teile zusammengesetzt werden ist egal.
    <div id="startTutorialButton">
      <br>
      <button onclick="setupTutorial();">tutorial</button>
    </div>
  </p>
  <p style="display: none;" id="exchangeDescription">
    Die Positionen der Puzzleteile wird ausgetauscht. Danach haben Sie die Aufgabe, durch Klicken auf zwei Teile diese auszutauschen, bis das Originalbild wiederhergestellt ist.
  </p>
  <p style="display: none;" id="schiebenDescription">
    Mindestens ein Puzzleteil muss gelöscht werden. Danach vermischt das Programm die Teile durch Schieben.
    <br>
    Ist dies geschehen, können Sie die Teile durch Klicken auf das zu verschiebende Teil (und unter Umständen die gewünschte Zielposition) so verschieben, dass wieder das Originalbild entsteht.
  </p>
  <div id="futureModeSettingsHeader"></div>
  <div class="card cardGeneral" id="traditionalSettings">
    <b style="font-size: 25px;" id="modeSettingsHeading">modusspezifische Einstellungen: <br> </b>
    <br>
    <input id="clipOptionsSound" checked="true" type="checkbox"> akustisches Feedback (Audio bei Verbindungsmöglichkeiten)
    <a id="vibrateA">
      <br>
      <input id="vibrate" type="checkbox"> haptisches Feedback (bei neuer Verbindungsmöglichkeit vibrieren)
    </a>
    <br>
    <input id="automaticTileSelectionReset" onclick=" tutorial.state = ''; document.onkeydown({key: 'F1', changeElement: true}); document.getElementById('tutorial').style.display = 'none'; localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" type="checkbox"> automatisch Teile/Auswahl abwählen (Alternative)
    <br>
    <p style="margin-bottom: 6px;" id="rotateTilesP">
    <input id="rotateTiles" onchange="if (checked) rotateTilesAdaptionSettings.style.display = 'none'; else {rotateTilesAdaptionsettings.style.display = 'block';}" checked="true" type="checkbox"> drehe Teile
    </p>
    <input id="markWrong" style="accent-color: red;" type="checkbox" > markiere nicht passende
    <a id="shuffleStyleLable">
      <br>
      Art der Verteilung der Teile: 
    </a>
    <select onchange="shuffleStyleVisibilities(value);";  id="shuffleStyle">
      <option value="overlapTiles">Teile verstreuen und überlappen lassen</option>
      <option value="listTiles">Teile nebeneinander auflisten (Teilliste)</option>
      <option value="nextToEachOther">Teile mit Abstand nebeneinander legen</option>
    </select>
    <a id="shuffleHeadline" style="display: none;">
      <br>
      <br>
      <b style="font-size: 25px;">Einstellungen zu der Verteilung der Teile:</b>
      <br>
    </a>
    <div style="display: none" class="card cardGeneral" id="EmptyTileBarDiv">
      <br>
      <input id="emptyTileBar" onchange="if (checked) emptyTileBarSettings.style.display = 'block'; else emptyTileBarSettings.style.display = 'none'; emptyTileBarShuffleStyleSelected(shuffleStyleBar.value);" type="checkbox">mit leerer Liste starten
      <div style="display: none;" id="emptyTileBarSettings">
        dabei folgendermaßen die Teile mischen: 
        <select onchange="emptyTileBarShuffleStyleSelected(value);" id="shuffleStyleBar">
          <option value="overlapTiles">Teile verstreuen und überlappen lassen</option>
          <option value="nextToEachOther">Teile mit Abstand nebeneinander legen</option>
        </select>
      </div>
      <div id="emptyTilebarTileGap"></div>
      <div id="tilesGapS" class="card cardGeneral" style="display: none;">
        <br>
        Abstand (in px): <input min="0" id="tilesGap" oninput="gapSizeChanged(value);" value="55" style="width: 55px;" type="number">
        <br>
        <br>
        <canvas id="gapCanvas"></canvas>
        <br>
        <input id="fillScreenTileGap" onchange="if (checked) aScrollXTileGap.style.display = 'none'; else aScrollXTileGap.style.display = 'inline';" checked="true" type="checkbox"> Bildschirm füllen
        <br>
        <a style="display: none" id="aScrollXTileGap">
          <input id="tilesXTileGap" min="1" value="4" style="width: 55px;" type="number"> Teile nebeneinander
          <br>
        </a>
      </div>
      <br>
    </div>
    <div id="shuffleStyleTileGap"></div>
      <a id="hitboxCheckbox" style="display: none;"><input onchange="if (checked) tileColliderSettings.style.display = 'block'; else tileColliderSettings.style.display = 'none'; adaptExpandButtonPosition(); showHitboxes();" type="checkbox"> <b>zeige Einstellung zur Modifizierung der Hitboxen zwischen den Teilen</b></a>
      <a id="tileColliderSettings" style="display: none;">
        <br>
        <input onchange="if (checked) {showHitboxes(); shortHaltColliderDiv.style.display = 'inline';} else shortHaltColliderDiv.style.display = 'none';" id="doHitboxAnimation" type="checkbox"> animation
        <br>
        <input id="highHitboxVisibility" type="checkbox"> blaue Linie auf dem "Spielfeld" immer an gesamtem Teil anzeigen
        <div id="shortHaltColliderDiv" style="display: none;"><input id="shortHaltCollider" type="checkbox"> stoppe kurz bei Anfangspunkt und Endpunkt der Kollision</div>
        <br>
        Hitbox Breite: <input type="range" min="1" oninput="showHitboxes();" id="hitboxWidth">
        <br>
        Hitbox Höhe: <input type="range" min="1" oninput="showHitboxes();" id="hitboxHeight">
        <br>
        <canvas id="hitboxTextur"></canvas>
      </a>
      <br>
      <input id="collideClip" checked="true" type="checkbox"> Teile an verdeckte Ränder nicht anknüpfen lassen
      <br>
      <input checked="true" onchange="if (checked)  connectableSlightOverlap.value = 10; else connectableSlightOverlap.value = 0;" type="checkbox"> Verbindungsoptionen auch bei leichter Überlappung der Teile anbieten
      <input type="number" id="connectableSlightOverlap" value="10" style="display: none;">
      <p id="scrollOnBlancP"><input id="scrollOnBlanc" checked="true" type="checkbox"> scrollen auf leerem Hintergrund erlauben</p>
      <a>
    <div style="display: none;" class="card cardGeneral" id="listTilesS">
      <h3>Einstellungen zur Teilleiste: </h3>
      <input type="checkbox" checked="true" onchange="backToBarVis(checked)"; id="BackToBarB"> Buttons für Zurückführung der Teile in die Leiste unten
      <br>
      <div id="backToBarBSize">
        <input id="backToBarBWidth" oninput="changeBackToBarB('width', value)" type="range"> Breite der Buttons
        <br>
        <input id="backToBarBHeight" oninput="changeBackToBarB('height', value)" type="range"> Höhe der Buttons
      </div>
      <br>
      <a id="tileBarHeightText">Höhe der Leiste</a>
      <button onclick="setDefaultSelectionBarHeight();" id="resetBarSize">reset</button>
      <input type="range" oninput="changeTileBarHeight(value);" min="25" id="tileBarHeight">
      <div id="autoSelectTileBarP">
        <input type="checkbox" checked="true" id="autoSelectTileBar"> automatisch nächstes Element in Auflistung anwählen
      </div>
    </div>
    <br>
  </div>
  <div id="exchangeSettings" class="card cardGeneral" style="display: none">
  <p id="swipeSteuerungP"><input type="checkbox" onclick="tutorial.state = ''; document.onkeydown({key: 'F1', changeElement: true}); document.getElementById('tutorial').style.display = 'none';" id="swipeSteuerung"> beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen</p>
  </div>
  <p id="schiebenSettings" class="card cardGeneral">
    <br>
    <strong style="font-size:15px;">mit der Anzahl der Schiebevorgänge, die der PC vornimmt, kann die Schwierigkeit am leichtesten kontrolliert werden</strong>
    <br>
    Lasse PC <input type="number" min="2" style="width: 55px;" id="anzahlVerschieben"> Mal verschieben: 
    <br>
    <input type="checkbox" onchange="if (checked) {anzahlVerschieben.style.display = 'none'; innerHTML.replace('_', ''); } else {anzahlVerschieben.style.display = 'inline'; innerHTML += '__'}" id="richtigeCheck"> verschieben, bis höchstens<input type="number" style="width:55px;" max="14" min="0" id="anzahlRichtige" value="10"> an origineller Stelle
    <br>
    <input type="checkbox" id="zurrückVermeiden" checked="true"> <font size="5">leeres Feld 2 Mal an selber Stelle nach <input type="number" id="anzahlVerboten" value="3" style="width: 42px;"> Malen verboten (einfacher, weil immer direkt nebeneinander)</font>
    <!-- <input type="checkbox" id="difficultSchieben"> niemals eine verschiebng rückgängig machen (schwierig, weil immer viel verändert wird) -->
  </p>
  <a style="display: none;" id="turnsHistoryS">
    <br>
    <div id="movementPlayer" style="display: none;">
      <input onchange="changeMovementPlayerVis(checked);" type="checkbox"><b>Züge des PCs ansehen</b>
      <div id="innerMovementPlayer" style="display: none;">
        <br>
        <input id="distinctMovement" onchange="movementStepsChanged(checked);" checked="true" onchange="" type="checkbox"> kürzeste Lösung, die der PC weiß
        <br>
        <button id="movementDirectionLeft" onclick="changeMovementDirection(-1);"><<</button>
        <button onclick="playMovementPos(objMovementPlayer.position - 1);"><</button>
        <button id="movementPlayButton" onclick="playPauseMovement();">play</button>
        <button onclick="playMovementPos(0);">⟲</button>
        <button onclick="playMovementPos(objMovementPlayer.position + 1);">></button>
        <button id="movementDirectionRight" style="background-color: hsla(180, 100%, 50%, 1);" onclick="changeMovementDirection(1);">>></button>
        <br>
        <input id="movementPosition" oninput="playMovementPos(value);" min="0" type="range"> Position
        <button onclick="playMovementPos(getPlayerPosition());">zu Ihrer Positionierung (falls vorhanden)</button>
        <br>
        <b>Geschwindigkeit</b>
        <br>
        schnell <input min="155" value="500" max="1000" id="movementPlayerSpeed" type="range"> langsam
        <button onclick="movementPlayerSpeed.value = 500;">zurücksetzen</button>
        <br>
        <canvas id="movementPlayerTextur"></canvas>
      </div>
      <br>
    </div>
    <input onchange="if (checked) {userMovementPlayer.style.display = 'block'; generalSettings.style.display = 'none';} else {userMovementPlayer.style.display = 'none'; generalsettings.style.display = 'block';}" type="checkbox"> <b>zu vorherigen Zug zurückkehren:</b>
    <div class="cardGeneral card" style="display: none;" id="userMovementPlayer">
      <button onclick="if (userMovement.index - 1 >= 0) {userMovement.index--; playMovementPos(userMovement.index, null, null, userMovement.moves);}"><</button>
      <input id="playerMovementSlider" oninput="playMovementPos(value, null, null, userMovement.moves);" min="0" max="0" type="range">
      <button onclick="if (userMovement.index < userMovement.moves.length) {userMovement.index++; playMovementPos(userMovement.index, null, null, userMovement.moves);}">></button>
      <br>
      <input id="goBackAsTurns" type="checkbox"> als extra Züge werten
    </div>
    <br>
    <input id="showRemovedTiles" type="checkbox"> gelöschte Teile als Anhaltspunkte an richtiger Position anzeigen (vorrausgesetzt kein Teil wurde auf die Position geschoben)
  </a>
  </div>
  <div id="generalSettings" class="card cardGeneral">
  <h2>allgemeine Einstellungen: </h2>
    <input type="checkbox" onchange="adaptExpandButtonPosition(); if (checked) rightMarkerSettings.style.display = 'block'; else rightMarkerSettings.style.display = 'none'; layout(true);" id="richtigPlazierte" style="accent-color: green;" checked="true"> markiere richtig plazierte
    <!-- <h3>general</h3> -->
    <div id="rightMarkerSettings" class="card cardGeneral">
      <input type="range" step="0.01" value="1" oninput="layout(true);" min="0.01" max="1" id="rightMarkerRadius"> radius von Mitte (in %)
      <br>
  <input min="0.01" max="1" step="0.01" value="0.3" oninput="layout(true)" id="rightMarkerTransparence" type="range"> Transparenz (in %)
  <br>
  Farbe: <input type="color" oninput="layout();" id="markRightColor" value="#00FF00">
    </div>
    <br>
  <input type="checkbox" id="raender" onchange="adaptExpandButtonPosition(); if (checked) randSettings.style.display = 'block'; else randSettings.style.display = 'none'; if (preview.src != '') layout(true, true);"> <font size="5"> zeige Ränder</font>
  <div id="randSettings" class="card cardGeneral">
    <input type="range" min="1" value="13" oninput="randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - value; layout();" id="breiteRand"> Breite des Randes
    <br>
    <input type="range" min="0" value="0" oninput="layout();" id="randPosition"> Position des Randes
    <br>
    <input type="range" min="0.01" max="1" step="0.01" value="0.35" oninput="layout();" id="borderTransparency"> Transparenz des Randes
    <br>
    Farbe: <input type="color" id="borderColor" oninput="layout();" value="#0000FF">
  </div>
  <!-- <input type="checkbox" onchange="if (checked == true) {schiebensettings.style.display = 'block'; swipeSteuerungP.style.display = 'none';} else {schiebenSettings.style.display = 'none'; swipeSteuerungP.style.display = 'inline';}" id="schieben"> <font size="5">nur schieben</font> -->
  <br>
  <input id="reloadWhenFinished" onchange="localStorage.setItem('reloadWhenFinished', checked)" type="checkbox">Lade die Seite automatisch neu, kurz nachdem das Puzzle fertig ist
  <br>
  <input id="keepScrolling" checked="true" type="checkbox"> am Rand scrollen bis Teil abgewählt oder vom Rand entfernt
  <br>
  <button type="button" id="aufgebenId" onclick="showCurrentStats(modeSelection.value);" name="button">vorläufige bzw. beste Ergebnis ansehen</button>
  <br>
  <div style="display: none;" class="card cardGeneral" id="videoControls">
    <h3>video controls</h3>
    <a id="timeChangeDiv">
    <input id="loop" checked="true" onchange="if (checked) stopAtEndP.style.display = 'none'; else stopAtEndP.style.display = 'inline'; playPauseVideo('play');" type="checkbox"> ⟲ Wiederholen
    <br>
    <input type="checkbox" onclick="video.muted = checked;">mute</input>
    <a id="stopAtEndP" style="display: none;"><input id="stopAtEnd" type="checkbox"> am Ende stoppen</a>
    <br>
    beginne bei <input type="text" oninput="if (value > loopEnding.value) {playPauseVideo('pause'); timeSlotWarning.style.display = 'inline';} else timeSlotWarning.style.display = 'none';" id="loopBeginning"> 
    <button onclick="if (timeText.innerHTML.split(' / ')[0] < loopEnding.value || loopEnding.value == '') {loopBeginning.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100); timeSlotWarning.style.display = 'none';} else timeSlotWarning.style.display = 'block';">nimm aktuelle Zeit</button> 
    und ende bei <input id="loopEnding" oninput="if (value < loopBeginning.value) {playPauseVideo('pause'); timeSlotWarning.style.display = 'inline';} else timeSlotWarning.style.display = 'none';" type="text">
     <button onclick="if (timeText.innerHTML.split(' / ')[0] > loopBeginning.value || loopBeginning.value == '') {loopEnding.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100); timeSlotWarning.style.display = 'none';} else timeSlotWarning.style.display = 'block';">nimm aktuelle Zeit</button>
    <br>
    <p id="timeSlotWarning" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
      Sie haben das Ende des Ausschnittes vor den Anfang gesetzt! Bitte setzen Sie den Startpunkt weiter vorne oder das Ende weiter hinten, damit Ihre Änderung übernommen wird.
      <br>
    </p>
    <button onclick="video.currentTime -= 10;"><<</button>
    </a>
    <button onclick="playPauseVideo(innerHTML);" id="playVideo">pause</button>
    <a id="timeChangeDiv">
    <button onclick="video.currentTime += 10;">>></button>
    <input oninput="video.currentTime = value; playPauseVideo('pause');" step="0.01" type="range" id="videoPosition" min="0">
    <a id="timeText"></a>
    </a>
</div>
<p id="showOriginalP" style="display:none">
  <input id="showOriginal"  onchange="originalDisplayChanged(checked)" type="checkbox"> Original anzeigen
  <br>
  <img style="display: none;" id="preview">
  <canvas style="display: none;" id="videoPreview"></canvas>
</p>
<div id="futurePuzzleManager"></div>
</div>
<br>
</div>
<button type="button" id="removeTilesFinishedB" style="display: none; font-size: 33px" onclick="shufflePuzzle();" name="button">Fertig</button>
<a id="tileStatusOptions" style="display: none; position: fixed; background-color: rgba(205, 218, 199, 0.77); border-radius: 5px;">
<input type="radio" id="pRemoveTile" checked="true" style="accent-color: red;" name="tileStatus"> Teil löschen
<input type="radio" id="doNotMoveTile" style="accent-color: blue;" name="tileStatus"> Teil beim Mischen nicht bewegen
</a>
<div id="futureTexturPosition"></div>
<br>
<br>
<button onclick="expandSide('top');" style="height: 55px;" class="expandButtons" id="expandTop">+</button>
<button onclick="expandSide('right');" style="width: 55px;" class="expandButtons" id="expandRight">+</button>
<button onclick="expandSide('left');" style="width: 55px;" class="expandButtons" id="expandLeft">+</button>
<br>
<button class="expandButtons" style="height: 55px;" onclick="expandSide('bottom');" id="expandBottom">+</button>
<canvas id="tileSelectionCanvas" style="display: none;" onmousedown="mouseDown(true);" onmouseup="mouseUp();" width="1" height="1"></canvas>
<div class="expandButtons" id="backToBarButtons">
</div>
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.6'" id="scrollTileSelectionRight" onclick="scrollTileSelection(1, 'elm');">
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.6'" id="scrollTileSelectionLeft" onclick="scrollTileSelection(-1, 'elm');">
<style>
  .dropdown {
position: relative;
display: inline-block;
}

.dropdown-content {
display: none;
position: absolute;
background-color: #f1f1f1;
min-width: 160px;
box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
z-index: 1;
}

.dropdown-content a {
color: black;
padding: 12px 16px;
text-decoration: none;
display: block;
}

.dropdown-content a:hover {background-color: #ddd;}
</style>
<style>
  #tileSelectionCanvas {
    /* position: -webkit-sticky; */
    position: fixed;
    bottom: 0px;
    overflow: hidden;
    background-color: hsla(0, 0%, 64%, 0.77);
    touch-action: none;
  }
  #scrollTileSelectionRight {
    position: fixed;
    right: 0px;
    opacity: 0.6;
    display: none;
  }
  #scrollTileSelectionLeft {
    position: fixed;
    left: 0px;
    opacity: 0.6;
    transform: rotate(180deg);
    display: none;
  }

  .backToTileB {
    position: fixed;
  }
  .expandButtons {
    display: none;
    font-size: 55px;
    position: absolute;

  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  }
</style>
<style name="bubbleStyle">
  /* (A) SPEECH BOX */
  .speech {
    /* (A1) FONT */
    font-family: arial, sans-serif;
    /* font-size: 0.5em; */
    /* font-size: 0.7em; */
    /* font-size: 1vw; */
    /* font-size: 25px; */
    font-size: 5vh;
  
    /* (A2) COLORS */
    color: #fff;
    background: blue;
  
    /* (A3) DIMENSIONS + POSITION */
    position: absolute;
    padding: 20px;
    border-radius: 10px;
    max-width: 320px;
    z-index: 2;
  }
  
  /* (B) ADD SPEECH "CALLOUT TAIL" */
  /* (B1) USE ::AFTER TO CREATE THE "TAIL" */
  .speech::after {
    /* (B1-1) ATTACH TRANSPARENT BORDERS */
    content: "";
    border: 20px solid transparent;
  
    /* (B1-2) NECESSARY TO POSITION THE "TAIL" */
    position: absolute;
  }
  
  /* (B2) BOTTOM "CALLOUT TAIL" */
  .bottom.speech::after {
    /* (B2-1) DOWN TRIANGLE */
    border-top-color: blue;
    border-bottom: 0;
  
    /* (B2-2) POSITION AT BOTTOM */
    bottom: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C) DIFFERENT TAIL POSITIONS */
  /* (C1) TOP */
  .top.speech::after {
    /* (C1-1) UP TRIANGLE */
    border-bottom-color: blue;
    border-top: 0;
  
    /* (C1-2) POSITION AT TOP */
    top: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C2) LEFT */
  .left.speech::after {
    /* (C2-1) LEFT TRIANGLE */
    border-right-color: blue;
    border-left: 0;
  
    /* (C2-2) POSITION AT LEFT */
    left: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (C3) RIGHT */
  .right.speech::after {
    /* (C3-1) RIGHT TRIANGLE */
    border-left-color: blue;
    border-right: 0;
  
    /* (C3-2) POSITION AT RIGHT */
    right: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (X) DOES NOT MATTER - SPACERS */
  /* .speech, .circular { margin: 50px 0 0 50px; } */
  body { padding-bottom: 100px; }
  
  </style>
  <style>
    #tutorial {
      background-color: rgba(205, 218, 199, 0.77);
      position: fixed;
      right: 0px;
      top: 0px;
      width: 47%;
      box-shadow: 2px 2px 20px #855d5d;
      display: none;
      overflow-y: scroll;
      scroll-behavior: smooth;
    }
    .card {
      box-shadow: 2px 2px 10px #855d5d;
      padding-top: 5px;
      padding-bottom: 5px;
      margin-top: 7px;
      margin-bottom: 7px;
      /* display: none; */
    }
    .cardGeneral {
      border-radius: 10px;
      padding-left: 10px;
      padding-right: 10px;
    }
    .currentTutorialStep {
      box-shadow: 2px 2px 10px red;
      margin-top: 3px;
      margin-bottom: 3px;
    }
    /* custom scrollbar */
    ::-webkit-scrollbar {
  width: 1vw;
}
::-webkit-scrollbar-track {
  border-radius: 100vw;
  background: hsla(0, 0%, 72%, 0.19);
  margin-block: 10px;
}
::-webkit-scrollbar-thumb {
  background: hsla(0, 0%, 72%, 0.55);
  border-radius: 100vw;
}
::-webkit-scrollbar-thumb:hover {
  background: hsla(0, 0%, 65%, 0.55);
}
::-webkit-scrollbar-corner {
  background: rgba(0,0,0,0);
}
  </style>
  <div id="tutorial" class="cardGeneral">
    <a id="scrollToTutorial"></a>
    <div class="card cardGeneral">
      <b>Einstellungen während des Tutorials</b>
      <br>
      Sie können fast alle Einstellungen während des Tutorials ändern! Auf die Wichtigen wird zwar im Tutorial aufmerksam gemacht, aber Sie können auch gerne selber reinschauen oder ausprobieren. 
    </div>
    <div id="traditionalTutorial">
      <!-- PC -->
    <div style="display: none;" id="traditionalTutorialPC">
    <div class="card cardGeneral section" id="moveTutorial">
      <h2>Teile bewegen und drehen</h2>
      <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
      <div class="card cardGeneral">
        <b>Informationen zum Teile drehen</b>
        <br>
        Wenn es nicht in den Einstellungen geädert wird, müssen die Teile rotiert werden, um zu passen. Deshalb werden beim Laden eines Bildes oder Videos automatisch die Breite und Höhe angeglichen. Wenn Sie die Breite oder Höhe des Bildes bzw. Videos ändern, können Sie die Teile zwar immer noch drehen, jedoch nur noch an den logischen Seiten miteinander verbinden. 
        <br>
        Zudem können Sie auch in der später erwähnten Teilliste die Teile mit den Pfeiltasten rotieren, während Sie die Maustaste gedrückt haben bzw. auf das Touchpad einen Doppelklick ausgeführt haben. 
      </div>
      <div class="card cardGeneral" id="moveStandardPC">
        <input type="radio" id="moveStyleStandard" onclick="unclippStandard.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {goTutorialSteps(1); automaticTileSelectionReset.checked = !checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', !checked);" name="moveStyle"> <b>Standard</b>
        <div id="tileClickMoveTutorialDiv"><input type="checkbox" id="tileClickMoveTutorial" onclick="checked = !checked"> Klicken Sie auf das gewünschte Teil. </div>
        <div id="moveMouseMoveTutorialDiv"><input type="checkbox" id="moveMouseMoveTutorial" onclick="checked = !checked"> Bewegen Sie dann den Mauszeiger, um das Teil zu bewegen. </div>
        <div id="rotateTileTutorialDiv"><input type="checkbox" id="rotateTileTutorial" onclick="checked = !checked"> Drücken Sie die linke bzw. rechte Pfeiltaste, um das Teil nach links bzw. rechts zu rotieren.</div>
        <div id="clickUnselectMoveTutorialDiv"><input type="checkbox" id="clickUnselectMoveTutorial" onclick="checked = !checked"> Durch einen erneuten Mausklick auf das Teil können Sie es wieder loslassen bzw. abwählen.</div>
      </div>
      <div class="card cardGeneral" id="moveAlternativePC">
        <input type="radio" id="moveStyleAlternative" onclick="unclippAlternative.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {goTutorialSteps(1); automaticTileSelectionReset.checked = checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" name="moveStyle"> <b>Alternative</b>
        <div id="holdMouseMoveTutorialDiv"><input type="checkbox" id="holdMouseMoveTutorial" onclick="checked = !checked"> Halten Sie die Maustaste gedrückt (oder doppelklicken Sie und lassen Sie Ihren Finger auf dem Touchpad).</div>
        <div id="moveMouseMoveTutorialAlternativeDiv"><input type="checkbox" id="moveMouseMoveTutorialAlternative" onclick="checked = !checked"> Bewegen Sie den Mauszeiger, um das Teil zu bewegen. </div>
        <div id="rotateTileTutorialAlternativeDiv"><input type="checkbox" id="rotateTileTutorialAlternative" onclick="checked = !checked"> Drücken Sie die linke bzw. rechte Pfeiltaste, um das Teil nach links bzw. rechts zu rotieren. </div>
        <div id="releaseMoveTutorialDiv"><input type="checkbox" id="releaseMoveTutorial" onclick="checked = !checked"> Lassen Sie die Taste bzw. das Touchpad los. </div>
      </div>
      <div id="moveStyleSettingChosenDiv"><input id="moveStyleSettingChosen" type="checkbox" onclick="checked = !checked"> Wählen Sie oben im Tutorial, ob Sie standardmäßig den Standard oder die Alternative haben wollen. Sie können diese Einstellung jederzeit in dem Einstellungsmenü ändern. </div>
    </div>
      <div class="card cardGeneral section" id="clippTutorial">
      <h2>Teile verbinden und lösen</h2>
      <div class="card cardGeneral" id="connectTiles">
        <h3>Teile verbinden</h3>
        <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div id="clippingInfos">
            <div class="card cardGeneral">
              <b style="font-size: 15px;">Hitboxen</b>
              <br>
              In den Einstellungen haben Sie die Möglichkeit, die Hitboxen zu verkleinern, wodurch Sie näher am Teil sein müssen, damit die Verbindung angeboten wird. Dies kann beispielsweise helfen, wenn Sie mit den vielen Verbindungsvorschlägen überfordert sind oder häufig ausversehen Teile verbinden. Andersrum können Sie die Hitbox auch vergrößern, damit Sie die Teile nicht so weit bewegen müssen.
            </div>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">Verbindungsmöglichkeiten bei Teilkollisionen werden standardmäßig nicht angeboten</b>
            <br>
            Standardmäßig werden Verbindungsmöglichkeiten von Teilen, an dessen Rand ein Teil angeknüpft werden soll und unter einem anderen Teil liegen, nicht angeboten. Falls Sie dies stört, können Sie auch das in den Einstellungen ändern ("Teile an verdeckte Ränder nicht anknüpfen lassen")
          </div>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">nicht passende und richtige markieren</b>
            <br>
            Wenn Teile sich zu ähnlich sind, können Sie diese im Vorfeld entfernen oder nicht passende markieren lassen, wenn eine Verbindung vorgeschlagen wird. 
            <br>
            Standardmäßig wird nur markiert, ob ein Teil richtig ist (alle nötigen Teile drum herum)
          </div>
        </div>
        <div class="card cardGeneral">
        <div id="selectTileConnectTileTutorialDiv"><input type="checkbox" id="selectTileConnectTileTutorial" onclick="checked = !checked"> Wählen Sie ein Teil an. </div>
        <div id="getClippingOptionConnectTileTutorialDiv"><input type="checkbox" id="getClippingOptionConnectTileTutorial" onclick="checked = !checked"> Nähern Sie sich einem anderen Teil. </div>
        <div id="clipTileTutorialDiv"><input type="checkbox" id="clipTileTutorial" onclick="checked = !checked"> Wählen Sie das Teil ab (Finger vom Bildschirm lösen), wenn Sie einen blauen Strich sehen, um es mit dem anderen zu verbinden. </div>
        </div>
        <div id="clippSecondTutorialDiv"><input id="clippSecondTutorial" type="checkbox" onclick="checked = !checked"> Verbinden Sie zwei weiteres Teil zu den bereis verbudenen. </div>
      </div>
      <div class="card cardGeneral section" id="disconnectTiles">
        <h3>Teile lösen</h3>
        <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
        <div class="card cardGeneral">
          <b style="font-size: 15px;">Information Shift Taste</b>
          <br>
          Solange Sie die Shift Taste drücken, können Sie beliebig viele Teile anwählen und diese danach bewegen. Sie können erst wieder abgewählt werden, nachdem Sie die Taste losgelassen haben. 
        </div>
        <div id="moveStyleStandardUnclipp" class="card cardGeneral">
          <input type="radio" onclick="moveStyleStandard.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {tutorial.state = 'selectTileConnectTileTutorial';  automaticTileSelectionReset.checked = !checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', !checked);" id="unclippStandard" name="unclippStyle"><b> Standard (verbunden mit Standard für Bewegen der Teile) </b>
          <div id="pressShiftStandardUnclippTutorialDiv"><input type="checkbox" id="pressShiftStandardUnclippTutorial" onclick="checked = !checked"> Drücken Sie die Shift Taste. </div>
          <div id="selectTileStandardUnclippTutorialDiv"><input type="checkbox" id="selectTileStandardUnclippTutorial" onclick="checked = !checked"> Wählen Sie ein Teil aus (außerhalb des Tutorials beliebige Anzahl möglich), welches mit einem anderen verbunden ist. </div>
          <div id="releaseShiftStandardUnclippTutorialDiv"><input type="checkbox" id="releaseShiftStandardUnclippTutorial" onclick="checked = !checked"> Lassen Sie die Shift Taste los. </div>
          <div id="unclippStandardTutorialDiv"><input type="checkbox" id="unclippStandardTutorial" onclick="checked = !checked"> Bewegen Sie den Mauszeiger, um die Teile zu lösen. </div>
          <div id="unselectUnclippStandardTutorialDiv"><input type="checkbox" id="unselectUnclippStandardTutorial" onclick="checked = !checked"> Klicken Sie, um die ausgewählten Teile abzuwählen. </div>
        </div>
        <div id="moveStyleAlternativeUnclipp" class="card cardGeneral">
          <input type="radio" onclick="moveStyleAlternative.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {tutorial.state = 'selectTileConnectTileTutorial';  automaticTileSelectionReset.checked = checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" id="unclippAlternative" name="unclippStyle"> <b>Alternative (verbunden mit Alternative für Bewegen der Teile)</b>
          <div id="pressShiftAlternativeUnclippTutorialDiv"><input type="checkbox" id="pressShiftAlternativeUnclippTutorial" onclick="checked = !checked"> Drücken Sie die Shift Taste. </div>
          <div id="selectTileAlternativeUnclippTutorialDiv"><input type="checkbox" id="selectTileAlternativeUnclippTutorial" onclick="checked = !checked"> Wählen Sie ein Teil aus (außerhalb des Tutorials beliebige Anzahl möglich, Maustaste drücken und halten oder Doppelklick auf Touchpad). Das Teil muss mit mindestens einem weiteren verbunden sein, damit es von diesem abgetrennt werden kann.  </div>
          <div id="unclippTileAlternativeUnclippTutorialDiv"><input type="checkbox" id="unclippTileAlternativeUnclippTutorial" onclick="checked = !checked"> Bewegen Sie den Mauszeiger, um die Teile zu lösen. </div>
          <div id="releaseShiftAlternativeUnclippTutorialDiv"><input type="checkbox" id="releaseShiftAlternativeUnclippTutorial" onclick="checked = !checked"> Lassen Sie die Shift Taste los. </div>
          <div id="unselectAlternativeUnclippTutorialDiv"><input type="checkbox" id="unselectAlternativeUnclippTutorial" onclick="checked = !checked"> Lassen Sie das Touchpad bzw. die Maustaste los, um das Teil abzuwählen. </div>
        </div>
      </div>
    </div>
    <div class="card cardGeneral section" id="generalSkills">
      <h2>allgemeine Fertigkeiten</h2>
      <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
      <div class="card cardGeneral">
        <h3>Zoomen</h3>
        Wie auch auf jeder anderen Website, können Sie rein- und rauszoomen. Das Übliche ist Str. + "-" zum Rauszoomen und Str. + "+" zum Reinzoomen (es kann auch das Mausrad statt plus und minus benutzt werden). Dadurch können Sie das "Spielfeld" besser überblicken, haben jedoch auch kleinere Teile und umgekehrt. 
      </div>
      <div id="scrollTutorial" class="card cardGeneral">
        <b style="font-size: 21px;">scroling</b>
        <br>
        <div class="card cardGeneral" id="manualScrollingTutorial">
          <h3>manuell scrollen</h3>
          <div id="selectTileScrollingTutorialDiv"><input type="checkbox" id="selectTileScrollingTutorial" onclick="checked = !checked">Teil anwählen (wenn Sie 2 Finger Geste nutzen wollen mit der linken Maustaste)</div> 
          <div id="manuallyScrollingTutorialDiv"><input type="checkbox" id="manuallyScrollingTutorial" onclick="checked = !checked">scrollen (z.B. mit 2 Finger Geste auf dem Touchpad oder mit dem Mausrad)</div> 
          <div id="unselectTileScrollingTutorialDiv"><input type="checkbox" id="unselectTileScrollingTutorial" onclick="checked = !checked">Teil abwählen</div> 
        </div>
        <div class="card cardGeneral" id="autoScrollTutorial">
          <h3>automatisch scrollen</h3>
          <div id="selectTileAutomaticScrollingTutorialDiv"><input type="checkbox" id="selectTileAutomaticScrollingTutorial" onclick="checked = !checked">Teil anwählen</div> 
          <div id="automaticScrollingTutorialDiv"><input type="checkbox" id="automaticScrollingTutorial" onclick="checked = !checked">Teil so weit nach unten schieben, dass mehr als die Hälfte des Teils den Bildschirm verlassen hat (außerhalb des tutorials alle Richtungen möglich)</div> 
          <!-- TODO: vom Rand weg bewegen -->
          <div id="stopScrollingAutomaticScrollingTutorialDiv"><input type="checkbox" id="stopScrollingAutomaticScrollingTutorial" onclick="checked = !checked">Teil abwählen oder vom Rand weg bewegen, um das Scrolling zu stoppen</div> 
        </div>
      </div>
    </div>
      <div class="card cardGeneral section" id="tileSelectionBarTutorial">
        <h3>Die Teilliste</h3>
        <div class="card cardGeneral">
          <b>Informationen zur aufbereitung der Teile (ink. Teilliste)</b>
          <br>
          In den Einstellungen können Sie auswählen, wie die Teile aufbereitet werden. Sie können verteil werden (mit Überlappen), in die Teilliste gebracht werden, um die es im Folgenden geht, oder auf dem Spielfeld nebeneinander gelegt werden. Zudem können Sie mit leerer Liste starten, sodass Sie die Teile sortiert dort ablegen oder auf dem Spielfeld behalten können. 
        </div>
        <div class="card cardGeneral">
          <b>zusätzliche Einstellungen</b>
          <br>
          Für die Teilliste gibt es zusätzliche Einstellungen, die Sie jetzt einsehen können. 
        </div>
        <div class="card cardGeneral" id="controlTileBarScrollTutorial">
          <h3>Scrolling in der Teilliste</h3>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div id="scrollArrowTileBarTutorialDiv"><input type="checkbox" id="scrollArrowTileBarTutorial" onclick="checked = !checked">Scrollen durch Anklicken der roten (halbtransparenten) Pfeile an den Rändern des Bildschirms (werden sichtbarer, wenn man sie mit der Maus berührt)</div> 
          <div class="card cardGeneral" id="scrollWithMouse">
            <h4 id="scrollTilelistSwipeTutorial">Scrollen mit der Maustaste</h4>
            <div id="MouseDownScrollTileBarTutorialDiv"><input type="checkbox" id="MouseDownScrollTileBarTutorial" onclick="checked = !checked">Maustaste drücken oder auf Touchpad doppelklicken und gedrückt halten bzw. Finger auf Touchpad lassen</div> 
            <div id="moveMouseScrollTileSelectionBarTutorialDiv"><input type="checkbox" id="moveMouseScrollTileSelectionBarTutorial" onclick="checked = !checked">Zeiger bewegen, um die Liste in die entsprechende Richtung zu bewegen </div> 
            <div id="stopScrollingTileBarTutorialDiv"><input type="checkbox" id="stopScrollingTileBarTutorial" onclick="checked = !checked">Maustaste bzw. Touchpad loslassen</div> 
          </div>
          <div id="ScrollkeyTileBarTutorialDiv"><input type="checkbox" id="ScrollkeyTileBarTutorial" onclick="checked = !checked">Scrollen durch drücken der linken bzw. rechten Pfeiltaste (Mauszeiger muss auf Liste sein)</div> 
        </div>
        <div class="card cardGeneral section" id="leaveTileBarTutorial">
          <h3>Teile auf "Spielfeld" bringen</h3>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">automatisch nächste Teil auswählen</b>
            <br>
            Am PC wird standardmäßig das nächste Teil in der Teilliste ausgewählt, am Handy nicht. Solange Sie auf dem "Spielfeld" ein Teil angewählt haben, wird kein Teil aus der Teilliste genommen. Sie können auch dies in den Einstellungen ändern. 
          </div>
          <div class="card cardGeneral" id="leaveTileBarTutorial">
            <div id="selectTileBarTileTutorialDiv"><input type="checkbox" id="selectTileBarTileTutorial" onclick="checked = !checked">Klicken Sie auf ein Teil in der Liste, um es anzuwählen.</div> 
            <div id="placeTileOnFiledTutorialDiv"><input type="checkbox" id="placeTileOnFiledTutorial" onclick="checked = !checked">Klicken Sie auf das "Spielfeld", um das Teil dort "abzulegen". </div> 
            <div id="unselecTileAfterTileBarTilePlacementTutorialDiv"><input type="checkbox" id="unselecTileAfterTileBarTilePlacementTutorial" onclick="checked = !checked">Wählen Sie das Teil ab.</div> 
          </div>
          <div id="SecondPlaceTileTutorialDiv"><input type="checkbox" id="SecondPlaceTileTutorial" onclick="checked = !checked">Legen Sie ein weiteres Teil auf dem Spielfeld ab.</div> 
        </div>
        <div class="card cardGeneral section" id="backToBarTutorial">
          <h3>Teile zurück in Teilliste bringen</h3>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div class="card cardGeneral" id="backToBarPlusBTutorial">
            <h4>mit "+"-Button</h4>
            <div id="BackToTileBarTutorialDiv"><input type="checkbox" id="BackToTileBarTutorial" onclick="checked = !checked">Klicken Sie auf einen der "+"-Bottons</div> 
            <div id="backToTileBarPlusBTutorialDiv"><input type="checkbox" id="backToTileBarPlusBTutorial" onclick="checked = !checked">Klicken Sie auf ein Teil, um es an der ausgewählten Stelle zurück in die Teilliste zu bringen. </div> 
          </div>
          <div class="card cardGeneral" id="backToBarBTutorial">
            <h4>mit "zurück in Leiste"-Button</h4>
            <div id="selectTileTileBarZurückInLeisteTutorialDiv"><input type="checkbox" id="selectTileTileBarZurückInLeisteTutorial" onclick="checked = !checked">Wählen Sie ein Teil in der Teilleiste an. Rechts von dem ausgewählten Teil wird das neue Teil eingereiht werden. </div> 
            <div id="clickBackToBarBTurotialDiv"><input type="checkbox" id="clickBackToBarBTurotial" onclick="checked = !checked">Klicken Sie auf den "zurück in Leiste"-Botton (oben links auf dem Bildschirm, lässt sich nur aktivieren, wenn ein Teil auf dem "Spielfeld" liegt). </div> 
            <div id="selectBackToBarTileZurückInLeisteTutorialDiv"><input type="checkbox" id="selectBackToBarTileZurückInLeisteTutorial" onclick="checked = !checked">Klicken Sie das Teil an, das Sie zurückholen wollen. </div> 
            <div class="card cardGeneral">
              <b style="font-size: 15px;">automatische Positionsauswahl</b>
              <br>
              Wenn Sie kein Teil ausgewählt haben und trotdem den Button drücken, wird das danach ausgewähle Teil an das Ende der Liste angehängt. 
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Handy -->
    <div id="traditionalTutorialHandy" style="display: none;">
      <div class="card cardGeneral section" id="moveTutorial">
        <h2>Teile bewegen</h2>
        <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
        <div class="card cardGeneral">
          <div id="selectTileMobileTurorialDiv"><input type="checkbox" id="selectTileMobileTurorial" onclick="checked = !checked"> Legen Sie Ihren Finger auf ein Teil. </div>
          <div id="moveTileMobileTutorialDiv"><input type="checkbox" id="moveTileMobileTutorial" onclick="checked = !checked"> Bewegen Sie dann den Finger, um das Teil zu bewegen. </div>
          <div id="releaseTileMobileTutorialDiv"><input type="checkbox" id="releaseTileMobileTutorial" onclick="checked = !checked"> Heben Sie den Finger vom Bildschirm an, um das Teil abzuwählen. </div>
        </div>
      </div>
        <div class="card cardGeneral section" id="clippTutorial">
        <h2>Teile verbinden und lösen</h2>
        <div class="card cardGeneral" id="connectTiles">
          <h3>Teile verbinden</h3>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div id="clippingInfosMobile"></div>
          <div class="card cardGeneral">
          <div id="selectTileConnectTileMobileTutorialDiv"><input type="checkbox" id="selectTileConnectTileMobileTutorial" onclick="checked = !checked"> Wählen Sie ein Teil an. </div>
          <div id="getClippingOptionConnectTileMobileTutorialDiv"><input type="checkbox" id="getClippingOptionConnectTileMobileTutorial" onclick="checked = !checked"> Nähern Sie sich einem anderen Teil. </div>
          <div id="clipTileMobileTutorialDiv"><input type="checkbox" id="clipTileMobileTutorial" onclick="checked = !checked"> Wählen Sie das Teil ab, wenn Sie einen blauen Strich sehen, um es mit dem anderen zu verbinden. </div>
          </div>
          <div id="clippSecondMobileTutorialDiv"><input id="clippSecondMobileTutorial" type="checkbox" onclick="checked = !checked"> Verbinden Sie drei weitere Teile zu den bereits verbundenen. </div>
        </div>
        <div class="card cardGeneral section" id="disconnectTiles">
          <h3>Teile lösen</h3>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">Allgemeiner Hinweis</b>
            <br>
            Wenn Sie Probleme mit dem Anklicken der Elemente oben in der leiste haben (scrollen, rotieren, Shift Taste), versuchen Sie, ein wenig weiter unten zu klicken, selbst wenn Sie außerhalb des angezeigten Elements klicken, kann das genau die richtige Stelle für das Klicken sein. 
          </div>
          <div class="card cardGeneral">
            <b style="font-size: 15px;">Information Shift Taste</b>
            <br>
            Solange Sie die Shift Taste drücken, können Sie beliebig viele Teile anwählen und diese danach bewegen. Sie können erst wieder abgewählt werden, nachdem Sie die Taste losgelassen haben. 
          </div>
          <div class="card cardGeneral">
            <div id="pressShiftMobileUnclippTutorialDiv"><input type="checkbox" id="pressShiftMobileUnclippTutorial" onclick="checked = !checked"> Drücken Sie die "Shift Taste". </div>
            <div id="selectTileMobileShiftUnclippTutorialDiv"><input type="checkbox" id="selectTileMobileShiftUnclippTutorial" onclick="checked = !checked"> Legen Sie den Finger auf ein Teil, welches mit einem anderen verbunden ist. </div>
            <div id="moveTileShiftUnclippTutorialDiv"><input type="checkbox" id="moveTileShiftUnclippTutorial" onclick="checked = !checked"> Bewegen Sie ein Teil mit dem Finger. </div>
            <div id="releaseFingerMobileShiftTutorialDiv"><input type="checkbox" id="releaseFingerMobileShiftTutorial" onclick="checked = !checked"> Lassen Sie den Finger wieder vom Bildschrim los.</div>
          </div>
          <div class="card cardGeneral">
            <b>Mehrfachauswahl (auch ohne Abtrennen möglich)</b>
            <br>
            <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
            <br>
            <div id="pressShiftMobileMultipleUnclippTutorialDiv"><input type="checkbox" id="pressShiftMobileMultipleUnclippTutorial" onclick="checked = !checked"> Drücken Sie die "Shift Taste". </div>
            <div id="selectTileMobileShiftMultipleUnclippTutorialDiv"><input type="checkbox" id="selectTileMobileShiftMultipleUnclippTutorial" onclick="checked = !checked"> Klicken Sie auf zwei Teile, welche miteinander verbunden sind und eine Verbindung zu einem weiteren Teil haben (außerhalb des Tutorials beliebige Anzahl möglich), die Sie von dem Rest abtrennen wollen. </div>
            <div id="moveTileShiftMultipleUnclippTutorialDiv"><input type="checkbox" id="moveTileShiftMultipleUnclippTutorial" onclick="checked = !checked"> Bewegen Sie eins der ausgewähltenTeile mit dem Finger. </div>
            <div id="releaseFingerMobileMultiShiftTutorialDiv"><input type="checkbox" id="releaseFingerMobileMultiShiftTutorial" onclick="checked = !checked"> Lassen Sie den Finger wieder vom Bildschrim los.</div>
          </div>
          <div class="card cardGeneral">
            <div id="twoFingersDownUnclippTutorialDiv"><input type="checkbox" id="twoFingersDownUnclippTutorial" onclick="checked = !checked"> Legen Sie zwei Finger auf das Teil, das Sie lösen wollen. (muss mit mindestens einem weiteren Teil verbunden sein)</div>
            <div id="releaseTwoFingersUnclippTutorialDiv"><input type="checkbox" id="releaseTwoFingersUnclippTutorial" onclick="checked = !checked"> Lassen Sie die Finger wieder vom Bildschirm los. </div>
            <div id="selectTileMobileTwoFingersUnclippTutorialDiv"><input type="checkbox" id="selectTileMobileTwoFingersUnclippTutorial" onclick="checked = !checked"> Legen Sie den Finger auf das abgelöste Teil. </div>
            <div id="moveTileTwoFingersUnclippTutorialDiv"><input type="checkbox" id="moveTileTwoFingersUnclippTutorial" onclick="checked = !checked"> Bewegen Sie das abgelöste Teil mit dem Finger. </div>
            <div id="releaseFingerMobileTwoFingersTutorialDiv"><input type="checkbox" id="releaseFingerMobileTwoFingersTutorial" onclick="checked = !checked"> Lassen Sie den Finger wieder vom Bildschrim los.</div>
          </div>
        </div>
      </div>
      <div class="card cardGeneral section" id="generalSkills">
        <h2>allgemeine Fertigkeiten</h2>
        <div id="scrollTutorial" class="card cardGeneral">
          <b style="font-size: 21px;">scrollen und zoomen</b>
          <br>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <br>
          <div class="card cardGeneral" id="manualScrollingTutorial">
            <h3>manuell scrollen und zoomen</h3>
            <div class="card cardGeneral">
              <b style="font-size: 15px;">auf leerem Hintergrund</b>
              <br>
              In den Einstellungen haben Sie die Möglichkeit auszustellen, dass Sie auf leerem bzw. weißem Hintergrund immer scrollen können (ohne den Haken bei "scroll" zu setzen)
            </div>
            <div id="selectScrollScrollingTutorialDiv"><input type="checkbox" id="selectScrollScrollingTutorial" onclick="checked = !checked">Wählen Sie "scroll" an</div> 
            <div id="scrollMobileScrollingTutorialDiv"><input type="checkbox" id="scrollMobileScrollingTutorial" onclick="checked = !checked">Scrollen Sie</div> 
            <div id="zoomInTutorialDiv"><input type="checkbox" id="zoomInTutorial" onclick="checked = !checked">zoomen Sie rein (ohne Haken bei "scroll nicht möglich")</div> 
            <div id="zoomOutTutorialDiv"><input type="checkbox" id="zoomOutTutorial" onclick="checked = !checked">zoomen Sie so weit raus wie möglich (ohne Haken bei "scroll nicht möglich")</div> 
            <div id="unselectScrollScrollingTutorialDiv"><input type="checkbox" id="unselectScrollScrollingTutorial" onclick="checked = !checked">Wählen Sie "scroll" ab</div> 
          </div>
          <div id="autoScrollMobileTutorial"></div>
        </div>
        <div class="card cardGeneral section">
          <h3>rotieren</h3>
          <button onclick="goToTutorialIndex(this);">hier beginnen oder fortfahren</button>
          <div class="card cardGeneral">
            <b>Informationen zum Teile drehen</b>
            <br>
            Wenn es nicht in den Einstellungen geädert wird, müssen die Teile rotiert werden, um zu passen. Deshalb werden beim Laden eines Bildes oder Videos automatisch die Breite und Höhe angeglichen. Wenn Sie die Breite oder Höhe des Bildes bzw. Videos ändern, können Sie das Teil zwar immer noch drehen, jedoch nur noch an den logischen Seiten miteinander verbinden. 
            <br>
            Zudem können Sie nach Aktivieren der Rotierfunktion oben in der Leiste auch in der später erwähnten Teilleiste durch Anklicken der Teile rotieren, bis Sie die Funktion abgewählt haben. 
          </div>
          <div id="activateRotateLeftTutorialDiv"><input type="checkbox" id="activateRotateLeftTutorial" onclick="checked = !checked"> Rotieren nach links aktivieren.</div>
          <div id="rotateLeftMobileTutorialDiv"><input type="checkbox" id="rotateLeftMobileTutorial" onclick="checked = !checked"> Teil(e) anklicken, die Sie rotieren wollen.</div>
          <div id="activateRotateRightTutorialDiv"><input type="checkbox" id="activateRotateRightTutorial" onclick="checked = !checked"> Rotieren nach rechts aktivieren.</div>
          <div id="rotateRightMobileTutorialDiv"><input type="checkbox" id="rotateRightMobileTutorial" onclick="checked = !checked"> Teil(e) anklicken, die Sie rotieren wollen.</div>
          <div id="deactivateRotateRightTutorialDiv"><input type="checkbox" id="deactivateRotateRightTutorial" onclick="checked = !checked"> Rotieren nach rechts deaktivieren.</div>
        </div>
      </div>
      <div id="tileSelectionBarMobileTutorial"></div>
    </div>
    <div id="completePuzzleTutorialDiv" class="section">
      <input type="checkbox" id="completePuzzleTutorial" onclick="checked = !checked">Vervollständigen Sie das Puzzle.
    </div>
</div>
<div id="exchangeTutorial" style="display: none;" class="cardGeneral">
  <div class="card cardGeneral section">
    <h1>Teile austauschen</h1>
    <div class="card cardGeneral">
      <div id="moveStyleStandardExchangeDiv" class="card cardGeneral">
        <input type="radio" id="moveStyleStandardExchange" onclick="localStorage.setItem('swipeExchangePuzzleCreator', !checked);" name="moveStyle">
      <b>Standard Steuerung</b>
      <div id="selectFirstExchangeNormalTutorialDiv"><input type="checkbox" id="selectFirstExchangeNormalTutorial" onclick="checked = !checked"> Klicken Sie das erste auszutauschende Teil an.</div>
      <div id="selectSecondExchangeNormalTutorialDiv"><input type="checkbox" id="selectSecondExchangeNormalTutorial" onclick="checked = !checked"> Klicken Sie das zweite Teil an, um es anzuwählen. und die beiden gewählten Teile auszutauschen. </div>
    </div>
    <div id="moveStyleAlternativeExchange" class="card cardGeneral">
      <input type="radio" onclick="localStorage.setItem('swipeExchangePuzzleCreator', !checked);" name="moveStyle">
      <b>Alternative Steuerung (hier Standard Steuerung auch nutzbar bzw. enthalten)</b>
      <div id="mouseDownSelectFirstExchangeAlternativeTutorialDiv"><input type="checkbox" id="mouseDownSelectFirstExchangeAlternativeTutorial" onclick="checked = !checked"> Drücken Sie die Maustaste bzw. den Finger auf den Bildschirm und halten Sie gedrückt.</div>
      <div id="mouseMoveExchangeAlternativeTutorialDiv"><input type="checkbox" id="mouseMoveExchangeAlternativeTutorial" onclick="checked = !checked"> Bewegen Sie die Maus bzw. den Finger zum Teil, mit dem Sie das zuerst angewählte austauschen wollen.</div>
      <div id="mouseUpExchangeAlternativeTutorialDiv"><input type="checkbox" id="mouseUpExchangeAlternativeTutorial" onclick="checked = !checked"> Lassen Sie die Maustaste bzw. den Bildschirm los.</div>
    </div>
    <h1>Auswahl abwählen</h1>
    <div id="standardUnselectExchangeTutorial" class="card cardGeneral">
      <b>Standard Steuerung</b>
      <div id="selectTileUnselectStandardTutorialDiv"><input type="checkbox" id="selectTileUnselectStandardTutorial" onclick="checked = !checked"> Klicken Sie das erste auszutauschende Teil an.</div>
      <div id="unselectTileUnselectStandardTutorialDiv"><input type="checkbox" id="unselectTileUnselectStandardTutorial" onclick="checked = !checked"> Klicken Sie es erneut an, um es wieder abzuwählen. </div>
    </div>
    <div id="alternativeUnselectExchangeTutorial" class="card cardGeneral">
      <b>Alternative Steuerung (hier Standard Steuerung auch nutzbar bzw. enthalten)</b>
        <div id="mouseDownUnselectAlternativeTutorialDiv"><input type="checkbox" id="mouseDownUnselectAlternativeTutorial" onclick="checked = !checked"> Drücken Sie die Maustaste bzw. den Finger auf den Bildschirm und halten Sie gedrückt.</div>
        <div id="moveMouseOutUnselectAlternativeTutorialDiv"><input type="checkbox" id="moveMouseOutUnselectAlternativeTutorial" onclick="checked = !checked"> Bewegen Sie die Maus bzw. den Finger auf ein anderes Teil.</div>
        <div id="moveMouseInUnselectAlternativeTutorialDiv"><input type="checkbox" id="moveMouseInUnselectAlternativeTutorial" onclick="checked = !checked"> Bewegen Sie die Maus bzw. den Finger auf das zuerst ausgewählte Teil.</div>
        <div id="releaseMouseUnselectAlternativeTutorialDiv"><input type="checkbox" id="releaseMouseUnselectAlternativeTutorial" onclick="checked = !checked"> Lassen Sie auf dem Teil, auf dem Sie angefangen haben wieder los, um die Auswahl abzuwählen.</div>
        <div class="card cardGeneral">
          Wenn Sie sich noch auf dem als erstes ausgewählen Teil befinden, können Sie auch die Maustaste bzw. den Finger sofort loslassen und erneut klicken, um das Teil abzuwählen. 
        </div>
    </div>
  </div>
</div>
</div>
<div id="schiebenTutorial" style="display: none;" class="cardGeneral">
  <div class="card cardGeneral section">
    <h1>Teile schieben</h1>
    <div class="card cardGeneral">
      <b>Schieben eine Option</b>
      <div id="schiebenNormalTurorialDiv"><input type="checkbox" id="schiebenNormalTurorial" onclick="checked = !checked"> Klicken Sie ein Teil neben der Lücke an, um es in die Lücke zu schieben.</div>
    </div>
    <div id="moveMultipleOptionsSchiebenTutorial" class="card cardGeneral">
      <b>Schieben mehrere Optionen</b>
      <div id="schiebenSelectTileMoveMultipleTurorialDiv"><input type="checkbox" id="schiebenSelectTileMoveMultipleTurorial" onclick="checked = !checked"> Wenn Sie ein Teil in mehrere Lücken verschieben können, müssen Sie <b>erneut zuerst das Teil anwählen</b>.</div>
      <div id="schiebenSelectGapMoveMultipleTurorialDiv"><input type="checkbox" id="schiebenSelectGapMoveMultipleTurorial" onclick="checked = !checked"> Nun müssen Sie jedoch zusätzlich auf die Lücke klicken, in die das Teil geschoben werden soll.</div>
    </div>
    <div class="card cardGeneral">
      <b>Informationen Einstellungen</b>
      <div class="card cardGeneral">
        <b>Züge rückgängig machen</b>
        <br>
        In den Einstellungen können Sie Ihre Züge rückgängig machen und zuvor wählen, ob die dafür notwendigen Züge für die Statistik zählen sollen. 
      </div>
      <div class="card cardGeneral">
        <b>Züge des PC angucken</b>
        <br>
        Zudem können Sie sich angucken, wie der PC das Puzzle löst. Er nimmt zwar nicht immer die kürzeste Route, aber immerhin weiß er eine. Wenn sie sich mit Ihrer überschneidet, können Sie sogar ab Ihrer Position im Spiel gucken, wie man das Puzzle lösen kann. 
      </div>
    </div>
  </div>
</div>
</div>
<script>
    window.onbeforeunload = function(){
    console.log("Leave Website");
      return 'Are you sure you want to leave?';
  };
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
    automaticTileSelectionReset.checked = true;
    automaticTileSelectionReset.style.display = 'none';
    // tileSelectionCanvas.style.position = "fixed";
    autoScrollMobileTutorial.appendChild(autoScrollTutorial);
    tileSelectionBarMobileTutorial.appendChild(tileSelectionBarTutorial);
    clippingInfosMobile.appendChild(clippingInfos);
    MouseDownScrollTileBarTutorialDiv.innerHTML = MouseDownScrollTileBarTutorialDiv.innerHTML.split('>')[0] + ">Finger auf Teilliste legen";
    moveMouseScrollTileSelectionBarTutorialDiv.innerHTML = moveMouseScrollTileSelectionBarTutorialDiv.innerHTML.split('>')[0] + ">Finger bewegen, um die Liste in die entsprechende Richtung zu bewegen ";
    stopScrollingTileBarTutorialDiv.innerHTML = stopScrollingTileBarTutorialDiv.innerHTML.split('>')[0] + ">Finger vom Bildschirm entfernen";
    scrollTilelistSwipeTutorial.innerHTML = "Scrollen durch Swipen";
    ScrollkeyTileBarTutorialDiv.remove();
  } else {
    var gerät = "PC"
    console.log("PC");
    swipeSteuerungP.innerHTML = swipeSteuerungP.innerHTML.replace('beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen', 'drücken Sie die Maustaste runter oder vollführen Sie einen Doppelklick beim ersten Teil und lassen Sie beim 2. Teil los. ');
    scrollOnBlancP.style.display = "none";
    vibrateA.style.display = "none";
  }
  exchangeTutorial.id += gerät;
  schiebenTutorial.id += gerät;
  gapSizeChanged(tilesGap.value);
  expandBottom.style.height = window.innerWidth/29;
  expandTop.style.height = window.innerWidth/29;
  expandLeft.style.width = window.innerWidth/29;
  expandRight.style.width = window.innerWidth/29;
  mobileControls.style.display = 'none';
  reloadWhenFinished.checked = JSON.parse(localStorage.getItem("reloadWhenFinished"));
  anzahlVerschieben.value = anzahlX.value*anzahlY.value;
  aufgebenId.style.display = "none";
  // schiebenSettings.style.display  = "inline"
  randSettings.style.display = "none";
  schiebenSettings.style.display = "none";
  größeAnpassenX.max = window.innerWidth
  größeAnpassenY.max = window.innerHeight
  var canvas = textur.getContext('2d');
  if (localStorage.getItem('tutorialAskedPuzzleCreatortraditional') != "true" && localStorage.getItem('tutorialAskedPuzzleCreatorexchange') != "true" && localStorage.getItem('tutorialAskedPuzzleCreatorschieben') != "true" && confirm('Sie haben dieses Spiel anscheinend noch nie gespielt. Wollen Sie das Tutorial zur Einführung spielen? Alternativ können Sie die einzelnen Bestandteile des Tutorials (wegen Einstellungsmöglichkeiten nicht alle Bestandteile vorhanden) direkt während Sie Ihr erstes Puzzle spielen in der Reihenfolge spielen, in der es Ihnen passt ("Steuerung anzeigen")! Wenn Sie auf "OK" o.ä. klicken, werden Sie als zu dem kompletten Tutorial zum Modus "traditional" gelangen, wenn Sie auf "abbrechen" o.ä. klicken, können Sie Ihr Puzzle spielen. ')) {
    setTimeout(() => {
      setupTutorial();
    }, 100);
  }
  // section 1: mainly change element style and visibility
  function emptyTileBarShuffleStyleSelected(value) {
    if (value == 'nextToEachOther' && emptyTileBar.checked) tilesGapS.style.display = 'block'; 
    else tilesGapS.style.display = 'none';
  }
  function rotateLeftModeChanged() {
    if (state.rotateLeft) rotatesLeft.checked = false; 
    state.rotateLeft = JSON.parse(JSON.stringify(rotatesLeft.checked));
    state.rotateRight = false;
    if ((tutorial.state == 'activateRotateLeftTutorial' && rotatesLeft.checked)) goTutorialSteps(1); 
    if (tutorial.state == 'rotateLeftMobileTutorial' && !rotatesLeft.checked) goTutorialSteps(-1);
  }
  function rotateRightModeChanged() {
    if (state.rotateRight) rotatesRight.checked = false;
    state.rotateRight = JSON.parse(JSON.stringify(rotatesRight.checked)); 
    state.rotateLeft = false;
    if ((tutorial.state == 'activateRotateRightTutorial' && rotatesRight.checked) || (tutorial.state == 'deactivateRotateRightTutorial' && !rotatesRight.checked)) goTutorialSteps(1); 
    if (tutorial.state == 'rotateRightMobileTutorial' && !rotatesRight.checked) goTutorialSteps(-1);
  }
  function hexTorgb(hex) {
    return ['0x' + hex[1] + hex[2] | 0, '0x' + hex[3] + hex[4] | 0, '0x' + hex[5] + hex[6] | 0];
  }
  function checkOut(closeAnyway) {
    var stillIn = false;
      for (var elm of document.getElementsByClassName('dropdown-content')[0].children) {
        if (window.getComputedStyle(elm).backgroundColor == "rgb(221, 221, 221)") stillIn = true;
      }
    if (!stillIn || closeAnyway) document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function shuffleStyleVisibilities(value) {
    if (value == 'nextToEachOther') {
      shuffleStyleTileGap.appendChild(tilesGapS);
      tilesGapS.style.display = 'block'; 
    }
    else tilesGapS.style.display = 'none';
    if (value == "listTiles") document.getElementById('EmptyTileBarDiv').style.display = "block";
    else document.getElementById('EmptyTileBarDiv').style.display = "none";
    if (value == "overlapTiles") shuffleHeadline.style.display = 'none';
    else shuffleHeadline.style.display = 'inline';
    if (value == 'listTiles' && emptyTileBar.checked) {
      emptyTileBarSettings.style.display = 'block';  
      if (shuffleStyleBar.value == "nextToEachOther") {
        emptyTilebarTileGap.appendChild(tilesGapS);
        tilesGapS.style.display = 'block';
      }
    }
    else emptyTileBarSettings.style.display = 'none';
  }
  function backToBarVis(checked) {
    if (checked) {
      backToBarButtons.style.display = 'inline';
      backToBarBSize.style.display = 'inline';
    }
    else {
      backToBarButtons.style.display = 'none';
      backToBarBSize.style.display = 'none';
    }
  }
  function showTitle(id, display) {
    id = id.replace('Symbol', 'Title');
    if (id != "rotateLeftTitle") rotateLeftTitle.style.display = 'none'; 
    if (id != "rotateRightTitle") rotateRightTitle.style.display = 'none'; 
    if (id != "selectMultipleTitle") selectMultipleTitle.style.display = 'none'; 
    if (id != "swipeTitle") swipeTitle.style.display = 'none'; 
    if (document.getElementById(id).style.display == "inline") document.getElementById(id).style.display = "none";
    else {
      document.getElementById(id).style.display = "inline";
      setTimeout(function () {
        document.getElementById(id).style.display = "none";
      }, 5000);
    }
  }
  function changeSettingsVis(vis) {
    if ((settings.style.display == 'none' || vis == "inline") && vis != "none") {
      settings.style.display = 'block'; 
      document.getElementById('tutorial').style.display = "none";
      selectBackToBarB.style.display = 'none';
      if (!state.removeTile && aufgebenId.style.display == "inline") wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
    }
    else {
      if (tutorial.state != "") {
        document.getElementById('tutorial').style.display = "inline";
        setTimeout(() => {
          tutorialSteps = Array.from(document.getElementById('tutorial').querySelectorAll('input[type="checkbox"]')).filter(x => x.offsetWidth > 0 || x.offsetHeight > 0);
          tutorial.index = 0;
          while (tutorialSteps.filter(x => document.getElementById(x.id + 'Div').className.includes('currentTutorialStep')).length > 0 && tutorialSteps[tutorial.index] && !document.getElementById(tutorialSteps[tutorial.index].id + "Div").className.includes('currentTutorialStep')) {
            tutorial.index++;
          }
          if (tutorialSteps[tutorial.index]) tutorial.state = tutorialSteps[tutorial.index].id;
          goTutorialSteps(0)
        }, 777);
      }
      settings.style.display = 'none';
      if (['inline', ''].includes(tileSelectionCanvas.style.display))  selectBackToBarB.style.display = "inline"
      originalDisplayChanged(false);
      canvas = textur.getContext('2d');
      if (wrongPosition && !state.changedPos) positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
      state.changedPos = false; 
    }
    if (modeSelection.value == "traditional") adaptExpandButtonPosition();
    texturTop = textur.getBoundingClientRect().top + scrollY;
  }
  function adaptExpandButtonPosition() {
    setTimeout(() => {
      if (settings.style.display == "block") expandTop.style.top = settings.getBoundingClientRect().bottom + scrollY + 17;
      else expandTop.style.top = showSettings.getBoundingClientRect().bottom + scrollY + 17;
      textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY;
      texturTop = textur.getBoundingClientRect().top + scrollY;
      expandRight.style.top = textur.getBoundingClientRect().top + scrollY;
      expandLeft.style.top = textur.getBoundingClientRect().top + scrollY;
      expandBottom.style.top = textur.getBoundingClientRect().top + scrollY;
      // update canvas and expand buttons position
      expandSide();
      textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
    }, 10);
  }
  function mirrorCanvas(checked) {
    if (checked) textur.style = "-webkit-transform: scaleX(-1); transform: scaleX(-1);";
    else {
      textur.style.transform = "";
      textur.style.webkitTransform = "";
    }
  }
  // change visibility of player of PC movement in schieben mode
  function changeMovementPlayerVis(checked) {
    if (checked) {
      innerMovementPlayer.style.display = 'inline'; 
      playMovementPos(getPlayerPosition(true));
      texturTop = textur.getBoundingClientRect().top + scrollY;
      movementPlayer.scrollIntoView();
      window.scroll(0, scrollY);
    }
    else {
      innerMovementPlayer.style.display = 'none';
      texturTop = textur.getBoundingClientRect().top + scrollY;
      canvas = textur.getContext('2d');
    }
  }
  // change size of + buttons for backToBar
  function changeBackToBarB(side, value) {
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var button = document.getElementsByClassName('backToTileB')[i];
      button.style[side] = value + 'px';
      button.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2 + 'px';
      button.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(button.style.width)/2 + 'px';
    }
  }
  // change play direction of movement player (player which shows the moves the PC did in schieben mode)
  function changeMovementDirection(direc) {
    objMovementPlayer.direc = direc;
    movementDirectionLeft.style.backgroundColor = '';
    movementDirectionRight.style.backgroundColor = '';
    if (direc == -1) movementDirectionLeft.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
    else movementDirectionRight.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
  }
  function changeTileBarHeight(value) {
    tileBarHeight.value = value;
    tileSelectionCanvas.style.height = JSON.parse(value) + 'px';
    // tileSelectionBar.pictureSize = {width: JSON.parse(value - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)};
    // if (!lengthPerTeil.sizeAdapted) lengthPerTeil.sizeAdapted = JSON.parse(JSON.stringify(lengthPerTeil.edit));
    // tileSelectionBar.pictureSize = {width: lengthPerTeil.edit.x - (Math.abs(lengthPerTeil.edit.y - (JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.y)))), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.y)};
    // tileSelectionBar.pictureSize = {width: lengthPerTeil.edit.x - (Math.abs(lengthPerTeil.edit.y - (JSON.parse(value) - 10))), height: JSON.parse(value) - 10};
    if (lengthPerTeil.edit.x > lengthPerTeil.edit.y && rotateTiles.checked) {
      tileSelectionBar.pictureSize = {width: lengthPerTeil.edit.x*(((JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)))/lengthPerTeil.edit.x), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)};
    }
    else {
      tileSelectionBar.pictureSize = {width: lengthPerTeil.edit.x*(((JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.y)))/lengthPerTeil.edit.y), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.y)};
    }
    lengthPerTeil.sizeAdapted = {x: tileSelectionBar.pictureSize.width, y: tileSelectionBar.pictureSize.height};
    tileSelectionCanvas.width = (lengthPerTeil.edit.x + 10)*positions.wrong.length;
    layout();
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
      backToBarBWidth.value = lengthPerTeil.sizeAdapted.x/7;
      backToBarBHeight.value = lengthPerTeil.sizeAdapted.y/7;
      elm.style.width = backToBarBWidth.value;
      elm.style.height = backToBarBHeight.value;
      elm.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2;
      elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
    }
    backToBarBWidth.max = lengthPerTeil.sizeAdapted.x;
    backToBarBHeight.max = lengthPerTeil.sizeAdapted.y;
    scrollTileSelectionLeft.height = lengthPerTeil.sizeAdapted.y/2;
    scrollTileSelectionRight.height = lengthPerTeil.sizeAdapted.y/2;
    scrollTileSelectionRight.style.bottom = (lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionRight.getBoundingClientRect().height/2) + "px";
    scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionLeft.getBoundingClientRect().height/2 + "px";
  }
  function originalDisplayChanged(checked) {
    if (aufgebenId.style.display == "inline") {
      startPause('viewOriginal');
      if (checked) stats.viewOriginal.times++;
      if (checked) {
        if (sourceIsPicture.checked) preview.style.display = "inline";
        else videoPreview.style.display = "inline";
        showOriginal.scrollIntoView();
      }
      else {
        if (sourceIsPicture.checked) preview.style.display = "none";
        else videoPreview.style.display = "none";
      }
      adaptExpandButtonPosition();
    }
  }
  // section 2: actions followed by element change/user input
  function goToTutorialIndex(bElm) {
    var indexId = Array.from(bElm.parentElement.querySelectorAll('input[type="checkbox"]')).filter(x => x.offsetWidth > 0 || x.offsetHeight > 0)[0].id;
    for (let i = 0; i < tutorialSteps.length; i++) {
      if (tutorialSteps[i].id == indexId) {
        goTutorialSteps(i - tutorial.index);
      }
    }
  }
  function showInformation() {
    var puzzle = puzzles[selected.puzzle];
    alert(`Dieses Puzzle nutzt den Modus "${puzzle.mode}". Sie haben bereits ${getTimeString(puzzle.completionTime)} Minuten mit dem Puzzle verbracht. Das Puzzle enthält ${puzzle.positions.wrong.length} Teile. `);
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function editPuzzleName() {
    var newName = prompt("Bitte geben Sie hier den neuen Namen ein.", selected.puzzle);
    if (newName && newName != selected.puzzle) {
      getPuzzles();
      puzzles[newName] = puzzles[selected.puzzle];
      delete puzzles[selected.puzzle];
      localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
      getPuzzles();
    }
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function deletePuzzle() {
    getPuzzles();
    delete puzzles[selected.puzzle]; 
    localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
    getPuzzles();
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function showHitboxes(recursively) {
    var canvas = hitboxTextur.getContext('2d');
    var waitTime = 0;
    if (doHitboxAnimation.checked && tileColliderSettings.style.display == "block" && (!state.hitboxPos || recursively)) {
      if (!state.hitboxPos) state.hitboxPos = {bottomTile: lengthPerTeil.edit.x, rightTile: lengthPerTeil.edit.y};
      if (!state.hitboxDirection) state.hitboxDirection = {bottomTile: -1, rightTile: 1};
      setTimeout(() => {
        if (state.hitboxPos.bottomTile < 0 || state.hitboxPos.bottomTile > lengthPerTeil.edit.x*2) state.hitboxDirection.bottomTile *= -1;
        if (state.hitboxPos.rightTile < 0 || state.hitboxPos.rightTile > lengthPerTeil.edit.y*2) state.hitboxDirection.rightTile *= -1;
        state.hitboxPos.bottomTile += state.hitboxDirection.bottomTile;
        state.hitboxPos.rightTile += state.hitboxDirection.rightTile;
        setTimeout(() => {
          showHitboxes(true);
        }, waitTime);
      }, 10);
    }
    if (!(doHitboxAnimation.checked && tileColliderSettings.style.display == "block")) state.hitboxPos = undefined;
    canvas.clearRect(0, 0, hitboxTextur.width, hitboxTextur.height);
    canvas.fillStyle = "hsl(0, 100%, 41%)";
    if (doHitboxAnimation.checked) {
    canvas.fillRect(lengthPerTeil.edit.x, lengthPerTeil.edit.y, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // right
    if (collides({x: lengthPerTeil.edit.x*2, y: lengthPerTeil.edit.y/2 - parseInt(hitboxHeight.value)/2 + lengthPerTeil.edit.y, width: 10, height: parseInt(hitboxHeight.value)}, {x: lengthPerTeil.edit.x*2, y: lengthPerTeil.edit.y/2 - parseInt(hitboxHeight.value)/2 + state.hitboxPos.rightTile, width: 10, height: parseInt(hitboxHeight.value)}).boolean) {
      if (shortHaltCollider.checked && !state.rightTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "hsl(120, 100%, 40%)";
      }
      else canvas.fillStyle = "green";
      state.rightTileCollidesHitbox = true;
    }
    else {
      if (shortHaltCollider.checked && state.rightTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "red";
      }
      else canvas.fillStyle = "hsl(0, 100%, 34%)";
      state.rightTileCollidesHitbox = false;
    }
    canvas.fillRect(lengthPerTeil.edit.x*2 + 11, state.hitboxPos.rightTile, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // bottom
    if (collides({x: lengthPerTeil.edit.x/2 - parseInt(hitboxWidth.value)/2 + lengthPerTeil.edit.x, y: lengthPerTeil.edit.y*2, width: parseInt(hitboxWidth.value), height: 10}, {x: lengthPerTeil.edit.x/2 - parseInt(hitboxWidth.value)/2 + state.hitboxPos.bottomTile, y: lengthPerTeil.edit.y*2, width: parseInt(hitboxWidth.value), height: 10}).boolean) {
      if (shortHaltCollider.checked && !state.leftTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "hsl(120, 100%, 40%)";
      }
      else canvas.fillStyle = "green";
      state.leftTileCollidesHitbox = true;
    }
    else {
      if (shortHaltCollider.checked && state.leftTileCollidesHitbox) {
        waitTime = 1777;
        canvas.fillStyle = "red";
      }
      else canvas.fillStyle = "hsl(0, 100%, 34%)";
      state.leftTileCollidesHitbox = false;
    }
    canvas.fillRect(state.hitboxPos.bottomTile, lengthPerTeil.edit.y*2 + 11, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
    // right
    canvas.fillRect(lengthPerTeil.edit.x*2, lengthPerTeil.edit.y/2 - hitboxHeight.value/2 + lengthPerTeil.edit.y, 10, hitboxHeight.value);
    canvas.fillRect(lengthPerTeil.edit.x*2, lengthPerTeil.edit.y/2 - hitboxHeight.value/2 + state.hitboxPos.rightTile, 10, hitboxHeight.value);
    // bottom
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2 + lengthPerTeil.edit.x, lengthPerTeil.edit.y*2, hitboxWidth.value, 10);
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2 + state.hitboxPos.bottomTile, lengthPerTeil.edit.y*2, hitboxWidth.value, 10);
  }
    else {
    canvas.fillRect(0, 0, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillRect(lengthPerTeil.edit.x + 11, 0, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillRect(0, lengthPerTeil.edit.y + 11, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
    canvas.fillRect(lengthPerTeil.edit.x, lengthPerTeil.edit.y/2 - hitboxHeight.value/2, 10, hitboxHeight.value);
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2, lengthPerTeil.edit.y, hitboxWidth.value, 10);
    }
  }
  function changeAdaptedSizeMax(width, height) {
    textur.width = width// + 111;
    textur.height = height// + 111;
    if (window.innerWidth > width || screenIsMax.checked) größeAnpassenX.max = window.innerWidth;
    else größeAnpassenX.max = width;
    if (window.innerHeight > height || screenIsMax.checked) größeAnpassenY.max = window.innerHeight;
    else größeAnpassenY.max = height;
    größeAnpassenX.value = width;
    größeAnpassenY.value = height;
    zeigeGröße();
  }
    // back to bar to the right of the selected tile in the tileBar
    function generalBackToBar(elm) {
    if (tileSelectionBar.tiles.length != anzahlX.value*anzahlY.value) {
      if (elm.style.backgroundColor == 'red') {
        state.backToBar = false;
        elm.style.backgroundColor = '';
        tileSelectionBar.selectedTile = undefined;
      }
      else {
        if (tutorial.state == "clickBackToBarBTurotial") goTutorialSteps(1);
        if (!tileSelectionBar.selectedTile) tileSelectionBar.selectedTile = {i: tileSelectionBar.tiles.length - 1};
        state.backToBar = tileSelectionBar.selectedTile.i + 1; 
        elm.style.backgroundColor = 'red';
        tileSelectionBar.selectedTile = undefined;
      }
    }
  }
  function expandSide(side, adaptButtonsOnly) {
    // if (!state.sideExpanded && aufgebenId.style.display == 'inline') {
    if (!adaptButtonsOnly) {
      if (['right', 'left'].includes(side)) textur.width += lengthPerTeil.edit.x*3;
      if (['bottom', 'top'].includes(side)) textur.height += lengthPerTeil.edit.y*3;
    }
    expandRight.style.left = textur.getBoundingClientRect().right + scrollX + 'px';
    expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY; + 'px';
    expandBottom.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandTop.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandRight.style.height = textur.height + 6; 
    expandLeft.style.height = textur.height + 6; 
    if (['top', 'left'].includes(side)) {
      var moveDirection = "x";
      if (side == "top") moveDirection = "y";
      for (const position of positions.wrong) {
        position.edit[moveDirection] += lengthPerTeil.edit[moveDirection]*3;
      }
    }
    state.rightScroll = 0;
    state.upScroll = 0;
    layout(true, true);
  }
  function showCurrentStats(mode) {
    if (mode == "traditional") alert(`Ihre vorläufigen Daten: Sie haben ${stats.turns} Mal Teile verbunden (es ist mit mindestens ${anzahlX.value*anzahlY.value - 1} Malen möglich) und ${stats.unclipped} Mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} Mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} Mal ein Teil gedreht.`);
    if (mode == "exchange") alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen (Es ist mit " + (positions.wrong.length - stats.preOrdered) + "Zügen möglich! Werden Sie es wohl schaffen?)");
    if (mode == "schieben") alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen (Es ist mit " + distinctMoves.length + "Zügen oder weniger möglich! Werden Sie es wohl schaffen?)");
    if (mode != "traditional" && stats.preOrdered) alert(`Bedenken Sie jedoch, dass Sie von den ${stats.highestRight.right} Richtigen von Anfang an ${stats.preOrdered} Teile von den insgesamt ${positions.wrong.length} Teilen an der richtigen Position hatten!`);
    alert(`Zudem haben Sie bis jetzt ${stats.viewOriginal.times} Mal für insgesamt ${stats.viewOriginal.time} Minuten auf das Originalbild geguckt und bis jetzt insgesant ${stats.completionTime} mit diesem Puzzle verbracht.`.replace('undefined', '0'));
  }
  function zuBildschirmgröße() {
    größeAnpassenX.value = window.innerWidth;
    größeAnpassenY.value = window.innerHeight;
    zeigeGröße();
  }
  function resetImageSize() {
    größeAnpassenX.value = preview.naturalWidth;
    größeAnpassenY.value = preview.naturalHeight;
    zeigeGröße();
  }
  // Seitenverhältnisse des Bildes anpassen
  function zuAngepassterBildschirmgröße(noShowing) {
    var referenceSize = originalSize;
    if (!screenIsMax.checked) referenceSize = {width: JSON.parse(JSON.stringify(größeAnpassenX.value)), height: größeAnpassenY.value};
    else referenceSize = {width: window.innerWidth + 1, height: window.innerHeight + 1};
    if (window.innerWidth < referenceSize.width && window.innerHeight < referenceSize.height) {
      größeAnpassenX.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
    }
    else {
      größeAnpassenX.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
    }
    if (!noShowing || noShowing == "repeat") zeigeGröße(true);
    if (screenIsMax.checked) {
      preventAutomaticZoom.content = `width=${größeAnpassenX.value}, height=${größeAnpassenY.value}, initial-scale=1.0, maximum-scale=1.0, user-scalable=0`;
      if (!noShowing) zuAngepassterBildschirmgröße("repeat");
    }
  }
  function zuOptimalerBildschirmgröße() {
    größeAnpassenX.value = preview.width;
    größeAnpassenY.value = preview.height;
    while (größeAnpassenX.value > window.innerWidth || größeAnpassenY.value > window.innerHeight) {
      größeAnpassenX.value--;
      größeAnpassenY.value--;
    }
    zeigeGröße();
  }
  function zeigeGröße(adapted, onInput) {
    if (größeAnpassenX.value != größeAnpassenY.value && !state.loadImage) bAdaptAmount.checked = true;
    if (state.loadImage && !adapted) zuAngepassterBildschirmgröße();
    delete state.loadImage;
    textur.width = größeAnpassenX.value;
    textur.height = größeAnpassenY.value
    // canvas.clearRect(0, 0, textur.width, textur.height);
    if (preview.src == "") {
    canvas.fillStyle = "blue";
    canvas.fillRect(0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  else {
    canvas.drawImage(document.getElementById('preview'), 0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  if (textur.width > window.innerWidth) editCanvasDiv.style.width = textur.width;
  else if (editCanvasDiv.style.width.replace('px', '') > window.innerWidth || (textur.getBoundingClientRect().right <= window.innerWidth + textur.getBoundingClientRect().left && textur.getBoundingClientRect().right > editCanvasDiv.getBoundingClientRect().right)) editCanvasDiv.style.width = window.innerWidth;
  // tilesSizeDiv: size reference
  else if (textur.getBoundingClientRect().right <= tilesSizeDiv.getBoundingClientRect().right) editCanvasDiv.style.width = "";
  // show tiles in grid
  drawTileGrid();
}
function drawTileGrid(doNotDrawPicture) {
  if (!doNotDrawPicture) {
    canvas.clearRect(0, 0, textur.width, textur.height);
    canvas.drawImage(preview, 0, 0, textur.width, textur.height);
  }
  for (let i = 0; i < anzahlX.value; i++) {
    canvas.beginPath();
    canvas.moveTo((textur.width/anzahlX.value)*i, 0);
    canvas.lineTo((textur.width/anzahlX.value)*i, textur.height);
    canvas.stroke();
  }  
  for (let i = 0; i < anzahlY.value; i++) {
    canvas.beginPath();
    canvas.moveTo(0, (textur.height/anzahlY.value)*i);
    canvas.lineTo(textur.width, (textur.height/anzahlY.value)*i);
    canvas.stroke();
  }  
}
  function playPauseVideo(innerHTML) {
    if (innerHTML == "play") {
      video.play();
      playVideo.innerHTML = 'pause';
    } 
    else {
      video.pause();
      playVideo.innerHTML = 'play';
    }
  }
  function modeSelected(value) {
    document.getElementById(value + 'Description').appendChild(startTutorialButton);
    modeSelection.value = value;
    traditionalDescription.style.display = 'none';
    exchangeDescription.style.display = 'none';
    schiebenDescription.style.display = 'none';
    document.getElementById(value + 'Description').style.display = 'block';
    if (value == "traditional") zeigeGröße();
    traditionalSettings.style.display = 'none';
    exchangeSettings.style.display = 'none';
    schiebenSettings.style.display = 'none';
    document.getElementById(value + 'Settings').style.display = 'block';
    document.getElementById(value + 'Settings').prepend(modeSettingsHeading);
  }
  var originalSize = {width: 0, height: 0};
  function gapSizeChanged(value) {
    gapCanvas.width = 100 + JSON.parse(tilesGap.value);
    gapCanvas.height = 100;
    var gCanvas = gapCanvas.getContext('2d');
    gCanvas.clearRect(0, 0, gCanvas.width, gCanvas.height);
    gCanvas.fillStyle = 'red';
    gCanvas.fillRect(0, 0, 50, 50);
    gCanvas.fillRect(50 + JSON.parse(tilesGap.value), 0, 50, 50);
  }
    // create the puzzle
    function create() {
    if (document.getElementById('preview').src == '' && video.src == '' && !pMediaStream) alert('Bitte laden Sie ein Bild oder ein Video bevor Sie auf diesen Button klicken um ein Puzzel zu erstellen!') 
    else if (!state.removeTile) {
      if (tutorial.state == "" && localStorage.getItem('tutorialAskedPuzzleCreator' + modeSelection.value) != "true" && confirm('Sie haben diesen Spielmodus anscheinend noch nie gespielt. Wollen Sie das Tutorial zur Einführung spielen? Alternativ können Sie die einzelnen Bestandteile des Tutorials (wegen Einstellungsmöglichkeiten nicht alle Bestandteile vorhanden) direkt während Sie Ihr erstes Puzzle in diesem Modus spielen in der Reihenfolge spielen, in der es Ihnen passt ("Steuerung anzeigen")! Wenn Sie auf "OK" o.ä. klicken, werden Sie als zu dem kompletten Tutorial zum Modus ' + modeSelection.value + ' gelangen, wenn Sie auf "abbrechen" o.ä. klicken, können Sie Ihr Puzzle spielen. ')) {
        setupTutorial();
      }
      else {
        futureTexturPosition.appendChild(textur);
        if (modeSelection.value == "schieben") modeDiv.prepend(modeSettingsHeading);
        else document.getElementById(modeSelection.value + 'Settings').prepend(modeSettingsHeading);
        if (modeSelection.value != "traditional") shuffleStyle.value = "none";
        if (modeSelection.value == "exchange") doNotMoveTile.checked = true;
        if (screenIsMax.checked) preventAutomaticZoom.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
        positions = {right: [], wrong: []};
        if (modeSelection.value == "traditional") {
          positions.layoutOrder = new Array(anzahlX.value*anzahlY.value);
          for (var i = 0; i < positions.layoutOrder.length; i++) {
            positions.layoutOrder[i] = i;
          }
        }
        removeTilesFinishedB.style.display = 'inline';
        if (modeSelection.value == "schieben") tileStatusOptions.style.display = 'inline';
        showSettings.title = "Einstellungsmöglichkeiten und Möglichkeit aufzugeben";
        imageSettings.style.display = "none";
        modeSelection.style.display = "none";
        schiebenSettings.style.display = "none";
        rotateTilesP.style.display = "none";
        missing = [];
        if (gerät == "Handy") mobileControls.style.display = "inline";
        if (sourceIsVideo.checked) {
          videoControls.style.display = 'block';
          videoPosition.max = video.duration;
          settings.style.display = 'block';
          videoPosition.style.width = window.innerWidth;
          while (timeText.getBoundingClientRect().x < videoPosition.getBoundingClientRect().x + convertStyle(videoPosition.style.width)) {
            videoPosition.style.width = (convertStyle(videoPosition.style.width) - 1) + 'px';
          }
          videoPosition.style.width = (convertStyle(videoPosition.style.width) - 15) + 'px';
          playVideo.style.width = playVideo.getBoundingClientRect().width;
          settings.style.display = 'none';
          if (video.srcObject) {
            for (const elm of timeChangeDiv) {
              elm.style.display = 'none';
            }
          }
        }
        originalSize.width = preview.width;
        originalSize.height = preview.height;
        preview.width = größeAnpassenX.value;
        preview.height = größeAnpassenY.value;
        textur.width = preview.width + 3*(anzahlX.value - 1) - 1// + 111;
        textur.height = preview.height + 3*(anzahlY.value - 1) - 1// + 111;
        videoPreview.width = größeAnpassenX.value;
        videoPreview.height = größeAnpassenY.value;
        var pAnzahlX = anzahlX.value;
        var pAnzahlY = anzahlY.value;
        if (sourceIsPicture.checked) lengthPerTeil = {original: {x: Math.round(originalSize.width/pAnzahlX), y: Math.round(originalSize.height/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
        else lengthPerTeil = {original: {x: Math.round(video.videoWidth/pAnzahlX), y: Math.round(video.videoHeight/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
        breiteRand.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3;
        randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - breiteRand.value;
        for (var i = 0; i < pAnzahlY; i++) {
          for (var i1 = 0; i1 < pAnzahlX; i1++) {
            if (modeSelection.value == "traditional") {
              var newTile = {original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}};
              if (i1) newTile.original.left = {x: positions.right[i*pAnzahlX + i1 - 1]?.original.x, y: positions.right[i*pAnzahlX + i1 - 1]?.original.y};
              if (i) newTile.original.top = {x: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.x, y: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.y};
              positions.right.push(newTile);
              if (i) positions.right[i*pAnzahlX + i1 - pAnzahlX].original.bottom = {x: newTile.original.x, y: newTile.original.y};
              if (i1) positions.right[i*pAnzahlX + i1 - 1].original.right = {x: newTile.original.x, y: newTile.original.y};
            }
            else {
              positions.right.push({original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}})
            }
            positions.right[positions.right.length - 1].border = [];
            if (i1 == 0) positions.right[positions.right.length - 1].border.push("left");
            if (i1 == pAnzahlX - 1) positions.right[positions.right.length - 1].border.push("right");
            if (i == 0) positions.right[positions.right.length - 1].border.push("top");
            if (i == pAnzahlY - 1) positions.right[positions.right.length - 1].border.push("bottom");
            positions.right[i*pAnzahlX + i1].x = i1;
            positions.right[i*pAnzahlX + i1].y = i;
          }
        }
        positions.wrong = JSON.parse(JSON.stringify(positions.right));
        for (var i = 0; i < pAnzahlY; i++) {
          for (var i1 = 0; i1 < pAnzahlX; i1++) {
            positions.wrong[i*pAnzahlX + i1].edit.x += 3*i1;
            positions.wrong[i*pAnzahlX + i1].edit.y += 3*i;
          }
        }
        //canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/200, /*yFromPicture*/200, 200, 200, /*xFromPlacement*/0, /*yFromPlacement*/0, 200, 200);
        window.scroll(0, /*96 50*/32);
        if (modeSelection.value == "schieben") {
          if (!state.restorePuzzle) alert("Bitte wählen Sie ein Teilstück aus, das entfernt wird. Im besten Fall ist es ein unwichtiger Teil des Bildes!");
          state.removeTile = true;
          layout(true, false, false, true);
        }
        else removeTile(true);
        // else layout();
        if (sourceIsVideo.checked) canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
        showSettings.scrollIntoView();
        window.scroll(0, 0);
        changeSettingsVis('none');
        swipeTitle.style.display = "inline";
        swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + 20;
        swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
        swipeTitle.style.display = "none";
        modeHeadline.style.display = 'none';
        shuffleHeadline.style.display = 'none';
        startTutorialButton.style.display = "none";
        EmptyTileBarDiv.style.display = "none";
        texturTop = textur.getBoundingClientRect().top + scrollY;
        futurePuzzleManager.appendChild(puzzleManager);
        automaticTileSelectionReset.checked = true;
      }
    }
    autoScroll = setInterval(function () {
      if (!selected.position.manualScrolling &&  aufgebenId.style.display == "inline" && !state.removeTile) {
        // top boundary: 
      // canvas.fillStyle = "blue";
      // canvas.fillRect(visualViewport.pageLeft - texturLeft, visualViewport.pageTop + state.upScroll - texturTop, visualViewport.width, 10);
  // up
  if (!scrollable.checked && aufgebenId.style.display == "inline" && (((modeSelection.value == "traditional" && positions.wrong[selected.tiles[0]]?.edit.y - lengthPerTeil.edit.y/2 < visualViewport.pageTop + state.upScroll - texturTop && selected.tiles.length) || (((modeSelection.value == "exchange" && selected.boolean.swipe) || (modeSelection.value == "schieben" && state.mouse == "down")) && mausy - scrollY < 30)))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    // window.scroll(scrollX, scrollY - 3);
    // mausy -= 3;
    fAutoScroll({x: 0, y: -3});
}
// right 
if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX + scrollX + lengthPerTeil.edit.x/2 > visualViewport.pageLeft + window.visualViewport.width/* - texturLeft*/ && selected.tiles?.length) {
      // window.scroll(scrollX + 3, scrollY);
      fAutoScroll({x: 3, y: 0}, true);
    }
if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x + lengthPerTeil.edit.x/2 > visualViewport.pageLeft + window.visualViewport.width + state.rightScroll/* + scrollX*/) || (modeSelection.value != "traditional" && mausx + texturLeft > visualViewport.pageLeft + window.visualViewport.width  - 50))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        // window.scroll(scrollX + 3, scrollY);
        // mausx += 3;
        fAutoScroll({x: 3, y: 0});
      }
      // left
      if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX - lengthPerTeil.edit?.x/2 < visualViewport.offsetLeft && selected.tiles.length) {
      // window.scroll(scrollX - 3, scrollY);
      fAutoScroll({x: -3, y: 0}, true);
    }
  if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && (mausx - visualViewport.pageLeft - state.rightScroll < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    // window.scroll(scrollX - 3, scrollY);
    // mausx -= 3;
    fAutoScroll({x: -3, y: 0});
}
  }
// down
var pScrollY = scrollY;
    if (shuffleStyle.value == "listTiles") pScrollY -= tileSelectionCanvas.getBoundingClientRect().height;// lengthPerTeil.edit.y - 10;
    var ptexturTop = textur.getBoundingClientRect().top - visualViewport.offsetTop; 
    if (ptexturTop < 0) ptexturTop = 0;
    if (!scrollable.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && ((positions.wrong[selected.tiles[0]].edit.y > visualViewport.pageTop + window.visualViewport.height + state.upScroll - ptexturTop - texturTop) || (['inline', ''].includes(tileSelectionCanvas.style.display) && positions.wrong[selected.tiles[0]].edit.y > tileSelectionCanvas.getBoundingClientRect().top + scrollY + state.upScroll - texturTop /* + pScrollY - texturTop*/))) || (modeSelection.value != "traditional" && mausy + texturTop > visualViewport.pageTop + window.visualViewport.height  - 70))) && (selected.boolean.swipe || modeSelection.value != "exchange") && state.mouse == "down")) {
        // window.scroll(scrollX, scrollY + 3);
        // mausy += 3;
        fAutoScroll({x: 0, y: +3});
      }
}, 10);
  }
  function fAutoScroll(direction, mirrored) {
    pcScrolls = true;
    if (tutorial.state == "automaticScrollingTutorial" && state.scrollY != scrollY) goTutorialSteps(1);
    state.scrollY = scrollY;
    if (!positions.wrong[selected.tiles[0]] || positions.wrong[selected.tiles[0]].edit.y > 0) window.scrollBy(direction.x, direction.y);
    mausx += direction.x;
    mausy += direction.y;
    if (gerät == "Handy") {
      if (direction.x && (positions.wrong[selected.tiles[0]] && ((positions.wrong[selected.tiles[0]].edit.x < textur.width && !mirrored) || (mausx > lengthPerTeil.edit.x/2 && mirrored))/*state.rightScroll < textur.width - visualViewport.width*/ && direction.x > 0) || (direction.x < 0 && ((selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x > 0 && !mirrored) || (mausx < textur.width - lengthPerTeil.edit.x/2 + texturLeft && mirrored))/*state.rightScroll > 0*/)) {
        state.rightScroll += direction.x;
        if (mirrored) canvas.translate(direction.x, 0);
        else canvas.translate(-direction.x, 0);
        layout(true, true);
      }
      if (direction.y && scrollY == state.scrollY && ((positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.y < textur.height/*textur.height - visualViewport.height*/ && direction.y > 0) || (direction.y < 0 && positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.y > 0))) {
        state.upScroll += direction.y;
        canvas.translate(0, -direction.y);
        layout(true, true);
        folgenMouseMove();
      }
    }
  }
  function checkAutoscrollStop(scrollBefore) {
    setTimeout(() => {
      if (tutorial.state == "stopScrollingAutomaticScrollingTutorial") {
        if (scrollX == scrollBefore.x && scrollY == scrollBefore.y) goTutorialSteps(1);
        checkAutoscrollStop({x: scrollX, y: scrollY});
      }
    }, 777);
  }
  var positionsBeginning = [];
  function shufflePuzzle() {
    var shuffleStyleBefore = shuffleStyle.value;
    if (emptyTileBar.checked)  shuffleStyle.value = shuffleStyleBar.value;
    if (modeSelection.value == "schieben" && !selected.tiles.length && !state.restorePuzzle) alert("Sie müssen mindestens ein Teil ausgeählt haben, das wegfällt, damit Sie schieben können!");
    else {
      localStorage.setItem('tutorialAskedPuzzleCreator' + modeSelection.value, "true");
      for (var i = 0; i < anzahlY.value; i++) {
      for (var i1 = 0; i1 < anzahlX.value; i1++) {
        positions.wrong[i*anzahlX.value + i1].edit.x -= 3*i1;
        positions.wrong[i*anzahlX.value + i1].edit.y -= 3*i;
      }
    }
    textur.width -= 3*(anzahlX.value - 1);
    textur.height -= 3*(anzahlY.value - 1);
      var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
      for (var i of selected.tiles) {
        missing.push(JSON.parse(JSON.stringify(positions.wrong[i].edit.x + ' - ' + positions.wrong[i].edit.y)));
        positionsBeginning.push(positions.wrong[i]);
        positions.wrong.forEach((position, i1) => {
          for (var direc of ['top', 'right', 'bottom', 'left']) {
            if (positions.wrong[i].border.includes(directionConverter[direc]) && positions.wrong[i].original[direc] && !i1/* && !selected.tiles.includes(getTile(positions.wrong[i].original[direc]))*/) {
              positions.wrong[getTile(positions.wrong[i].original[direc])].border.push(directionConverter[direc]);
            }
            if (position.original[direc]) {
            position.original[direc].degree = 0;// position.edit.degree;
            if (angular.equals(position.original[direc], {x: positions.wrong[i].original.x, y: positions.wrong[i].original.y, degree: 0})) {
              delete position.original[direc].degree;
              delete positions.right[i1].original[direc];
              // delete position.original[direc];
            }
            else delete position.original[direc].degree;
          }
          }
        });
      }
      if (modeSelection.value != "exchange") {
        for (var i = 0; i < positions.wrong.length; i++) {
          if (selected.objTiles.includes(JSON.stringify(positions.wrong[i].edit))) {
            positions.wrong.splice(i, 1);
            positions.right.splice(i, 1);
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
              if (doNotChange[i1] > i) doNotChange[i1]--;
            }
            if (modeSelection.value == "traditional") {
              positions.layoutOrder.splice(i, 1);
              for (var i1 = i; i1 < positions.layoutOrder.length; i1++) {
                positions.layoutOrder[i1]--;
              }
            }
            i--;
          }
        }
      }
      selected.tiles = [];
      removeTilesFinishedB.style.display = 'none';
      state.removeTile = false;
      if (modeSelection.value == "schieben") {
        getShortestPCMovement();
      }
      else {
      if (modeSelection.value == "traditional") {
        textur.width += 500;
        textur.height += 500;
        positions.wrong.forEach((position, i) => {
          if (shuffleStyle.value != "listTiles" || emptyTileBar.checked) {
            position.edit = {x: Math.round(Math.random()*(textur.width - lengthPerTeil.edit.x)), y: Math.round(Math.random()*(textur.height - lengthPerTeil.edit.y)), degree: 0};
            if (emptyTileBar.checked) tileSelectionBar.tiles.push(i);
          }
          else {
            position.edit = {x: i*(lengthPerTeil.edit.x + 5) + lengthPerTeil.edit.x/2, y: 5 + lengthPerTeil.edit.y/2, degree: 0};
            tileSelectionBar.tiles.push(i);
          }
          position.original = {x: position.original.x, y: position.original.y, degree: [0, 90, 180, 270][Math.round(Math.random()*3)]};
          if (!rotateTiles.checked) position.original.degree = 0;
          if (position.original.degree == 270) stats.minimumRotations += 90;
          else stats.minimumRotations += Math.abs(position.original.degree/90);
      });
      if (emptyTileBar.checked) {
        state.modelEmptybar = true;
        setTimeout(function () {
          tileSelectionBar.tiles = [];
          state.modelEmptybar = false;
          layout();
        }, 100);  
      }
    }
    if (shuffleStyle.value == "nextToEachOther") {
        if (isNaN(tilesGap.value) || tilesGap.value == '') tilesGap.value = 55;
        if (isNaN(tilesXTileGap.value) || tilesXTileGap.value == '') tilesXTileGap.value = anzahlX.value;
        var pos = {x: lengthPerTeil.edit.x/2, y: lengthPerTeil.edit.y/2};
        for (let i = 0; i < positions.wrong.length; i++) {
          positions.wrong[i].edit = {x: pos.x, y: pos.y, degree: 0};
          pos.x += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
          if ((pos.x + lengthPerTeil.edit.x/2 > window.innerWidth && fillScreenTileGap.checked) || (!fillScreenTileGap.checked && pos.x > lengthPerTeil.edit.x + (lengthPerTeil.edit.x + JSON.parse(tilesGap.value))*(parseInt(tilesXTileGap.value) - 1))) {
            if (pos.x + lengthPerTeil.edit.x/2 > textur.width) textur.width = pos.x - lengthPerTeil.edit.x/2 - JSON.parse(tilesGap.value);
            pos.x = lengthPerTeil.edit.x/2;
            if (pos.y + lengthPerTeil.edit.y/2 > textur.height) textur.height = pos.y + lengthPerTeil.edit.y/2;
            pos.y += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
          }
        }
      }
      for (i = positions.wrong.length - 1; (modeSelection.value == "exchange" || shuffleStyle.value != "overlapTiles") && i > 0; i--) {
        do {
          j = Math.floor(Math.random() * (i + 1));
        } while (doNotChange.includes(j) && j != i && doNotChange.length != positions.wrong.length);
        x = positions.wrong[i].edit;
        if (!doNotChange.includes(i)) {
          positions.wrong[i].edit = positions.wrong[j].edit;
          positions.wrong[j].edit = x;
        }
      }
      stats.preOrdered = "pending";
    }
    if (shuffleStyle.value == "nextToEachOther") tilesGapS.style.display = "none";
    shuffleStyle.value = shuffleStyleBefore;
    doNotChange = [];
    aufgebenId.style.display = "inline";
  showOriginalP.style.display = 'inline';
  showTutorialB.style.display = "inline"
  shuffleStyle.style.display = 'none';
  tileStatusOptions.style.display = 'none';
  shuffleStyleLable.style.display = 'none';
  if (modeSelection.value == "schieben") turnsHistoryS.style.display = 'inline';
  // expand textur buttons
  if (modeSelection.value == "traditional") { 
    if (localStorage.getItem('automaticTileSelectionResetPuzzleCreator') != "true" && gerät == "PC") automaticTileSelectionReset.checked = false;
    else automaticTileSelectionReset.checked = true;
  textur.style.position = "absolute";
  expandBottom.style.width = textur.width + 6; 
  expandTop.style.width = textur.width + 6;  
  // expandTop.style.position = "static";  
  for (const elm of document.getElementsByClassName('expandButtons')) {
    elm.style.display = 'inline';
  }
  textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY + 'px';
  texturTop = textur.getBoundingClientRect().top + scrollY;
  expandLeft.style.left = '0px';
  expandLeft.style.height = textur.height + 6;  
  expandLeft.style.top = textur.getBoundingClientRect().top + scrollY// texturTop;
  textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
  expandTop.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandBottom.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandRight.style.top = texturTop;
  expandRight.style.height = textur.height + 6;  
  expandRight.style.left = textur.getBoundingClientRect().right + scrollX// textur.getBoundingClientRect().x + scrollX + textur.width + 6 + 'px';
  expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY;// texturTop + scrollY + textur.height + 6 + 'px'; 
}
  texturLeft = textur.getBoundingClientRect().left + scrollX;
  if (gerät == "Handy") autoSelectTileBar.checked = false;
  // var pTileBarHeight = lengthPerTeil.edit.y + 10;
  // if (lengthPerTeil.edit.x > lengthPerTeil.edit.y && rotateTiles.checked) pTileBarHeight = lengthPerTeil.edit.x + 10;
  // tileSelectionBar.height = pTileBarHeight;
  tileBarHeight.max = window.innerHeight - texturTop - lengthPerTeil.edit.y;
  setDefaultSelectionBarHeight();
  // changeTileBarHeight(pTileBarHeight);
  // tileSelectionCanvas.height = pTileBarHeight;
  backToBarBWidth.max = lengthPerTeil.edit.x;
  backToBarBHeight.max = lengthPerTeil.edit.y;
  backToBarBWidth.value = lengthPerTeil.edit.x/7;
  backToBarBHeight.value = lengthPerTeil.edit.y/7;
  hitboxCheckbox.style.display = "inline";
  hitboxWidth.max = lengthPerTeil.edit.x;
  hitboxWidth.value = lengthPerTeil.edit.x/4;
  hitboxHeight.max = lengthPerTeil.edit.y;
  hitboxHeight.value = lengthPerTeil.edit.y/4;
  hitboxTextur.width = lengthPerTeil.edit.x*3 + 33;
  hitboxTextur.height = lengthPerTeil.edit.y*3 + 33;
  if (shuffleStyle.value == "listTiles") {
    tileSelectionCanvas.style.display = "inline";
    selectBackToBarB.style.display = 'inline';
    listTilesS.style.display = 'block';
    settings.style.display = 'block';
    tileBarHeight.style.width = window.innerWidth - tileBarHeightText.getBoundingClientRect().width - resetBarSize.getBoundingClientRect().width - 100;
    settings.style.display = 'none';
  }
  else tileSelectionCanvas.style.display = "none";
  scrollTileSelectionRight.style.bottom = (lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionRight.getBoundingClientRect().height/2) + "px";
  scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionLeft.getBoundingClientRect().height/2 + "px";
  if (gerät == "Handy") {
    selectBackToBarB.style.fontSize = '5vh';
    // zoom out: 
    var newElm = document.createElement('meta');
      newElm.name = "viewport";
      newElm.id = "zoomLevelControler";
      newElm.content = "initial-scale=0.25";
      document.getElementsByTagName('head')[0].appendChild(newElm);
  }
  if (shuffleStyle.value == "listTiles") {
    scrollTileSelection(0);
    for (var i = 0; i < tileSelectionBar.tiles.length + 1; i++) {
      addElement({class: "backToTileB", innerText: '+', style: `width: ${backToBarBWidth.value}px; height: ${backToBarBHeight.value}; bottom: ${(lengthPerTeil.edit.y + 5)/2 - (backToBarBHeight.value)/2}px; left: ${10 + (5 + lengthPerTeil.edit.x)*(i) - (backToBarBWidth.value)/2}px`, onclick: `posInBarSelected(${i});`}, 'button', 'backToBarButtons');
    }
  }
    if (gerät == "Handy") {
    mobileControls.style.display = 'inline';
    rotateControls.style.display = "inline";
  }
  selected.boolean = {click: false, swipe: false};
  try {
  preventAutomaticZoom.content = "";
  } catch (err) {}
  window.scroll(0, 0);
  }
  adaptTitlesPosition();
  emptyTileBar.style.display = "none";
  if (modeSelection.value == "traditional") {
    traditionalModeMobileControls.style.display = 'inline';
  }
  canvas = textur.getContext('2d');
  layout(true, true);
  startPause('completionTime');
  setTimeout(() => {
    adaptMobileControlsPosition();
    if (tileSelectionCanvas.style.display != "none") {
      scrollTileSelection(1);
      changeTileBarHeight(tileBarHeight.value);
      scrollTileSelection(-1);
    }
  }, 100);
}
function setDefaultSelectionBarHeight() {
  var pTileBarHeight = lengthPerTeil.edit.y + 10;
  if (lengthPerTeil.edit.x > lengthPerTeil.edit.y && rotateTiles.checked) pTileBarHeight = lengthPerTeil.edit.x + 10;
  tileSelectionBar.height = pTileBarHeight;
  tileSelectionCanvas.height = pTileBarHeight;
  changeTileBarHeight(pTileBarHeight);
}
// #importantUserInputs
// select tiles to remove and move tiles or exchange them depending on the mode
function canvasClicked(calledBy) {
  if (calledBy == "elm") selected.boolean.swipe = false;
  selected.tile = checkSelected();
  if (!state.removeTile && !scrollable.checked && !finished) { 
    if (aufgebenId.style.display == "inline" && settings.style.display == "block") changeSettingsVis('none');
    if (selected.tile && selected.tiles.length && (selected.boolean.click || selected.boolean.swipe) && modeSelection.value == "exchange" && !state.removeTile) {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == selected.tile.x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == selected.tile.y) {
          if (selected.tile.x + "-" + selected.tile.y == selected.coord.x + "-" + selected.coord.y && (!selected.boolean.swipe || (calledBy == "mouseup" && state.tileChanged)) && !state.unselected) {
            selected.tiles = selected.tiles.filter(x => x != i);
            if (["unselectTileUnselectStandardTutorial"].includes(tutorial.state) || (tutorial.state == "releaseMouseUnselectAlternativeTutorial" && state.tileChanged)) goTutorialSteps(1);
            if (tutorial.state == "selectSecondExchangeNormalTutorial") goTutorialSteps(-1);
            state.unselected = true;
            setTimeout(() => {
              state.unselected = false;
            }, 100);
          }
          else if (selected.tile.x + "-" + selected.tile.y != selected.coord.x + "-" + selected.coord.y) {
              console.log("vertausche " + selected.tile.x + "-" + selected.tile.y + " mit " + selected.coord.x + "-" + selected.coord.y);
              if (["selectSecondExchangeNormalTutorial"].includes(tutorial.state)) goTutorialSteps(1);
              if (tutorial.state == "unselectTileUnselectStandardTutorial") goTutorialSteps(-1);
              if (tutorial.state == "releaseMouseUnselectAlternativeTutorial") goTutorialSteps(-3);
              stats.turns++;
              vertauscheZwei(i, selected.tiles[0]);
              selected.tiles = [];
              i = positions.wrong.length;
              // i1 = positions.wrong.length;
              if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
              state.exchangedTiles = true;
              setTimeout(() => {
                state.exchangedTiles = false;
              }, 500);
          }
          selected.boolean = {click: false, swipe: false};
      }
    }
    }
    else if (modeSelection.value == "schieben" && selected.tile/* && selected.boolean*/ && missing.length && !state.removeTile) {
      var tileMoved = false;
      for (var i1 = 0; i1 < missing.length; i1++) {
        pMissing = missing[i1];
        if (possibleMissing.length && pMissing == (selected.tile.x)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y) {
          if (tutorial.state == "schiebenSelectGapMoveMultipleTurorial") goTutorialSteps(1);
          moveTile(possibleMissing.filter(x => x.i1 == i1)[0].i, i1);
          tileMoved = true;
        }
        else {
        if ((pMissing == (selected.tile.x + 1)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y) /*right*/ || (pMissing ==(selected.tile.x - 1)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y)/*left*/ || (pMissing == selected.tile.x*lengthPerTeil.edit.x + ' - ' + (selected.tile.y + 1)*lengthPerTeil.edit.y)/*down*/ || (pMissing == (selected.tile.x*lengthPerTeil.edit.x + ' - ' + (selected.tile.y - 1)*lengthPerTeil.edit.y)/*up*/)) {
          for (var i = 0; i < positions.wrong.length; i++) {
            if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == selected.tile.x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == selected.tile.y) {
              possibleMissing.push({i: i, i1: i1});
            }
          }
        }
      }
  }
  if (possibleMissing.length == 1 && !tileMoved) {
    if (tutorial.state == "schiebenNormalTurorial") goTutorialSteps(1);
    moveTile(possibleMissing[0].i, possibleMissing[0].i1);
  }
  if (possibleMissing.length > 1 && tutorial.state == "schiebenSelectTileMoveMultipleTurorial") goTutorialSteps(1);
}
    else if (selected.tile && (modeSelection.value == "exchange"/* || missing*/) && !state.exchangedTiles && !state.unselected) {
      selected.coord = {x: selected.tile.x, y: selected.tile.y};
      selected.tiles = [getTileIByCoord(selected.tile)];
      selected.boolean.click = true;
      if (["selectFirstExchangeNormalTutorial", "selectTileUnselectStandardTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
  }
    selected.tile = checkSelected(true);
    if (selected.tile && ((!missing.length && modeSelection.value == "schieben") || state.removeTile) && (!lastCoord || JSON.stringify(lastCoord) != JSON.stringify(selected.tile) || (((state.mouse == "up" && calledBy != "elm") || calledBy == "mouseDown") && JSON.stringify(state.coord) == JSON.stringify(selected.tile)))) {
      removeTile(null, calledBy);
      lastCoord = selected.tile;
    }
    else {
      if (aufgebenId.style.display == "inline") layout(false, true);
    }
    selected.tile = checkSelected();
  }
  function getTileIByCoord(coord, positionType) {
    if (!positionType) positionType = "wrong";
    for (let i = 0; i < positions[positionType].length; i++) {
      if (positions[positionType][i].edit.x/lengthPerTeil.edit.x == coord.x && positions[positionType][i].edit.y/lengthPerTeil.edit.y == coord.y) return i;
    }
  }
  // section 2.1: movementPlayer (player of PC movement in schieben mode)
  function getShortestPCMovement(restorePuzzle) {
  if (!state.restorePuzzle && !restorePuzzle) {
    movement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
    verschiebenPC();
  }
  wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
  setTimeout(function () {
    // create misstingDistinct
    distinctMoves = JSON.parse(JSON.stringify(movement.move));
    var distinctPositions = [];
    var change;
    var firstRunThrough = true;
    playerMovement = movement.move;
    do {
      change = false;
      var leftBeginning = 1;
      for (let i = 0; i < movement.move.length; i++) {
        var move = JSON.stringify(playMovementPos(i, true, true));
      if (distinctPositions.includes(move) || JSON.stringify(movement.startPosition) == move) {
        for (let i1 = leftBeginning; i1 < /*movement.move.length*/i; i1++) {
          if (JSON.stringify(playMovementPos(i1, true, true)) == move && distinctMoves[i1] != undefined && distinctMoves[i] != undefined) {
            distinctPositions.splice(i1, (i - i1));
            // distinctMoves.splice(i1, (i - i1));
            // console.log('lösche ' + i1 + ' bis ' + (i-1));
            distinctMoves.fill(undefined, i1, i);
            leftBeginning = i1 + (i - i1);
            // i1 = i1 + (i - i1);
            change = true;
            break;
          }
        }
        }
        if (firstRunThrough) distinctPositions.push(move);
      }
      firstRunThrough = false;
    } while (change)
    distinctMoves = distinctMoves.filter(x => x != undefined);
    if (distinctMoves[0] && ((Math.abs(distinctMoves[0].x) == Math.abs(distinctMoves[1].x) || Math.abs(distinctMoves[0].y) == Math.abs(distinctMoves[1].y)) && distinctMoves[0].tile == distinctMoves[1].tile)) distinctMoves.splice(0, 2);
    positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
    movementStepsChanged(distinctMovement.checked);
    state.redoI1 = undefined;
  }, 500);
  movementPlayer.style.display = 'inline';
  movementPlayerTextur.width = textur.width;
  movementPlayerTextur.height = textur.height;
}
  var userMovement = {index: 0, moves: []};
  function movementStepsChanged(checked, doNotSetChecked) {
    if (!doNotSetChecked)  distinctMovement.checked = checked;
    if (checked) playerMovement = distinctMoves;
    else playerMovement = movement.move;
    movementPosition.max = playerMovement.length;
  }
  function playPauseMovement() {
    if (movementPlayButton.innerHTML == "play") {
      movementPlayButton.innerHTML = "pause";
      playMovementFunction();
    }
    else movementPlayButton.innerHTML = "play";
  }
  var playerMovement = [];
  function playMovementFunction() {
    if (movementPlayButton.innerHTML == "pause") {
      if (JSON.parse(movementPosition.value) < playerMovement.length || JSON.parse(movementPosition.value) + objMovementPlayer.direc < 0) playMovementPos(JSON.parse(movementPosition.value) + objMovementPlayer.direc);
      else movementPlayButton.innerHTML = "play";
      setTimeout(function () {
        playMovementFunction();
      }, JSON.parse(movementPlayerSpeed.value));
    }
  }
  var objMovementPlayer = {pause: false, position: 0, direc: 1};
  function getPlayerPosition(backToBeginningIfNeeded, easySteps) {
    for (let i = 0; i < playerMovement.length; i++) {
      if (JSON.stringify(playMovementPos(i, true, true)) == JSON.stringify(movement.playerPosition)) {
        return i;
      }
    }
    if (easySteps != undefined) {
      movementStepsChanged(easySteps);
    }
    else {
      movementStepsChanged(false, true);
      getPlayerPosition(false, distinctMovement.checked);
    }
    if (backToBeginningIfNeeded) return 0;
    else return JSON.parse(movementPosition.value);
  }
  var wrongPosition;
  function playMovementPos(position, pReturn, doNotChangeVal, pPlayerMovement) {
    var isUserMovement = pPlayerMovement != undefined;
    if (!pPlayerMovement) pPlayerMovement = playerMovement;
    else {
      if (goBackAsTurns.checked) stats.turns += Math.abs(position - playerMovementSlider.value);
      playerMovementSlider.value = position;
      state.changedPos = true;
      userMovement.index = position;
      setTimeout(() => {
        movement.playerPosition = positions.wrong;
        storePuzzle();
      }, 100);
    }
    if (position < 0) position = 0;
    if (position > pPlayerMovement.length) position = pPlayerMovement.length;
    if (!doNotChangeVal) movementPosition.value = position;
    if (!isUserMovement) positions.wrong = JSON.parse(JSON.stringify(movement.startPosition));
    else positions.wrong = JSON.parse(JSON.stringify(userMovement.startPosition));
    for (let i = pPlayerMovement.length - 1; i >= position; i--) {
      if (isUserMovement) missing[pPlayerMovement[i].i1] = positions.wrong[pPlayerMovement[i].tile].edit.x + ' - ' + positions.wrong[pPlayerMovement[i].tile].edit.y;
      positions.wrong[pPlayerMovement[i].tile].edit.x += pPlayerMovement[i].x;
      positions.wrong[pPlayerMovement[i].tile].edit.y += pPlayerMovement[i].y;
    }
    if (pReturn) return positions.wrong;
    // PC movement player
    if (!isUserMovement) {
      canvas = movementPlayerTextur.getContext('2d');
      objMovementPlayer.position = JSON.parse(position);
    }
    layout(true, true);
  }
  // end section 2.1
    // backTobar button clicked
    var offline = false;
    function posInBarSelected(i) {
      if (tutorial.state == "BackToTileBarTutorial") goTutorialSteps(1);
      if (Array.from(document.getElementsByClassName('backToTileB')).filter(x => x.style.backgroundColor != "").length && i == state.backToBar) {
        state.backToBar = "unselect " + i;
      }
    for (const elm of document.getElementsByClassName('backToTileB')) {
      elm.style.backgroundColor = '';
    }
    if (tileSelectionBar.tiles.length != positions.wrong.length && state.backToBar != "unselect " + i) {
      state.backToBar = i; 
      document.getElementsByClassName('backToTileB')[i].style.backgroundColor = 'red';
    }
    if (typeof state.backToBar === "string" && state.backToBar.includes("unselect")) state.backToBar = false;
    tileSelectionBar.selectedTile = undefined;
    layout();
  }
  // section 2.2: handle input data (picture, video, URL)
  // load selected file
  function readImg(input) {
    var cancelLoading = false;
    sourceCheckboxes.style.display = 'none';
    var reader = new FileReader();
    stopLiveFeed();
    if (!state.restorePuzzle || state.restorePuzzle.fileName == input.files[0].name || confirm("Sie haben wohl das falsche Puzzle ausgewählt. Wenn Sie trotzdem fortfahren wollen, klicken Sie auf OK o.ä. (andernfalls klicken Sie auf abbrechen o.ä. und erneut auf den Namen des Bildes, um das rictige Bild auszuwählen. )")) {
      reader.onload = function (e) {
        if (sourceIsPicture.checked) document.getElementById('preview').setAttribute("src", e.target.result);
        else {
          video.setAttribute("src", e.target.result);
          setTimeout(function () {
            loadImage(video.videoWidth, video.videoHeight);
          }, 1000);
        }
      };
    }
      else if (state.restorePuzzle) {
        cancelLoading = true;
      }
    reader.readAsDataURL(input.files[0]);
    if (input.files[0].type.includes('video')) sourceIsVideo.checked = true;
    else sourceIsPicture.checked = true;
    for (const puzzle of Object.keys(puzzles)) {
      if (!state.restorePuzzle && puzzles[puzzle].fileName == input.files[0].name && confirm('Sie haben bereits ein Puzzle mit dieser Datei im Modus "' + puzzles[puzzle].mode + '" begonnen! Sie haben es unter dem Namen "' + puzzle + '" gespeichert. Wollen Sie dieses laden?')) {
        restorePuzzleSource(puzzle, true);
        break;
      }
    }
    if (!cancelLoading && sourceIsPicture.checked) loadImage();
    fileName = input.files[0].name;
    setTimeout(() => {
      if (state.waitForPictureSelection) startTutorial();
    }, 1111);
  }
  var fileName;
  var video = document.createElement("video");
  function useURL() {
    useURLCheck.checked = true;
    sourceCheckboxes.style.display = 'none';
    if (sourceURL.value.includes('.mp4') || sourceURL.value.includes('.move')) sourceIsVideo.checked = true;
    else if (sourceURL.value.includes('.png') || sourceURL.value.includes('.jpg') || sourceURL.value.includes('.jpeg')) sourceIsPicture.checked = true;
    else {
     document.getElementById('sourceIs' + state.userSource).checked = true;
     sourceCheckboxes.style.display = 'block';
  }
    stopLiveFeed();
    for (const puzzle of Object.keys(puzzles)) {
      if (!state.restorePuzzle && sourceURL.value == puzzles[puzzle].URL && confirm('Sie haben bereits ein Puzzle mit diesem Link/dieser URL im Modus "' + puzzles[puzzle].mode + '" begonnen! Sie haben es unter dem Namen "' + puzzle + '" gespeichert. Wollen Sie dieses laden?')) {
        restorePuzzleSource(puzzle, true);
        break;
      }
    }
    if (sourceIsPicture.checked) {
        preview.src = sourceURL.value;
    loadImage();
  }
  else {
    video.src = sourceURL.value;
  }
  }
  function startVideo() {
    video.play();  // start playing
    updateVideo(); //Start rendering
  }
  video.addEventListener('loadeddata', function() {
    startVideo();
    loadImage(video.videoWidth, video.videoHeight);
  }, false);
  var originalSize = {};
  function loadImage(width, height) {
    setTimeout(function () {
      URLInfo.style.display = 'none';
      // videoPosition.style.width = window.innerWidth - 33 - timeText.getBoundingClientRect().width - 126.234375*2;
      if (!width) {
        width = preview.width;
        height = preview.height;
      }
      originalSize = {width: width, height: height};
      try {
        canvas.drawImage(document.getElementById('preview'), 0, 0);
      } catch (err) {
        if (useURLCheck.checked) URLInfo.style.display = 'block';
        offline = true;
      }
      if (aufgebenId.style.display != "inline") {
        changeAdaptedSizeMax(width, height);
        zuAngepassterBildschirmgröße();
      } 
       if (state.restorePuzzle) {
        größeAnpassenX.max =  state.restorePuzzle.width;
        größeAnpassenY.max =  state.restorePuzzle.height;
        größeAnpassenX.value = state.restorePuzzle.width;
        größeAnpassenY.value = state.restorePuzzle.height;
        if (state.restorePuzzle.tileBarTiles) shuffleStyle.value = "listTiles";
        else shuffleStyle.value = "nextToEachOther";
        create();
        shufflePuzzle();
        restorePuzzle(state.restorePuzzle);
        delete state.restorePuzzle;
       }
    }, 500);
    selectSourceHeader.style.color = "green";
    createPuzzleButton.style.backgroundColor = "green";
  }
  // end section 2
  // section 3: handle videos

  // returns string with UI time
// @param: pTime: total time in seconds
function getTimeString(pTime) {
  pTime = Math.floor(pTime);
  var sec, mins, hours;
  hours = Math.floor(pTime / 60 / 60);
  mins = Math.floor(pTime / 60) - hours*60;
  sec = pTime - mins*60 - hours*60*60;
  if (sec < 10) sec = '0' + sec; 
  if (mins < 10) mins = '0' + mins; 
  if (hours < 10) hours = '0' + hours;
  return `${hours}:${mins}:${sec}`;
}
// converts time string back into time in seconds
// @param: 
  // value: String with UI time layout
  // id: undefined or loopEnding (value then is time stamp of loop ending)
  function convertTime(value, id){
  var time = 0;
  var sec = value.split(':')[2];
  var mins = value.split(':')[1];
  var hours = value.split(':')[0];
  if (sec < 10) sec = sec[1];
  if (mins < 10) mins = mins[1];
  if (hours < 10) hours = hours[1];
  if (value.split(':')[3]) time += parseInt(value.split(':')[3])/100;
    try {
      time += JSON.parse(sec);
      time += JSON.parse(mins)*60;
      time += JSON.parse(hours)*60*60;
      if (time > video.duration || time < 0) console.log(abc);
    }
    catch (e) {
      if (id == 'loopEnding') time = video.duration;
      else time = 0;
    }
  return time;
}
// draw changes in the video on the canvas and changes the current position in the video
function updateVideo(){
    videoPosition.value = video.currentTime;
    timeText.innerHTML = getTimeString(video.currentTime) + ' / ' + getTimeString(video.duration);
    canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
    if (aufgebenId.style.display == "inline") {
      for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
        var i = i1;
        if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
        if (shuffleStyle.value == "listTiles" && tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], false, i, tileSelectionBar.canvas);
        else drawPictureSegment(positions.wrong[i], positions.right[i], false, i);
      }
    }
    else  if (state.removeTile) {
      for (let i = 0; i < anzahlX.value; i++) {
        for (let i1 = 0; i1 < anzahlY.value; i1++) {
          canvas.drawImage(video, positions.wrong[i1*anzahlX.value + i].original.x, positions.wrong[i1*anzahlX.value + i].original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, i*lengthPerTeil.edit.x + 3*i, i1*lengthPerTeil.edit.y + 3*i1, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
        }
      }
    }
    else {
      canvas.drawImage(video,0,0, größeAnpassenX.value, größeAnpassenY.value);
      drawTileGrid(true);
    }
    videoPreview.getContext('2d').drawImage(video, 0, 0, größeAnpassenX.value, größeAnpassenY.value);
    showSelected();
    showClippingOptions();
    if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')  && loop.checked) {
      video.currentTime = convertTime(loopBeginning.value);
      if (loopEnding.value > loopBeginning.value || loopEnding.value == "" || loopBeginning.value == "") video.play();
    }
    else if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')) {
      if (stopAtEnd.checked) playPauseVideo('pause');
      else if(video.currentTime >= video.duration) playVideo.innerHTML = 'play';
    }
    if (sourceIsVideo.checked) requestAnimationFrame(updateVideo); // wait for the browser to be ready to present another animation fram.
    else video.pause();
}
// section 3.1: live camera
// Prefer camera resolution nearest to 1280x720.
var constraints = { /*audio: true, */video: { width: 1280, height: 720 } };
var pMediaStream;
// stop live feed, so another one can start
function stopLiveFeed() {
  if (pMediaStream) {
    pMediaStream.getTracks().forEach(track => {
      track.stop();
    });
    video.srcObject = undefined;
  }
  // pMediaStream = undefined;
}
// changes camera source
async function changeCamera(index) {
  for (const puzzle of Object.keys(puzzles)) {
    if (!state.restorePuzzle && index == puzzles[puzzle].liveCam && confirm('Sie haben bereits ein Puzzle mit dieser Kamera im Modus "' + puzzles[puzzle].mode + '" begonnen! Sie haben es unter dem Namen "' + puzzle + '" gespeichert. Wollen Sie dieses laden?')) {
      restorePuzzleSource(puzzle, true);
      break;
    }
  }
  sourceCheckboxes.style.display = 'none';
  sourceIsVideo.checked = true;
  stopLiveFeed();
  var Test = await navigator.mediaDevices.enumerateDevices();
  constraints.video.deviceId = Test[index].deviceId;
  navigator.mediaDevices.getUserMedia(constraints)
  .then(function(mediaStream) {
    video.srcObject = mediaStream;
    pMediaStream = mediaStream;
  })
}

// gets available cameras
navigator.mediaDevices.enumerateDevices()
.then(function(devices) {
  var option = 0;
  devices.forEach( (device, i) => {
    console.log(device.kind + ": " + device.label + " id = " + device.deviceId);
    if (device.kind == "videoinput") {
      option++;
      opt = document.createElement("option");
      opt.text = device.label;
      if (opt.text == "") opt.text = "option " + option;
      opt.value = i;
      document.getElementById("cameraSelection").options.add(opt);
    }
  });
  if (cameraSelection.options.length < 2) cameraSelection.style.display = 'none';
  if (!cameraSelection.options.length) useLiveCam.style.display = 'none';
})
// end section 3
var puzzles = {};
  getPuzzles();
  function getPuzzles() {
    while (puzzleSelection.getElementsByTagName('li').length) {
      puzzleSelection.getElementsByTagName('li')[0].remove();
    }
    puzzles = JSON.parse(localStorage.getItem('puzzleCreatorPuzzles'));
    if (!puzzles) puzzles = {};
    for (const puzzle of Object.keys(puzzles)) {
      var option = document.createElement('li');
      option.innerHTML = puzzle;
      option.value = puzzle;
      option.id = 'select ' + puzzle;
      option.onclick = () => {
        selected.puzzle = puzzle;
        if (editPuzzleManager.style.display == "none") editPuzzleManager.style.display = "inline";
        else editPuzzleManager.style.display = "none";
        editPuzzleManager.style.top = document.getElementById('select ' + puzzle).getBoundingClientRect().bottom;
      };
      puzzleSelection.appendChild(option);
    }
  }
  function restorePuzzleSource(name, sourceLoaded) {
    var puzzle = puzzles[name];
    state.restorePuzzle = true;
    anzahlX.value = puzzle.tileAmount.x;
    anzahlY.value = puzzle.tileAmount.y;
    modeSelected(puzzle.mode);
    if (!sourceLoaded) {
      if (puzzle.fileName) {
        fileB.click();
        alert('Bitte wählen Sie die von Ihnen genutzte Datei mit dem Namen "' + puzzle.fileName + '" aus.');
      }
      if (puzzle.URL) {
        sourceURL.value = puzzle.URL;
        useURL();
      }
      if (puzzle.liveCam) {
        cameraSelection.value = puzzle.liveCam;
        changeCamera(puzzle.liveCam);
      }
    }
    state.restorePuzzle = puzzle;
    puzzleName.value = name;
    doStorePuzzle.checked = true;
  }
  function restorePuzzle(puzzle) {
    setTimeout(() => {
        positions = puzzle.positions;
        stats = puzzle.stats;
        if (sourceIsVideo.checked) {
          loopBeginning.value = puzzle.loopBeginning;
          loopEnding.value = puzzle.loopEnding;
          video.currentTime = convertTime(loopBeginning.value);
        } 
        if (puzzle.mode == "schieben") {
          movement = puzzle.movement;
          missing = puzzle.missing;
          getShortestPCMovement(true);
          movement.playerPosition = positions.wrong;
          userMovement = puzzle.userMovement;
          userMovement.index++;
          playerMovementSlider.max = userMovement.moves.length;
          playerMovementSlider.value = userMovement.index + 1;
          playMovementPos(puzzle.movementPlayerPosition, null, null, userMovement.moves);
        }
        if (puzzle.mode == "traditional") {
          rotateTiles.checked = puzzle.settings.rotateTiles;
          if (puzzle.tileBarTiles) tileSelectionBar.tiles = puzzle.tileBarTiles;
          mirrorInput.checked = puzzle.settings.mirrorInput;
          mirrorCanvas(mirrorInput.checked);
          restoreClipped();
        while (positions.wrong.filter(x => x.edit.x < -lengthPerTeil.edit.x/2).length) {
          expandSide('left');
        }
        while (positions.wrong.filter(x => x.edit.x > textur.width + lengthPerTeil.edit.x/2).length) {
          expandSide('right');
        }
        while (positions.wrong.filter(x => x.edit.y < -lengthPerTeil.edit.y/2).length) {
          expandSide('top');
        }
        while (positions.wrong.filter(x => x.edit.y > textur.height + lengthPerTeil.edit.y/2).length) {
          expandSide('bottom');
        }
      }
      layout(true, true);
    }, 500);
    stopClock.completionTime.time = puzzle.completionTime;
    stopClock.viewOriginal.time = puzzle.viewOriginalTime;
  }
  function restoreClipped() {
    for (let i = 0; i < positions.wrong.length; i++) {
      getConnectedTiles(i, true, null, true);
    }
  }
  // scroll TileSelectionBar (translate)
  function scrollTileSelection(direc, calledBy) {
    if (tutorial.state == "scrollArrowTileBarTutorial" && calledBy == "elm") goTutorialSteps(1);
    if (tutorial.state == "ScrollkeyTileBarTutorial" && calledBy == "arrowKey") goTutorialSteps(1);
    var screenScrollX = window.visualViewport.width/lengthPerTeil.sizeAdapted.x*lengthPerTeil.edit.x;
    if (screenScrollX/lengthPerTeil.edit.x > positions.wrong.length) screenScrollX = positions.wrong.length*lengthPerTeil.edit.x;
    tileSelectionBar.leftOffScreenTiles += direc;
    var scrollXBefore = tileSelectionBar.scrollX;
    tileSelectionBar.scrollX += (lengthPerTeil.edit.x + 5)*(direc*(-1));
    if (tileSelectionBar.scrollX >= lengthPerTeil.edit.x + 5) {
      tileSelectionBar.offset = 0;
      tileSelectionBar.scrollX = lengthPerTeil.edit.x + 5;
      tileSelectionBar.leftOffScreenTiles = -1;
    }
    if (tileSelectionBar.scrollX >= 0) scrollTileSelectionLeft.style.display = 'none';
    else scrollTileSelectionLeft.style.display = 'inline';
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX) {
      if (!tileSelectionBar.offset) {
        tileSelectionBar.offset = - (scrollXBefore - (-((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX));
        tileSelectionBar.elmleftBefore = document.getElementsByClassName('backToTileB')[0].style.left;
      }
      tileSelectionBar.scrollX = -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX + 1;
      tileSelectionBar.leftOffScreenTiles = tileSelectionBar.tiles.length - Math.ceil(screenScrollX/lengthPerTeil.sizeAdapted.x) + 1;
    }
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length)) + screenScrollX) scrollTileSelectionRight.style.display = 'none';
    else scrollTileSelectionRight.style.display = 'inline';
    layout(true, true);
    positionBackToTileBarButtons();
  }
  var tileSelectionBar = {canvas: tileSelectionCanvas.getContext('2d'), tiles: [], scrollX: 1, height: 0, leftOffScreenTiles: 0, offset: 0};
  tileSelectionBar.collidesMouse = () => {
    var obj = tileSelectionCanvas.getBoundingClientRect();
    return collides({x: mausx, y: mausy - scrollY + texturTop, width: 1, height: 1}, obj).boolean;
  }
  tileSelectionBar.getTilePosition = (generalPosition) => {
    for (const tile of tileSelectionBar.tiles) {
      if (tile == generalPosition) return tile;
    }
  }
  // get amount of tiles on x and y-axis to equal width and height
  function getSizeTileAmoutAdaption() {
    for (let i = 0; i < 1000; i++) {
      for (let i1 = 0; i1 < 1000; i1++) {
        if (i > 1 && i1 > 1 && !Math.abs(Math.abs(Math.round(größeAnpassenX.value/i)) - Math.abs(Math.round(größeAnpassenY.value/i1))) && i*i1 > minTileAmount.value) {
          return {x: i, y: i1};
        }
      }
    }
  }
  // adapt amount of tiles on x and y-axis to equal width and height
  function adaptTileAmount(adaptionStyleChanged) {
    if (modeSelection.value == 'traditional' && rotateTiles.checked) {
      var data = getSizeTileAmoutAdaption();
      if (data) {
        anzahlX.value = data.x;
        anzahlY.value = data.y;
      }
    }
  }
  function addElement(attr, elm, childOf, asElement) {
      var newElement = document.createElement(/*'span'*/elm);
      if (childOf && !asElement) document.getElementById(childOf).appendChild(newElement);
      else if (childOf) childOf.appendChild(newElement);
      else tests.appendChild(newElement);
      for (attrNow of Object.keys(attr)) {
        if (attrNow == 'innerText') newElement.innerText = attr[attrNow];
        else newElement.setAttribute(attrNow/*'style'*/, /*'color:' + word[i].colour*/attr[attrNow]);
      }
    }
  var lengthPerTeil = {};
  var positions = {right: [], wrong: []};
  var finished = false;
  var missing = [];
  var distinctMoves = [];
  function convertDirection(direc, degr) {
    var directions = ['top', 'right', 'bottom', 'left'];
    var direcObj = {top: 0, right: 1, bottom: 2, left: 3};
    while (degr > 0) {
      direc = directions[direcObj[direc] - 1];
      if (!direc) direc = directions[0];
      degr -= 90;
    }
    return direc;
  }
  // section 4: layout
  function showSelectedTile(tile, color) {
    canvas.fillStyle = color;
    canvas.save();
    if (state.removeTile || (!state.removeTile && modeSelection.value == "exchange")/* && modeSelection.value != "schieben"*/) canvas.translate(positions.wrong[tile].edit.x + lengthPerTeil.edit.x/2, positions.wrong[tile].edit.y + lengthPerTeil.edit.y/2);
    else canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
    canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
    canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.restore();
  }
  function showSelected() {
    for (var tile of selected.tiles) {
      showSelectedTile(tile, "rgba(255, 0, 0, 0.3)");
    }
    for (var tile of doNotChange) {
      showSelectedTile(tile, "rgba(0, 76, 255, 0.3)");
    }
  }
  function showClippingOptions() {
    for (var clip of selected.clip) {
      pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
      if ([90, 270].includes(positions.wrong[clip.sI].original.degree)) {
        pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
        pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
      }
      canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
      if (markWrong.checked && (JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) canvas.fillStyle = 'rgba(255, 0, 0, 0.83)';
      if (!tileSelectionBar.tiles.includes(clip.i)) {
        canvas.save();
        if (highHitboxVisibility.checked) {
          canvas.translate(clip.original.x, clip.original.y);
          canvas.fillRect(-((pLengthPerTeil.edit.x)/2), -((pLengthPerTeil.edit.y)/2), clip.original.width, clip.original.height);
        }
        else {
          canvas.translate(clip.x, clip.y);
          canvas.fillRect(-((pLengthPerTeil.edit.x)/2), -((pLengthPerTeil.edit.y)/2), clip.width, clip.height);
        }
        canvas.restore();
      }
    }
  }
  function layout(withoutAlert, clear, pReturn, removeTilesScreen) {
    if (state.removeTile) removeTilesScreen = true;
    if (clear && (aufgebenId.style.display == 'inline' || state.removeTile)) canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
    if (lengthPerTeil.sizeAdapted) tileSelectionCanvas.width = positions.wrong.length*(lengthPerTeil.edit.x*(lengthPerTeil.edit.x/lengthPerTeil.sizeAdapted.x));
    else if (positions.wrong.length) tileSelectionCanvas.width = positions.wrong.length*lengthPerTeil.edit.x;
    if (lengthPerTeil.sizeAdapted && (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*tileSelectionBar.tiles.length < window.innerWidth) tileSelectionBar.scrollX = 0;
    richtige = 0;
    if (modeSelection.value == "schieben") {
      for (const position of positionsBeginning) {
        if (showRemovedTiles.checked) drawPictureSegment(position, position, removeTilesScreen, null, null, null, 0.5);
      }
    }
    for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
      var i = i1;
      if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
      if (!tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i);
    }
    for (var i1 = 0; i1 < tileSelectionBar.tiles.length; i1++) {
      var i = tileSelectionBar.tiles[i1];
      drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i, tileSelectionBar.canvas, i1);
    }
    showClippingOptions();
    showSelected();
    if (stats.highestRight.right < richtige && !withoutAlert) {
      stats.highestRight = {right: richtige, turns: stats.turns};
    }
    if (stats.preOrdered == "pending") stats.preOrdered = richtige;
    if (richtige == positions.wrong?.length && !removeTilesScreen && !finished && !state.restorePuzzle && createPuzzleButton.style.display == "none") {
      if (doStorePuzzle.checked && settings.style.display != "inline") {
        delete puzzles[puzzleName.value];
        localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
      }
      stopClock.completionTime.running = 0;
      richtige = 0;
      if(!withoutAlert) {
        if (tutorial.state == "completePuzzleTutorial") goTutorialSteps(1);
        selected.tiles = [];
        finished = true;
        if (pReturn) return "noChange!";
        if (modeSelection.value == "schieben") alert("Sie haben es in " + stats.turns + " Zügen (man hätte es in " + distinctMoves.length + " Zügen oder weniger schaffen können) und insgesamt " + stats.completionTime + " Minuten geschafft! Zum Umschieben vom Originalbild hat der Computer " + movement.move.length + " Züge benötigt, um es zu zerwuseln. Ob Sie darauf jetzt stolz sein können, müssen Sie selber entscheiden ;)");
        if (modeSelection.value == "exchange") alert(`Sie haben es in ${stats.turns} Zügen und insgesamt ${stats.completionTime} Minuten geschafft! (Sie hätten es in ${positions.wrong.length - stats.preOrdered} Zügen schaffen können.) Dabei haben Sie von Anfang an von den insgesamt ${positions.wrong.length} Teilen ${stats.preOrdered} Teile an der richtigen Position gehabt.`);
        if (modeSelection.value == "traditional") alert(`Super! Sie haben das Puzzle in ${stats.completionTime} Minuten geschafft! Sie haben ${stats.turns} Mal Teile verbunden (man schafft es mit mindestens ${anzahlX.value*anzahlY.value - 1} Malen) und ${stats.unclipped} Mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} Mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} Mal ein Teil gedreht. Man hätte es mit mindestens ${stats.minimumRotations} Mal drehen schaffen können. `);
        alert(`Zudem haben Sie ${stats.viewOriginal.times} Mal für insgesamt ${stats.viewOriginal.time} Minuten auf das Originalbild geguckt.`.replace('undefined', '0'));
        if (reloadWhenFinished.checked) {
          setTimeout(function () {
            window.location.reload(false);
          }, 3000);
        }
        else alert("Bitte laden Sie die Seite neu, wenn Sie ein weiteres Puzzle erstellen wollen!");
        layout(true);
    }
  }
}
  var richtige = 0;
  function drawPictureSegment(position, segmentPosition, removeTilesScreen, i, pCanvas, i1, tileTransparency) {
    if (i1 == undefined) i1 = tileSelectionBar.getTilePosition(i);
    if (!pCanvas) pCanvas = canvas;
    else if (!state.modelEmptybar) {
      position.edit = {x: 5 + (lengthPerTeil.edit.x + 5)*i1 + lengthPerTeil.edit.x/2, y: tileSelectionBar.height/2/*5 + lengthPerTeil.edit.y/2*/, degree: 0};
    }
    pCanvas.save();
    if (modeSelection.value == "traditional" && !removeTilesScreen) pCanvas.translate(position.edit.x, position.edit.y);
    else pCanvas.translate(position.edit.x + lengthPerTeil.edit.x/2, position.edit.y + lengthPerTeil.edit.y/2);
    if (pCanvas.canvas.id == "tileSelectionCanvas") {
      pCanvas.translate(tileSelectionBar.scrollX, 0);
      tileSelectionBar.canvas.fillStyle = "red";
      if (tileSelectionBar.selectedTile?.tileI == i) {
        if ([90, 270].includes(position.original.degree)) tileSelectionBar.canvas.fillRect(-(lengthPerTeil.edit.y/2) - 5, -(lengthPerTeil.edit.x/2) - 5, lengthPerTeil.edit.y + 10, lengthPerTeil.edit.x + 10);
        else tileSelectionBar.canvas.fillRect(-(lengthPerTeil.edit.x/2) - 5, -(lengthPerTeil.edit.y/2) - 5, lengthPerTeil.edit.x + 10, lengthPerTeil.edit.y + 10);
      }
    }
    pCanvas.rotate(position.original.degree*Math.PI/180);
    if (tileTransparency) canvas.globalAlpha = tileTransparency;
    if (sourceIsPicture.checked) pCanvas.drawImage(document.getElementById('preview'), /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    else pCanvas.drawImage(video, /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // pCanvas.restore();
    canvas.globalAlpha = 1;
    // #potentialErrorCause
    if (tileTransparency != 0.5 && (((modeSelection.value != "traditional" && position.edit.x == segmentPosition.edit.x && position.edit.y == segmentPosition.edit.y) || (modeSelection.value == "traditional" && angular.equals(position.original, segmentPosition.original) && connectedTilesRotationRight(position.original))) && !removeTilesScreen && !state.removeTile && !finished)) {
      var rgbColor = hexTorgb(markRightColor.value);
      pCanvas.fillStyle = `rgba(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]}, ${rightMarkerTransparence.value})`
      if (richtigPlazierte.checked) {
        pCanvas.fillRect(-(lengthPerTeil.edit.x*rightMarkerRadius.value)/2, -(lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
      }
      richtige++;
    }
    pCanvas.restore();
    var rgbColor = hexTorgb(borderColor.value);
    pCanvas.fillStyle = `rgba(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]}, ${borderTransparency.value})`;
    if (raender.checked) {
      pCanvas.save();
      if (modeSelection.value == "traditional" && !state.removeTile) pCanvas.translate(position.edit.x, position.edit.y);
      else pCanvas.translate(position.edit.x + (lengthPerTeil.edit.x)/2, position.edit.y + (lengthPerTeil.edit.y)/2);
      pCanvas.rotate((position.original.degree)*Math.PI/180);
      if (position.border.includes("right")) pCanvas.fillRect((lengthPerTeil.edit.x)/2 - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("left")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2) + JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("top")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2) + JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      if (position.border.includes("bottom")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), ((lengthPerTeil.edit.y)/2) - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      pCanvas.restore();
    }
  }
  // end section 4
  function connectedTilesRotationRight(positionOriginal) {
    for (const direc of ['right', 'bottom', 'left', 'top']) {
      if (positionOriginal[direc]) {
        var connectedTile = getTile(positionOriginal[direc]);
        if (connectedTile != undefined && positions.wrong[connectedTile].original.degree) return false;
      }
    }
    return true;
  }
  var selected = {boolean: false, position: {x: 0, y: 0}, tiles: [], objTiles: [], clip: []};
  var lastCoord;
  function moveTile(i, i1) {
    console.log("schiebe...");
    possibleMissing = [];
    pMissing = missing[i1];
    stats.turns++;
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i]));
    if (userMovement.index < userMovement.moves.length - 1) {
      userMovement.moves.splice(userMovement.index, userMovement.moves.length - userMovement.index);
    }
    userMovement.moves.push({x: -(JSON.parse(pMissing.split(' - ')[0]) - positions.wrong[i].edit.x), y: -(JSON.parse(pMissing.split(' - ')[1]) - positions.wrong[i].edit.y), tile: i, i1: i1});
    userMovement.index++;
    playerMovementSlider.max = userMovement.moves.length;
    playerMovementSlider.value = userMovement.index + 1;
    positions.wrong[i].edit = {x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0};//.splice(side, 1);
    missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
    selected.boolean = false;
    movement.playerPosition = positions.wrong;
    userMovement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
    if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
  }
  var doNotChange = [];
  var possibleMissing = [];
  // select tiles to be removed or ignored
  function removeTile(first, calledBy) {
    if (!first && (!state.tileRemoved || calledBy == "touchmove" || calledBy == "mousemove")) {
      state.tileRemoved = true;
      setTimeout(function () {
        state.tileRemoved = false;
      }, 133);
    positions.wrong.forEach((position, i) => {
      if (position.x == checkSelected(true).x && position.y == checkSelected(true).y/*position.edit.x/lengthPerTeil.edit.x == checkSelected().x && position.edit.y/lengthPerTeil.edit.y == checkSelected().y*/) {
        if (pRemoveTile.checked && !selected.tiles.includes(i)) {
          selected.tiles.push(i);
          doNotChange = doNotChange.filter(x => x != i);
          selected.objTiles.push(JSON.stringify({x: position.edit.x - 3*position.x, y: position.edit.y - 3*position.y, degree: 0}));
        }
        else if (doNotMoveTile.checked && !doNotChange.includes(i)) {
          doNotChange.push(i);
          selected.tiles = selected.tiles.filter(x => x != i);
        }
        else if (pRemoveTile.checked && selected.tiles.includes(i)) {
          for (var i1 = 0; i1 < selected.tiles.length; i1++) {
            if (selected.tiles[i1] == i) {
              selected.tiles.splice(i1, 1);
              selected.objTiles.splice(i1, 1);
              }
            }
          }
          else if (doNotMoveTile.checked && doNotChange.includes(i)) {
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
            if (doNotChange[i1] == i) {
              doNotChange.splice(i1, 1);
              }
            }
          }
        }
    });
  }
  if (first && modeSelection.value != "schieben" && !state.restorePuzzle && tutorial.state == "") alert("Hier können Sie nun auf die Teile klicken, die Sie nicht im Puzzle haben wollen! Sie können gedrückt halten, um mehrere gleichzeitig anzuwählen!");
    layout(true, true, undefined, true);
    state.removeTile = true;
  }
  // lists coordinates of all entered tiles
  function listCoordinates(tiles) {
    var list = [];
    for (const tile of tiles) {
      list.push(positions.wrong[tile].edit.x + ' - ' + positions.wrong[tile].edit.y);
    }
    return list;
  }
  // PC moving the tiles in schieben mode
  function verschiebenPC() {
    var missingArray = [];
    var workingNumbers = [];
    var maleZurrück = {number: 0, normalSlide: 0};
    for (var i = 0; i < positions.wrong.length; i++) {
      if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i);
    }
    var counter = 0;
    for (var i = 0; (i < /*positions.wrong.length + */JSON.parse(anzahlVerschieben.value) || (richtigeCheck.checked && richtige > anzahlRichtige.value)) && (!zurrückVermeiden.checked || counter < 100000 || counter < anzahlVerschieben.value); i++) {
      var side = workingNumbers[Math.round(Math.random()*(workingNumbers.length - 1))];
      if (!workingNumbers.length) break;
      missing.forEach((pMissing, i1) => {
      try {
      if (!listCoordinates(doNotChange).includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y) && (((zurrückVermeiden.checked && ((missingArray.length < 1 || workingNumbers.length == 0/*positions.wrong[side].edit.x != missingBefore.data.edit.x && positions.wrong[side].edit.y != missingBefore.data.edit.y*/) || ((maleZurrück.number < anzahlVerboten.value && !((maleZurrück.normalSlide/5 + "").includes("."))) || !(missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y)/*missingBefore.data.edit.x != missing.data.edit.x && missingBefore.data.edit.y != missing.data.edit.y*/)))) || !zurrückVermeiden.checked) && ((pMissing == (positions.wrong[side].edit.x + lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y) /*right*/ || (pMissing ==
      (positions.wrong[side].edit.x - lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y)/*left*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y + lengthPerTeil.edit.y))/*down*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y - lengthPerTeil.edit.y))/*up*/))) {
      if (zurrückVermeiden.checked && (missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y))) {
        maleZurrück.number++;
      }
      else maleZurrück.normalSlide++;
      missingArray.push(pMissing);
      //console.log(missingArray);
      // movement.positions.unshift(JSON.parse(JSON.stringify(positions)));
      var ablage = JSON.parse(JSON.stringify(positions.wrong[side]));
      movement.move.unshift({x: (pMissing.split(' - ')[0] - ablage.edit.x), y: (pMissing.split(' - ')[1] - ablage.edit.y), tile: side});
      // movement.missing.unshift(JSON.parse(JSON.stringify(missingArray)));
      positions.wrong[side].edit = JSON.parse(JSON.stringify({x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0}));//.splice(side, 1);
      textur.width = textur.width;
      layout(true);
      // for (var i1 = 0; difficultSchieben.checked && i1 < movement.positions.length; i1++) {
        //   if (angular.equals(positions, movement.positions[i1])/* && angular.equals(missing, movement.missing[i1])*/) {
          //     positions = JSON.parse(JSON.stringify(movement.positions[1]));
          //     missing = JSON.parse(JSON.stringify(movement.missing[1]));
          //     movement.positions.splice(0, 1);
          //     movement.missing.splice(0, 1);
          //     maleZurrück.number++;
          //     i1 = movement.positions.length;
          //     i--;
          //     for (var i2 = 0; i2 < workingNumbers.length; i2++) {
            //       if (workingNumbers[i2] == side) workingNumbers.splice(i2, 1);
            //     }
            //   }
            // }
            // if (i1 != movement.positions.length + 1) {
      missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
      workingNumbers = [];
      for (var i1 = 0; i1 < positions.wrong.length; i1++) {
        if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i1);
      }
      // }
    }
      else {
        i--;
        for (var i1 = 0; i1 < workingNumbers.length; i1++) {
          if (workingNumbers[i1] == side) workingNumbers.splice(i1, 1);
        }
      }
    } catch (e) {
      //console.log("ein Error bei der if Abfrage!!! + (" + e + ")");
      i = positions.wrong.length;
    }
  });
    counter++;
    }
    if (layout(undefined, true, true) != undefined) verschiebenPC();
  }
  var movement = {move: [], startPosition: []};
  var mausx;
  var mausy;
  var stats = {turns: 0, highestRight: {turns: 0, right: 0}, rotated: 0, unclipped: 0, wrongClipped: 0, viewOriginal: {times: 0}, minimumRotations: 0};
  document.onmousemove = readMouseMove
  var originalMausX;
  // section 5: most user inputs
  var pcScrolls = false;
  window.addEventListener('scroll',()=>{
    if (pcScrolls) pcScrolls = false;
    else {
      selected.position = {x: selected.position.x + (state.scrollX - scrollX), y: selected.position.y + (state.scrollY - scrollY), manualScrolling: true};
      if (["manuallyScrollingTutorial", "scrollMobileScrollingTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    } 
    if (scrollY < texturTop - (showSettings.getBoundingClientRect().bottom + scrollY) && settings.style.display == "block") selectBackToBarB.style.display = 'none';
    else if (['inline', ''].includes(tileSelectionCanvas.style.display) && shuffleStyle.value == "listTiles") selectBackToBarB.style.display = 'inline';
    adaptMobileControlsPosition();
    if (keepScrolling.checked) folgenMouseMove();
    state.scrollX = scrollX;
    state.scrollY = scrollY;
  });
  window.visualViewport.addEventListener("resize", resized);
  var scale = 1;
  function resized (event) {
    if (scale != visualViewport.scale) {
      setTimeout(() => {
        state.shift = false;
        state.shiftBySwipe = false;
      }, 500);
      if ((scale < visualViewport.scale && tutorial.state == "zoomInTutorial") || (scale > visualViewport.scale && tutorial.state == "zoomOutTutorial")) goTutorialSteps(1);
      scale = visualViewport.scale;
      if (state.rightScroll < 0 && (positions.wrong.reduce((acc, val) => val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 < acc ? val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 : acc, textur.width)) > visualViewport.pageLeft) {
      var distance = (positions.wrong.reduce((acc, val) => val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 < acc ? val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 : acc, textur.width)) - visualViewport.pageLeft;
      state.rightScroll += distance;
      if (mirrorInput.checked) canvas.translate(distance, 0);
      else canvas.translate(-distance, 0);
    }
    if (state.rightScroll > 0 && (visualViewport.pageLeft + visualViewport.width - texturLeft) > positions.wrong.reduce((acc, val) => val.edit.x + lengthPerTeil.edit.x - state.rightScroll > acc ? val.edit.x + lengthPerTeil.edit.x - state.rightScroll : acc, 0)) {
      var distance = (visualViewport.pageLeft + visualViewport.width - texturLeft) - positions.wrong.reduce((acc, val) => val.edit.x + lengthPerTeil.edit.x - state.rightScroll > acc ? val.edit.x + lengthPerTeil.edit.x - state.rightScroll : acc, 0)
      state.rightScroll -= distance;
      if (mirrorInput.checked) canvas.translate(-distance, 0);
      else canvas.translate(distance, 0);
    }
    if (state.upScroll < 0 && (positions.wrong.reduce((acc, val) => val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 < acc ? val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 : acc, textur.height)) > visualViewport.pageTop) {
      var distance = (positions.wrong.reduce((acc, val) => val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 < acc ? val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 : acc, textur.height)) - visualViewport.pageTop;
      state.upScroll += distance;
      canvas.translate(0, -distance);
    }
    if (state.upScroll > 0 && (visualViewport.pageTop + visualViewport.height - texturTop) > positions.wrong.reduce((acc, val) => val.edit.y + lengthPerTeil.edit.y - state.upScroll > acc ? val.edit.y + lengthPerTeil.edit.y - state.upScroll : acc, 0)) {
      var distance = (visualViewport.pageTop + visualViewport.height - texturTop) - positions.wrong.reduce((acc, val) => val.edit.y + lengthPerTeil.edit.y - state.upScroll > acc ? val.edit.y + lengthPerTeil.edit.y - state.upScroll : acc, 0)
      state.upScroll -= distance;
      canvas.translate(0, distance);
    }
    layout(true, true);
   }
  }
  function adaptTitlesPosition() {
    var vis = {rotateLeft: rotateLeftTitle.style.display, rotateRight: rotateRightTitle.style.display, selectMultiple: selectMultipleTitle.style.display, swipe: swipeTitle.style.display};
    rotateLeftTitle.style.display = "inline";
    rotateRightTitle.style.display = "inline";
    selectMultipleTitle.style.display = "inline";
    rotateLeftTitle.style.top = rotateLeftSymbol.getBoundingClientRect().bottom + scrollY + 20;
    rotateRightTitle.style.top = rotateRightSymbol.getBoundingClientRect().bottom + scrollY + 20;
    selectMultipleTitle.style.top = selectMultipleSymbol.getBoundingClientRect().bottom + scrollY + 20;
    rotateLeftTitle.style.left = rotateLeftSymbol.getBoundingClientRect().left + rotateLeftSymbol.getBoundingClientRect().width/2 - rotateLeftTitle.getBoundingClientRect().width/2;
    rotateRightTitle.style.left = rotateRightSymbol.getBoundingClientRect().left + rotateRightSymbol.getBoundingClientRect().width/2 - rotateRightTitle.getBoundingClientRect().width/2;
    selectMultipleTitle.style.left = selectMultipleSymbol.getBoundingClientRect().left + selectMultipleSymbol.getBoundingClientRect().width/2 - selectMultipleTitle.getBoundingClientRect().width/2;
    swipeTitle.style.display = "inline";
    swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + scrollY + 20;
    swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
    rotateLeftTitle.style.display = vis.rotateLeft;
    rotateRightTitle.style.display = vis.rotateRight;
    selectMultipleTitle.style.display = vis.selectMultiple;
    swipeTitle.style.display = vis.swipe;
  }
  function adaptMobileControlsPosition() {
    mobileControls.style.top = (visualViewport.offsetTop/* - 7*/ + 2) + 'px';
    mobileControls.style.left = (visualViewport.offsetLeft + 300/visualViewport.scale) + 'px';
    mobileControls.style.fontSize =  (5/visualViewport.scale) + 'vh';
    for (const elm of document.getElementsByClassName('mobileControlsElm')) {
      elm.style.width = 44/(visualViewport.scale); 
      elm.style.height = 44/(visualViewport.scale); 
    }
    var pos = {x: visualViewport.offsetLeft, y: visualViewport.offsetTop};
    setTimeout(() => {
      if (pos.x != visualViewport.offsetLeft || pos.y != visualViewport.offsetTop) adaptMobileControlsPosition();
      else {
        for (const elm of document.getElementsByClassName('speech')) {
          elm.style.fontSize = 25/visualViewport.scale + 'px';
          elm.style.maxWidth = visualViewport.width/4 + 'px';
          elm.style.padding = 20/visualViewport.scale + 'px';
        }
        adaptTitlesPosition();
      }
    }, 40);
    document.getElementById('tutorial').style.maxHeight = window.innerHeight - mobileControls.getBoundingClientRect().bottom - 10;
    if (modeSelection.value != "traditional") document.getElementById('tutorial').style.maxHeight = window.innerHeight;
  }
  // #importantUserInputs
  function readMouseMove(e) {
    mausx = e.clientX + scrollX - texturLeft + state.rightScroll;
    mausy = e.clientY + scrollY - texturTop + state.upScroll;
    if (selected.position.manualScrolling) {
      selected.position = {x: mausx, y: mausy};
      selected.position.manualScrolling = false;
    }
    if (gerät != "Handy") originalMausX = e.clientX;
    if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width) - mausx; // - scrollX;
    // /*96*/32// - 43;
    // if (scrollY > 32) mausy += 32;
    if (gerät == "PC") folgenMouseMove("mousemove");
  }
  window.scroll(0, 0);
  var texturTop = textur.getBoundingClientRect().top + scrollY;
  var state = {mouse: "up", shift: false, newTileSelected: false, buttons: {}, coord: {x: 0, y: 0}, backToBar: false, rightScroll: 0, upScroll: 0, userSource: 'Picture', scrollX: 0, scrollY: 0};
  var texturLeft = textur.getBoundingClientRect().left;
  // #importantUserInputs
  // if (gerät == "Handy") {
    textur.addEventListener('touchmove', touch, {passive:false});
    textur.addEventListener('touchstart', touch);
    textur.addEventListener('touchend', touch);
    tileSelectionCanvas.addEventListener('touchmove', touch, {passive:false});
    tileSelectionCanvas.addEventListener('touchstart', touch);
    tileSelectionCanvas.addEventListener('touchend', touch);
    function touch(ev) {
      if (!scrollable.checked && ev.type == "touchmove" && settings.style.display != "inline" && (aufgebenId.style.display == "inline" || state.removeTile) && (!scrollOnBlanc.checked || selected.tiles.length)) {
        if (event.cancelable) ev.preventDefault();
        else console.log("event not cancable!");
      }
      if ((aufgebenId.style.display == "inline" || removeTilesFinishedB.style.display == "inline") && (!ev.touches[0] || (ev.touches[0] && !collides({x: ev.touches[0]["pageX"] - scrollX, y: ev.touches[0]["pageY"] - scrollY, width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean))) {
    if (ev.touches[1] && aufgebenId.style.display == "inline") {
      state.shift = true;
      state.shiftBySwipe = true;
      selected.tiles = [];
      mouseDown();
    }
    if (ev.type == "touchend") {
      console.log('touchEnd');
    }
    // #potentialErrorCause
    if ((state.removeTile || ((swipeSteuerung.checked || modeSelection.value != "exchange"))) && ev.touches[0]) {
      var pTexturLeft = textur.getBoundingClientRect().left + scrollX;
      if (pTexturLeft < 0) pTexturLeft = 0;
      mausx = ev.touches[0]["pageX"] - pTexturLeft + state.rightScroll;
      mausy = ev.touches[0]["pageY"] - texturTop + state.upScroll;// - 32;
      if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width + scrollX) - mausx;
      // TODO: if statement needed?
      if (tileSelectionBar.collidesMouse() || gerät == "Handy") originalMausX = ev.touches[0]["pageX"];
    }
    if (!scrollable.checked) {
    if (ev.type == "touchstart" && !ev.touches[2] && !collides({x: mausx, y: mausy + texturTop, width: 1, height: 1}, selectBackToBarB.getBoundingClientRect()).boolean) {
      mouseDown(null, ev.touches[0] == undefined && collides({x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"], width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean);
    }
    if (ev.type == "touchend") {
      // #potentialErrorCause
      // setTimeout(function () {
        mouseUp();
        layout(true, true);
      // }, 100);
    }
    if (ev.type == "touchmove" && (modeSelection.value == "traditional" || state.removeTile || tutorial.state != "")) {
      folgenMouseMove("touchmove");
    }
  }
    }
    adaptMobileControlsPosition();
  }
  // }
  function tileSelected() {
    for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
      var i = positions.layoutOrder[i1];
      var coord = positions.wrong[i].edit;
      var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
      if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
      if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
        return true;
      }
    }
  }
  var tutorial = {state: "", index: 0};
  function mouseDown(elmCalled, touchStart) {
    state.tileChanged = false;
    if (gerät == "PC" || !elmCalled) {
      selected.tile = checkSelected();
    if (swipeSteuerung.checked && modeSelection.value == "exchange" && selected.tile && !selected.boolean.click && !scrollable.checked) {
      selected.coord = {x: selected.tile.x, y: selected.tile.y};
        selected.tiles = [getTileIByCoord(selected.tile)];
        layout();
      selected.boolean.swipe = true;
    }
    delete state.rorated;
    tileSelectionBar.swipePosition = originalMausX;
    if (modeSelection.value == "traditional") {
    if (state.mouse == "up" && !automaticTileSelectionReset.checked && state.removeTile) state.mouse = "downNow";
    if (state.mouse != "downNow") state.mouse = "down";
    if (((selected.tiles.length && !state.shift) || state.removeTile) && !automaticTileSelectionReset.checked && state.mouse != "downNow") {
      mouseUp(true);
      if ((tutorial.state == "clickUnselectMoveTutorial" && !state.removeTile && selected.tiles.length) || ["unselectUnclippStandardTutorial", "unselecTileAfterTileBarTilePlacementTutorial"].includes(tutorial.state)) {
        goTutorialSteps(1);
        if (tutorial.state != "SecondPlaceTileTutorial" && !state.helpTutorial) automaticTileSelectionReset.checked = true;
      }
      if (["getClippingOptionConnectTileTutorial", "manuallyScrollingTutorial", "automaticScrollingTutorial", "moveMouseMoveTutorial"].includes(tutorial.state)) {
        goTutorialSteps(-1);
      }
      if (tutorial.state == "rotateTileTutorial") goTutorialSteps(-2);
      if (!state.removeTile) selected.tiles = [];
      else state.mouse = "up";
      state.shiftBefore = false;
    }
    else {
      if (state.mouse = "downNow") state.mouse = "down";
      if (gerät == "Handy" && selectMultiple.checked) state.shift = true;
      state.coord = checkSelected(true);
      if (modeSelection.value == "traditional") {
        // tile on field
        if (tileSelectionBar.selectedTile?.tileI != undefined && ((tileSelectionBar.selectedTile.byUser && autoSelectTileBar.checked) || !tileSelected()) && !tileSelectionBar.collidesMouse() && state.backToBar === false) {
          if (["placeTileOnFiledTutorial", "SecondPlaceTileTutorial"].includes(tutorial.state)) goTutorialSteps(1);
          var i = tileSelectionBar.selectedTile;
          selected.tiles.push(i.tileI);
          positions.layoutOrder = positions.layoutOrder.filter(x => x != i.tileI);
          positions.layoutOrder.push(i.tileI);
          tileSelectionBar.tiles.splice(i.i, 1);
          // tileSelectionBar.tiles = tileSelectionBar.tiles.filter(x => x != undefined);
          if (!autoSelectTileBar.checked || !tileSelectionBar.tiles.length) tileSelectionBar.selectedTile = undefined;
            else {
              setTimeout(function () {
                tileSelectionBar.selectedTile.byUser = false;
                if (tileSelectionBar.selectedTile.i >= tileSelectionBar.tiles.length) tileSelectionBar.selectedTile.i--;
                tileSelectionBar.selectedTile.tileI = tileSelectionBar.tiles[tileSelectionBar.selectedTile.i];
                layout();
              }, 10);
            }
          positions.wrong[i.tileI].edit = {x: mausx, y: mausy, degree: 0};
          state.placeTile = true;
          scrollTileSelection(0);
        }
        // selected.tiles = [];
        selected.position = {x: mausx, y: mausy};
        for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
          var i = positions.layoutOrder[i1];
          var coord = positions.wrong[i].edit;
          var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
          if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
          if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height) {
            state.oldTileSelected = true;
          }
          if (tutorial.state == "twoFingersDownUnclippTutorial" && state.shiftBySwipe && getConnectedTiles(selected.tiles[0], true).length >= 2) goTutorialSteps(1);
          if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && (!selected.tiles.includes(i) || (gerät == "Handy" && (rotatesLeft.checked || rotatesRight.checked))) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
            if (!state.placeTile) {
              if (!selected.tiles.includes(i)) selected.tiles.push(i);
              positions.layoutOrder = positions.layoutOrder.filter(x => x != i);
              positions.layoutOrder.push(i);
              if (["tileClickMoveTutorial", "holdMouseMoveTutorial", "moveMouseMoveTutorialAlternative", "selectTileConnectTileTutorial", "selectTileScrollingTutorial", "selectTileAutomaticScrollingTutorial", "selectTileMobileTurorial", "selectTileConnectTileMobileTutorial", "selectTileMobileTwoFingersUnclippTutorial"].includes(tutorial.state) || (["selectTileMobileShiftMultipleUnclippTutorial"].includes(tutorial.state) && selected.tiles.length >= 2 && getConnectedTiles(selected.tiles[0], true).length >= 3) || (["selectTileStandardUnclippTutorial", "selectTileAlternativeUnclippTutorial", "selectTileMobileShiftUnclippTutorial"].includes(tutorial.state) && getConnectedTiles(selected.tiles[0], true).length >= 2)) {
                goTutorialSteps(1);
              }
              if (!elmCalled && !touchStart && rotateTiles.checked) {
                if (rotatesRight.checked) {
                  rotateSelected(90);
                  if (tutorial.state == "rotateRightMobileTutorial") goTutorialSteps(1);
                }
                if (rotatesLeft.checked) {
                  rotateSelected(-90);
                  if (tutorial.state == "rotateLeftMobileTutorial") goTutorialSteps(1);
                }
              }
            }
            if (state.backToBar !== false) {
              if (["backToTileBarPlusBTutorial", "selectBackToBarTileZurückInLeisteTutorial"].includes(tutorial.state)) goTutorialSteps(1);
              // tileSelectionBar.tiles.push(i);
              tileSelectionBar.tiles.splice(state.backToBar, 0, i);
              if (autoSelectTileBar.checked && tileSelectionBar.tiles.length == 1) {
                state.setSelected = {i: state.backToBar, tileI: i};
                setTimeout(function() {
                  tileSelectionBar.selectedTile = state.setSelected;
                }, 10);
              }
              document.getElementsByClassName('backToTileB')[state.backToBar].style.backgroundColor = '';
              selectBackToBarB.style.backgroundColor = '';
              state.backToBar = false;
              unclipp(i);
              mouseDown();
            }
            layout(true);
            state.newTileSelected = true;
          }
        }
        if (!state.newTileSelected && !state.oldTileSelected && !automaticTileSelectionReset.checked && !state.removeTile) selected.tiles = [];
        state.placeTile = false;
        tileSelectionBar.tiles.forEach((tileI, i) => {
          var tile = positions.wrong[tileI];
          if (mausx > (5 + lengthPerTeil.sizeAdapted.x)*i + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && mausx < (5 + lengthPerTeil.sizeAdapted.x)*(i + 1) + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && tileSelectionBar.collidesMouse()) {
            tileSelectionBar.selectedTile = {i: i, tileI: tileI, byUser: true};
            if (rotatesLeft.checked) rotateTile(tileI, -90);
            if (rotatesRight.checked) rotateTile(tileI, 90);
            if (["MouseDownScrollTileBarTutorial", "selectTileBarTileTutorial", "selectTileTileBarZurückInLeisteTutorial"].includes(tutorial.state)) goTutorialSteps(1);
            layout();
          }
        });
        folgenMouseMove("mouseDown");
      }
    }
  }
  else {
    state.coord = checkSelected(true);
    state.mouse = "down";
    if (state.removeTile) folgenMouseMove("mouseDown");
    if (tutorial.state == "mouseMoveExchangeAlternativeTutorial") goTutorialSteps(-1);
    if (["mouseDownSelectFirstExchangeAlternativeTutorial", "mouseDownUnselectAlternativeTutorial"].includes(tutorial.state)) {
      goTutorialSteps(1);
    }
  }
  }
}
  // #importantUserInput
  function folgenMouseMove(calledBy) {
    if (modeSelection.value == "exchange" && JSON.stringify(checkSelected()) != JSON.stringify(selected.coord)) {
      state.tileChanged = true;
      if (["mouseMoveExchangeAlternativeTutorial", "moveMouseOutUnselectAlternativeTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
    if (state.tileChanged && JSON.stringify(checkSelected()) == JSON.stringify(selected.coord) && tutorial.state == "moveMouseInUnselectAlternativeTutorial") goTutorialSteps(1);
    if ((["moveMouseMoveTutorialAlternative", "moveMouseMoveTutorial", "moveTileMobileTutorial", "moveTileShiftUnclippTutorial", "moveTileShiftMultipleUnclippTutorial", "moveTileTwoFingersUnclippTutorial"].includes(tutorial.state) || (tileSelectionBar.collidesMouse() && tutorial.state == "moveMouseScrollTileSelectionBarTutorial")) && (calledBy == "mousemove" || calledBy == "touchmove") ) {
      if ((tutorial.state == "moveMouseMoveTutorial" && rotateTileTutorial.checked) || (tutorial.state == "moveMouseMoveTutorialAlternative" && rotateTileTutorialAlternative.checked)) goTutorialSteps(1);
      goTutorialSteps(1);
    }
    if (state.mouse == "down" && tileSelectionBar.collidesMouse() && tutorial.state == "MouseDownScrollTileBarTutorial" && calledBy != "mousedown") goTutorialSteps(1);
    if (tileSelectionBar.collidesMouse()) mausx = originalMausX;
    selected.clip = [];
    if (state.mouse == "down" && state.removeTile) canvasClicked(calledBy);
    positionBackToTileBarButtons(true);
    if (state.mouse == "down" && !state.removeTile && modeSelection.value == "traditional") {
      if (calledBy != "mouseDown") selectMultiple.checked = false;
      // select clipped
      for (var tile of selected.tiles) {
        var objTile = positions.wrong[tile];
        if (gerät == "PC") {
        if (mirrorInput.checked && originalMausX - lengthPerTeil.edit.x/2 < 0) {
          textur.width += 15;
          expandSide('right', true); 
        }
        if (!mirrorInput.checked && objTile.edit.x + lengthPerTeil.edit.x > textur.width) expandSide('right'); // textur.width += lengthPerTeil.edit.x;
        if (objTile.edit.y + lengthPerTeil.edit.y > textur.height) expandSide('bottom'); // textur.height += lengthPerTeil.edit.y;
      }
        for (var clipp of clipped) {
          var newTile = clipp.split(' - ').filter(x => !selected.tiles.includes(JSON.parse(x)))[0];
          if (!state.shift && !state.shiftBefore && clipp.split(' - ').includes(tile + "") && newTile) {
            selected.tiles.push(JSON.parse(newTile));
            positions.layoutOrder = positions.layoutOrder.filter(x => x != JSON.parse(newTile));
            positions.layoutOrder.push(JSON.parse(newTile));
          }
        }
        // unclipp
        if (((state.shift && automaticTileSelectionReset.checked) || (!automaticTileSelectionReset.checked && !state.shift && state.shiftBefore)) && calledBy != "mouseDown") {
          unclipp(tile);
          state.shiftBySwipe = false;
        }
        // positions.wrong.forEach((position, i) => {
        //   if (((objTile.original?.left?.x == position.original?.x && objTile.original?.left?.x != undefined && objTile.original?.left?.y == position.original?.y) || (objTile.original?.top?.x == position.original?.x && objTile.original?.top?.x != undefined && objTile.original?.top?.y == position.original?.y) || (objTile.original?.wrong?.x == position.original?.x && objTile.original?.wrong?.x != undefined && objTile.original?.wrong?.y == position.original?.y) || (objTile.original?.bottom?.x == position.original?.x && objTile.original?.bottom?.x != undefined && objTile.original?.bottom?.y == position.original?.y)) && !selected.tiles.includes(i)) {
        //     selected.tiles.push(i);
        //   }
        // });
        if ((automaticTileSelectionReset.checked || !state.shift)) {
          positions.wrong[tile].edit.x += mausx - selected.position.x;
          positions.wrong[tile].edit.y += mausy - selected.position.y;
          // check clicking
          checkPossibleClipping(tile);
       }
      }
      if ((automaticTileSelectionReset.checked || !state.shift)) {
        deleteFurtherClipOptions();
        playClippingSound();
        selected.position = {x: mausx, y: mausy, manualScrolling: selected.position.manualScrolling};
        layout(false, true);
      }
    }
  }
  // deletes clip options that apply to the same tile but are further away
  function deleteFurtherClipOptions() {
    nearestTile = {};
    selected.clip.forEach((clip, i1) => {
      if (!getConnectedTiles(clip.sI, true).includes(nearestTile[clip.i]?.clip.sI)) {
        if (!nearestTile[clip.i] || clip.distance < nearestTile[clip.i].clip.distance) {
          if (nearestTile[clip.i]) selected.clip.splice(nearestTile[clip.i].i, 1);
          nearestTile[clip.i] = {clip: clip, i: i1};
        }
        else if (clip.distance >= nearestTile[clip.i].clip.distance) {
          selected.clip.splice(i1, 1);
        }
      }
      // sI
      if (!getConnectedTiles(clip.i, true).includes(nearestTile[clip.sI]?.clip.i)) {
      if (!nearestTile[clip.sI] || (clip.distance < nearestTile[clip.sI].clip.distance)) {
        if (nearestTile[clip.sI]) selected.clip.splice(nearestTile[clip.sI].i, 1);
        nearestTile[clip.sI] = {clip: clip, i: i1};
      }
      else if (clip.distance > nearestTile[clip.sI].clip.distance) {
        selected.clip.splice(i1, 1);
      }
    }
    });
    for (let i1 = 0; i1 < selected.clip.length; i1++) {
      if (selected.clip[i1 + 1] && !getConnectedTiles(selected.clip[i1].i, true).includes(selected.clip[i1 + 1].i)) {
        if (selected.clip[i1].distance <= selected.clip[i1 + 1].distance) selected.clip.splice(i1 + 1, 1);
        else selected.clip.splice(i1, 1);
      }
    }
  }
  var nearestTile = {};
  // #importantUserImput
  function mouseUp(byUnselection) {
    if (["moveMouseMoveTutorialAlternative", "moveMouseScrollTileSelectionBarTutorial", "moveTileMobileTutorial", "getClippingOptionConnectTileMobileTutorial", "moveTileShiftUnclippTutorial", "moveTileTwoFingersUnclippTutorial"].includes(tutorial.state)) {
      if (tutorial.state == "moveTileTwoFingersUnclippTutorial") selected.tiles = [];
      goTutorialSteps(-1);
    }
    if (tutorial.state == "rotateTileTutorialAlternative") goTutorialSteps(-2);
    if (tutorial.state == "releaseMoveTutorial") {
      goTutorialSteps(1);
    }
    if (["getClippingOptionConnectTileTutorial", "manuallyScrollingTutorial", "automaticScrollingTutorial", "moveMouseOutUnselectAlternativeTutorial"].includes(tutorial.state) && (automaticTileSelectionReset.checked || modeSelection.value != "traditional")) {
      goTutorialSteps(-1);
    }
    setTimeout(() => {
      if (tutorial.state == "selectSecondExchangeNormalTutorial" && !selected.boolean.click) goTutorialSteps(-1);
    }, 500);
    if (tutorial.state == "unselectAlternativeUnclippTutorial" && !state.helpTutorial) {
      automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
    }
    if (["mouseMoveExchangeAlternativeTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
    if (["moveMouseInUnselectAlternativeTutorial"].includes(tutorial.state)) goTutorialSteps(-2);
    if (["unselectAlternativeUnclippTutorial", "unselectTileScrollingTutorial", "stopScrollingAutomaticScrollingTutorial", "stopScrollingTileBarTutorial", "releaseTileMobileTutorial", "releaseFingerMobileShiftTutorial", "releaseFingerMobileMultiShiftTutorial", "releaseFingerMobileTwoFingersTutorial", "mouseUpExchangeAlternativeTutorial"].includes(tutorial.state) || (automaticTileSelectionReset.checked && tutorial.state == "unselecTileAfterTileBarTilePlacementTutorial") || (tutorial.state == "releaseTwoFingersUnclippTutorial" && state.shiftBySwipe)) {
      goTutorialSteps(1);
    }
    if (swipeSteuerung.checked && modeSelection.value == "exchange" && checkSelected()) {
      canvasClicked('mouseup');
    }
    if (automaticTileSelectionReset.checked || !selected.tiles.length || (state.removeTile && (automaticTileSelectionReset.checked)) || modeSelection.value != "traditional") {
      state.mouse = "up";
      if (tutorial.state == "releaseShiftAlternativeUnclippTutorial" && !state.helpTutorial) {
        unselectAlternativeUnclippTutorial.checked = true;
        automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
      }
    }
    if (gerät == "Handy" && !selectMultiple.checked && !state.shiftBySwipe) state.shift = false;
    if (automaticTileSelectionReset.checked) state.shiftBefore = false;
    if (modeSelection.value == "traditional" && (!state.rotated || gerät == "PC")) {
      state.newTileSelected = false;
      state.oldTileSelected = false;
      if (automaticTileSelectionReset.checked || byUnselection || gerät == "Handy") {
      var bClipped = false;
      for (var clip of selected.clip) {
        if (!tileSelectionBar.tiles.includes(clip.i)) {
        if ((JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) stats.wrongClipped++;
        var directionOpposite = {left: 'right', top: 'bottom', right: 'left', bottom: 'top'};
        positions.wrong[clip.i].original[clip.direction] = {x: positions.right[clip.sI].original.x, y: positions.right[clip.sI].original.y};
        positions.wrong[clip.sI].original[directionOpposite[clip.direction]] = {x: positions.right[clip.i].original.x, y: positions.right[clip.i].original.y};
        var differ = {x: (clip.selected.x - positions.wrong[clip.sI].edit.x), y: (clip.selected.y - positions.wrong[clip.sI].edit.y)};
        for (var tile of selected.tiles) {
          positions.wrong[tile].edit.x += differ.x;
          positions.wrong[tile].edit.y += differ.y;
        }
        clipped.push(clip.i + ' - ' + clip.sI);
        bClipped = true;
        for (var tile of selected.tiles) {
        // do more clipping if needed
        checkPossibleClipping(tile, true);
      }
      deleteFurtherClipOptions();
      }
    }
    if (selected.clip.length && bClipped) {
      new Audio('https://adi.nicolaiweitkemper.de/Sounds/helpTheTrain/weiche.mp3').play();
      console.log("clipping...");
      if ((["clipTileTutorial", "clipTileMobileTutorial"].includes(tutorial.state)) || (tutorial.state == "clippSecondTutorial" && getConnectedTiles(selected.tiles[0], true).length >= 4) || (tutorial.state == "clippSecondMobileTutorial" && getConnectedTiles(selected.tiles[0], true).length >= 5)) {
        if (!tutorial.state.includes('Mobile') && !state.helpTutorial) automaticTileSelectionReset.checked = false;
        goTutorialSteps(1);
      }
      stats.turns++;
      // selectMultiple.checked = false;
      state.shift = false;
      selected.tiles = [];
    }
  }
  selected.clip = [];
}
if (selected.tiles.length && !state.shift && !state.removeTile && automaticTileSelectionReset.checked && modeSelection.value == "traditional") selected.tiles = [];
delete state.rotated;
layout(false, true);
  if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
  if (tutorial.state == "unclippTileAlternativeUnclippTutorial" && state.mouse == "up") {
    goTutorialSteps(-1);
    selected.tiles = [];
  }
}
  function rotateTile(tile, direction) {
    if (mirrorInput.checked) direction *= -1;
    positions.wrong[tile].original.degree = getDegreeAfterRotation(positions.wrong[tile].original.degree, direction);
    stats.rotated++;
  }
  function getDegreeAfterRotation(degree, direction) {
    degree += direction;
    if (degree < 0) degree = 270;
    if (degree > 270) degree = 0;
    return degree;
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  document.onkeyup = function(event) {
    if (event.key == "Shift" && state.shift) {
      state.shift = false;
      if (automaticTileSelectionReset.checked) selected.tiles = [];
      if (["selectTileStandardUnclippTutorial", "selectTileAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
      if (tutorial.state == "releaseShiftStandardUnclippTutorial") goTutorialSteps(1);
      if (tutorial.state == "unclippTileAlternativeUnclippTutorial") goTutorialSteps(-2);
      if (tutorial.state == "releaseShiftAlternativeUnclippTutorial") {
        goTutorialSteps(1);
        if (unselectAlternativeUnclippTutorial.checked) {
          goTutorialSteps(1);
        }
      }
    }
    if (event.key == "Escape") {
      selected.tiles = [];
    }
    // if (aufgebenId.style.display == "none") layout();
  }
  // end section 5
  // section 6: rotate tile(s)
    // #importantUserInputs
    document.onkeydown = function(event) {
      if (event.key == "F1") {
        if (tutorial.state == "") {
          if (!event.changeElement) {
            state.helpTutorial = true;
            startTutorial(true);
            showTutorialB.innerHTML = showTutorialB.innerHTML.replace('anzeigen', 'verstecken');
          }
          if (shuffleStyle.value != "listTiles") tileSelectionBarTutorial.style.display = "none";
          // traditional mode: standard/alternative visibility
          completePuzzleTutorialDiv.style.display = "none";
          moveStandardPC.style.display = "block";
          moveAlternativePC.style.display = "block";
          moveStyleStandardUnclipp.style.display = "block";
          moveStyleAlternativeUnclipp.style.display = "block";
          if (automaticTileSelectionReset.checked) {
            moveStandardPC.style.display = "none";
            moveStyleStandardUnclipp.style.display = "none";
            moveStyleAlternative.checked = true;
            unclippAlternative.checked = true;
          }
          else {
            moveAlternativePC.style.display = "none";
            moveStyleAlternativeUnclipp.style.display = "none";
            moveStyleStandard.checked = true;
            unclippStandard.checked = true;
          }
          // exchange mode: standard/alternative visibility
          moveStyleStandardExchangeDiv.style.display = "block";
          moveStyleAlternativeExchange.style.display = "block";
          standardUnselectExchangeTutorial.style.display = "block";
          alternativeUnselectExchangeTutorial.style.display = "block";
          if (swipeSteuerung.checked) {
            moveStyleStandardExchangeDiv.style.display = "none";
            standardUnselectExchangeTutorial.style.display = "none";
          }
          else {
            moveStyleAlternativeExchange.style.display = "none";
            alternativeUnselectExchangeTutorial.style.display = "none";
          }

          moveStyleSettingChosenDiv.style.display = "none";
          // if (tutorialSteps.length) tutorial.state = tutorialSteps[tutorial.index].id;
        }
       else {
        showTutorialB.innerHTML = showTutorialB.innerHTML.replace('verstecken', 'anzeigen');
         tutorial.state = "";
         document.getElementById('tutorial').style.display = "none";
        }
        return false;
      }
      if (event.key == "Shift") {
        state.shift = true;
        state.shiftBefore = true;
        selected.tiles = [];
        if (["pressShiftStandardUnclippTutorial", "pressShiftAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(1);
      }
      var collidesTilesBar = tileSelectionBar.collidesMouse();
      if (rotateTiles.checked) {
        if (event.key == "ArrowRight") {
          if (collidesTilesBar && state.mouse == "up") {
            scrollTileSelection(1, "arrowKey");
          }
          else if (collidesTilesBar) rotateTile(tileSelectionBar.selectedTile.tileI, 90);
          else rotateSelected(90);
        }
        if (event.key == "ArrowLeft") {
          if (collidesTilesBar && state.mouse == "up") scrollTileSelection(-1, "arrowKey");
          else if (collidesTilesBar) rotateTile(tileSelectionBar.selectedTile.tileI, -90);
          else rotateSelected(-90);
        }
      }
      if (event.key?.includes("Arrow")) layout(true);
      if ((event.key == "ArrowRight" || event.key == "ArrowLeft") && modeSelection.value == "traditional" && ((selected.tiles.length && rotateTiles.checked) || collidesTilesBar)) return false;
  }
  function rotateSelected(direction) {
    if (tutorial.state == "moveMouseMoveTutorial") rotateTileTutorial.checked = true;
    if (tutorial.state == "moveMouseMoveTutorialAlternative") rotateTileTutorialAlternative.checked = true;
    if (["rotateTileTutorial", "rotateTileTutorialAlternative"].includes(tutorial.state)) goTutorialSteps(1);
    if (!state.removeTile) {
      if (selected.tiles.length == 1 && getConnectedTiles(selected.tiles[0], true).length > 1 && gerät == "PC") {
        rotateTile(selected.tiles[0], direction);
      }
      else {
        state.rotated = [];
        if (!state.shift) {
          rotateAround(selected.tiles[0], direction);
          if (lengthPerTeil.edit.x != lengthPerTeil.edit.y && getConnectedTiles(selected.tiles[0], true).length > 1) {
            state.rotated = [];
            rotateAround(selected.tiles[0], direction);
          }
        }
        else {
          for (const tile of selected.tiles) {
            rotateTile(tile, direction);
          }
        }
        // layout(true, true);
        folgenMouseMove();
      }
    }
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  // end section 6
  function storePuzzle() {
    getPuzzles();
    var puzzle = puzzles[puzzleName.value];
    if (!puzzle) puzzle = {};
    puzzle.settings = {};
    puzzle.tileAmount = {x: anzahlX.value, y: anzahlY.value};
    puzzle.positions = positions;
    puzzle.stats = stats;
    puzzle.mode = modeSelection.value;
    if (modeSelection.value == "schieben") {
      puzzle.movement = JSON.parse(JSON.stringify(movement));
      delete puzzle.movement.playerPosition;
      puzzle.missing = missing;
      puzzle.userMovement = userMovement;
      puzzle.movementPlayerPosition = playerMovementSlider.value;
    }
    if (modeSelection.value == "traditional") {
      puzzle.settings.rotateTiles = rotateTiles.checked;
      if (shuffleStyle.value == "listTiles") puzzle.tileBarTiles = tileSelectionBar.tiles;
    }
    puzzle.settings.mirrorInput = mirrorInput.checked;
    if (sourceIsFile.checked) {
      puzzle.fileName = fileName;
    }
    if (useURLCheck.checked) {
      puzzle.URL = sourceURL.value;
    }
    if (useLiveCam.checked) {
      puzzle.liveCam = cameraSelection.options[cameraSelection.value - 1].value;
    }
    puzzle.width = größeAnpassenX.value;
    puzzle.height = größeAnpassenY.value;
    puzzle.completionTime = stopClock.completionTime.time;
    puzzle.viewOriginalTime = stopClock.viewOriginal.time;
    puzzles[puzzleName.value] = puzzle;
    if (sourceIsVideo.checked) {
      puzzle.loopBeginning = loopBeginning.value;
      puzzle.loopEnding = loopEnding.value;
    } 
    localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
  }
  // returns pixel as a number
  function convertStyle(value) {
    return JSON.parse(value.replace('px', ''));
  }
  // adapts the position of the backToTileBarButtons
  function positionBackToTileBarButtons(calledByMouseDown) {
    if (!calledByMouseDown || (aufgebenId.style.display == "inline" && shuffleStyle.value == "listTiles" && state.mouse == "down" && tileSelectionBar.collidesMouse() && !selected.tiles.length)) {
      if (calledByMouseDown) tileSelectionBar.scrollX += (mausx - tileSelectionBar.swipePosition);
      tileSelectionBar.leftOffScreenTiles = - (Math.floor(tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5)));
      if (((tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5)) tileSelectionBar.offset = - (JSON.parse("0." + (tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5));
      else tileSelectionBar.offset = 0;
      if (tileSelectionBar.scrollX >= 0) tileSelectionBar.offset = -(tileSelectionBar.offset);
      else tileSelectionBar.leftOffScreenTiles--;
      for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
        elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
      }
      tileSelectionBar.swipePosition = mausx;
      if (calledByMouseDown) scrollTileSelection(0);
    }
  }
  function unclipp(tile) {
    var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
    var objTile = positions.wrong[tile];
    for (const direc of ['left', 'top', 'right', 'bottom']) {
      if (objTile.original[direc] && !selected.tiles.includes(getTile(objTile.original[direc]))) {
        delete positions.wrong[getTile(objTile.original[direc])].original[directionConverter[direc]];
        delete objTile.original[direc];
      }
    }
    var unclipped = false;
    for (let i = 0; i < clipped.length; i++) {
      if (clipped[i].split(' - ').includes(tile + "") && (!selected.tiles.includes(parseInt(clipped[i].split(' - ')[0])) || !selected.tiles.includes(parseInt(clipped[i].split(' - ')[1])))) {
        clipped.splice(i, 1);
        unclipped = true;
        i--;
      }
    }
    if (unclipped) {
      stats.unclipped++;
      if (["unclippStandardTutorial", "unclippTileAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
  }
  function checkPossibleClipping(tile, afterClipping) {
    pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
    pCollider = {width: parseInt(hitboxWidth.value), height: parseInt(hitboxHeight.value)};
    if ([90, 270].includes(positions.wrong[tile].original.degree) && lengthPerTeil.edit.x != lengthPerTeil.edit.y) {
      pCollider = {width: parseInt(hitboxHeight.value), height: parseInt(hitboxWidth.value)};
      pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
      pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
    }
    var nearest = {left: {area: 1000}, top: {area: 1000}, right: {area: 1000}, bottom: {area: 1000}, overAll: {area: 1000, i: -1}};
    for (let i = 0; i < positions.wrong.length; i++) {
      positions.wrong[i].tempI = i;
    }
    var possiblePositions = positions.wrong.filter(x => Math.abs(x.edit.x - positions.wrong[tile].edit.x) < pLengthPerTeil.edit.x + 11 && Math.abs(x.edit.y - positions.wrong[tile].edit.y) < pLengthPerTeil.edit.y + 11);
    for (const pos of possiblePositions) {
      var obj = {all: pos.edit, slc: positions.wrong[tile].edit};
      var selectedObj = {
        right: {x: obj.slc.x - 10, y: obj.slc.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2},
        left: {x: obj.slc.x + pLengthPerTeil.edit.x, y: obj.slc.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2},
        bottom: {x: obj.slc.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.slc.y - 10, width: pCollider.width - 2, height: 10},
        top: {x: obj.slc.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.slc.y + pLengthPerTeil.edit.y, width: pCollider.width - 2, height: 10}
      };
      if (!clipped.includes(pos.tempI + ' - ' + tile) && !clipped.includes(tile + ' - ' + pos.tempI)) {
        var nearTile = {
          right: collides(selectedObj.right, {x: obj.all.x + pLengthPerTeil.edit.x - parseInt(connectableSlightOverlap.value), y: obj.all.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10 + parseInt(connectableSlightOverlap.value), height: pCollider.height - 2}),
          left: collides(selectedObj.left, {x: obj.all.x - 10, y: obj.all.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10 + parseInt(connectableSlightOverlap.value), height: pCollider.height - 2}),
          bottom: collides(selectedObj.bottom, {x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y + pLengthPerTeil.edit.y - parseInt(connectableSlightOverlap.value), width: pCollider.width - 2, height: 10 + parseInt(connectableSlightOverlap.value)}),
          top: collides(selectedObj.top, {x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y - 10, width: pCollider.width - 2, height: 10 + parseInt(connectableSlightOverlap.value)})
        };
        for (var side of Object.keys(nearTile)) {
          if (nearTile[side].boolean && nearTile[side].area < nearest[side].area) {
            nearest[side] = {area: nearTile[side].area, i: pos.tempI};
          }
        }
      }
    }
    if (nearest) {
      // console.log("new check");
      for (const near of Object.values(nearest)) {
        // console.log(near.area);
        if (near.area < nearest.overAll.area) {
          nearest.overAll = {area: near.area, i: near.i};
        }
      }
    }
    var acceptedI = getConnectedTiles(nearest.overAll.i, true);
    screenObj = {x: visualViewport.pageLeft - texturLeft + state.rightScroll, y: visualViewport.pageTop - texturTop + state.upScroll, width: window.visualViewport.width, height: window.visualViewport.height};
    if (mirrorInput.checked) screenObj = {x: textur.width - (visualViewport.pageLeft - texturLeft + state.rightScroll), y: visualViewport.pageTop - texturTop + state.upScroll, width: window.visualViewport.width, height: window.visualViewport.height};
    canvas.fillStyle = "blue";
    // canvas.fillRect(screenObj.x, screenObj.y, screenObj.width, screenObj.height);
    var clipLength = selected.clip.length;
    var filteredClip = JSON.stringify(filter(selected.clip, false, true));
    var obj = {all: positions.wrong[nearest?.right.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.left && !filteredClip.includes(JSON.stringify({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y, width: 10, height: pLengthPerTeil.edit.y, selected: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y}}))) {
      selected.clip.push({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height, original: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y}, selected: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.right.area});
    }
    obj = {all: positions.wrong[nearest?.left.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.right && !filteredClip.includes(JSON.stringify({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y, width: 10, height: pLengthPerTeil.edit.y, selected: {x: obj.all.x - pLengthPerTeil.edit.x, y: obj.all.y}}))) {
      selected.clip.push({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height, original: {x: obj.all.x - 10, y: obj.all.y, width: 10, height: lengthPerTeil.edit.y}, selected: {x: obj.all.x - pLengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.left.area});
    }
    obj = {all: positions.wrong[nearest?.bottom.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.top && !filteredClip.includes(JSON.stringify({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y, width: pLengthPerTeil.edit.x, height: 10, original: {x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y, width: pLengthPerTeil.edit.x, height: 10}, selected: { x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y}}))) {
      selected.clip.push({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y + pLengthPerTeil.edit.y, width: pCollider.width, height: 10, original: {x: obj.all.x + 1, y: obj.all.y + pLengthPerTeil.edit.y, width: lengthPerTeil.edit.x, height: 10}, selected: { x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y}, distance: nearest.bottom.area});
    }
    obj = {all: positions.wrong[nearest?.top.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.bottom && !filteredClip.includes(JSON.stringify({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x, y: obj.all.y - 10, width: pLengthPerTeil.edit.x, height: 10, selected: {x: obj.all.x, y: obj.all.y - pLengthPerTeil.edit.y}}))) {
      selected.clip.push({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y - 10, width: pCollider.width, height: 10, original: {x: obj.all.x, y: obj.all.y - 10, width: lengthPerTeil.edit.x, height: 10}, selected: {x: obj.all.x, y: obj.all.y - pLengthPerTeil.edit.y}, distance: nearest.top.area});
    }
    checkedTiles = [];
    for (var i = 0; i < selected.clip.length - clipLength; i++) {
      var clip = selected.clip[selected.clip.length - 1 - i];
      var clipCollider = JSON.parse(JSON.stringify(clip));
      clipCollider.x -= state.rightScroll;
      clipCollider.y -= state.upScroll;
      if (selected.clip.length > clipLength && ((selected.clip[selected.clip.length - 1 - i - 1] && angular.equals(clip, selected.clip[selected.clip.length - 1 - i - 1])) ||  (state.rotated && gerät == "Handy") || (positions.wrong[clip.i].original.degree != positions.wrong[clip.sI].original.degree && getDegreeAfterRotation(getDegreeAfterRotation(positions.wrong[clip.i].original.degree, 90), 90) /*total: 180°*/ != positions.wrong[clip.sI].original.degree && pLengthPerTeil.edit.x != pLengthPerTeil.edit.y) || tileSelectionBar.tiles.includes(clip.i) || ((/*selectedCollidesOthers(clip, tile) || */!collides(addTolerance(clipCollider, 3), screenObj).boolean || selectedCollideOther(clip.i) || clipCollidesLowerTile(clip) || !acceptedI.includes(clip.i)) && !afterClipping))) {
        selected.clip.pop();
        i--;
      }
    }
  }
  // returns a list with the indizes (plural index) of all tiles the entered tile ('tile') is connected to
  function getConnectedTiles(tile, firstCall, connectedTiles, restoreClipped) {
    if (!connectedTiles) connectedTiles = [];
    connectedTiles.push(tile);
    var tileObj = positions.wrong[tile];
    for (const side of ['left', 'top', 'right', 'bottom']) {
      if (tileObj && tileObj.original[side] && !connectedTiles.includes(getTile(tileObj.original[side]))) {
        if (restoreClipped && !clipped.includes(tile + ' - ' + getTile(tileObj.original[side])) && !clipped.includes(getTile(tileObj.original[side]) + ' - ' + tile)) {
          clipped.push(tile + ' - ' + getTile(tileObj.original[side]));
        }
        getConnectedTiles(getTile(tileObj.original[side]), false, connectedTiles, restoreClipped);
      }
    };
    if (firstCall) return connectedTiles;
  }
  function playClippingSound() {
    for (const option of selected.clip) {
      // new option
      if (!clipOptionsBefore || !JSON.stringify(clipOptionsBefore).includes(JSON.stringify(filter([option], true, true)[0]))) {
        if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseDown%20(click)_V3.mp3').play();
        clipOptionsBefore = (filter(selected.clip, true, true));
        if (vibrate.checked) window.navigator.vibrate(33);
        if (["getClippingOptionConnectTileTutorial", "getClippingOptionConnectTileMobileTutorial"].includes(tutorial.state))goTutorialSteps(1);
      }
    }
    if (clipOptionsBefore) {
      for (const option of clipOptionsBefore) {
        if (!JSON.stringify(filter(selected.clip, true, true)).includes(JSON.stringify(option))) {
          if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseUp%20(click).mp3').play();
          clipOptionsBefore = (filter(selected.clip, true, true));
          if (vibrate.checked) {
            setTimeout(function () {
              window.navigator.vibrate(27);
            }, 100);
          }
          if (["clipTileTutorial", "clipTileMobileTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
        }
      }
    }
  }
  // remove sI out of the entered obj
  function filter(clipOptions, sI, distance) {
    var stored = JSON.parse(JSON.stringify(clipOptions));
    for (const elm of stored) {
      if (sI) delete elm.sI;
      if (distance) delete elm.distance;
    }
    return stored;
  }
  var clipOptionsBefore;
  // checks collision of tiles with the clip options marker
  function selectedCollidesOthers(pClip,  tile) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (collides(transformToObj(i), addTolerance(pClip, 3)).boolean && !tileSelectionBar.tiles.includes(i) && !selected.tiles.includes(i) && tile != i) {
        return true;
      }
    }
  }
  var checkedTiles = [];
  // checks if selected tiles collide tiles which are (connected to) tiles you want to clip to
  function selectedCollideOther(pClipIndex) {
    var connected = getConnectedTiles(pClipIndex, true);
    for (const clipIndex of connected) {
      for (const tile of selected.tiles) {
        if (collides(transformToObj(clipIndex, 3), transformToObj(tile, 3)).boolean) {
          return true;
        }
      }
    }
  }
  // checks collision between clip marker and tiles on top of c.clipI (tile you want to clip to)
  function clipCollidesLowerTile(clip) {
    var clipIReached = false;
    for (const position of positions.layoutOrder.filter(x => !selected.tiles.includes(x))) {
      if (position == clip.i) clipIReached = true;
      else if (clipIReached && collides(clip, transformToObj(position, 3)).boolean && collideClip.checked) {
        return true;
      }
    }
  }
  var clipped = [];
  function collides(a, b) {
    try {
      return {boolean: !(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        ), area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)};

    } catch (e) {
      console.log('err: ' + e);
    }
  }
  // checks if potentiallySelected collides with any other tile (not used anymore due to more advanced collision detection (TODO: optional?))
  function selectedCollides(potentiallySelected) {
    for (var tile of selected.tiles) {
      if (collides(transformToObj(tile), transformToObj(potentiallySelected)).boolean) return tile;
    }
  }
  // transforms index of tile into an obj that can be used for collision checks (tolerance can be added)
  function transformToObj(i, tolerance) {
    pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
    if ([90, 270].includes(positions.wrong[i].original.degree)) {
      pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
      pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
    }
    var obj =  positions.wrong[i].edit;
    if (!tolerance) tolerance = 0;
    return {x: obj.x + tolerance, y: obj.y + tolerance, width: pLengthPerTeil.edit.x - tolerance*2, height: pLengthPerTeil.edit.y - tolerance*2};
  }
  // adds tolerance by decreacing the size of the entered hitbox (obj)
  function addTolerance(obj, tolerance) {
    return {...obj, x: obj.x + tolerance, y: obj.y + tolerance, width: obj.width - tolerance*2, height: obj.height - tolerance*2};
  }
  // returns the index of the tile which has the entered original coordinates
  function getTile(originalCoord) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (positions.wrong[i].original.x == originalCoord.x && positions.wrong[i].original.y == originalCoord.y) return i;
    };
  }
  // exchanges two tiles (positions)
  function vertauscheZwei(i, i1) {
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i].edit));
    positions.wrong[i].edit = JSON.parse(JSON.stringify(positions.wrong[i1].edit));
    positions.wrong[i1].edit = JSON.parse(JSON.stringify(ablage));
    if (positions.wrong[i1].edit == undefined) positions.wrong.splice(i1, 1);
  }
  // returns the coordinates of a selected tile (schieben and exchange mode)
  function checkSelected(removeTile) {
    // try {
        for (var i = 0; i < anzahlX.value; i++) {
          for (var i1 = 0; i1 < anzahlY.value; i1++) {
            if ((removeTile && mausx > lengthPerTeil.edit.x*i + 3*i && mausx < lengthPerTeil.edit.x*(i + 1) + 3*(i + 1) && mausy > lengthPerTeil.edit.y*i1 + 3*(i1) && mausy < lengthPerTeil.edit.y*(i1 + 1) + 3*(i1 + 1)) || (lengthPerTeil.edit && !removeTile && mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1))) {
              return {x: i, y: i1};
            }
            // if (!removeTile && mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1)) return {x: i, y: i1};
          }
        }
  // } catch (e) {
  //   console.log("pleaseDebug :)");
  // }
  }

// section 7: stop clock:
var stopClock = {viewOriginal: {time: 0, running: 0}, completionTime: {time: 0, running: 0}};
var time = 0;
var running = 0;

function startPause(type) {
if (stopClock[type].running == 0) {
  stopClock[type].running = 1;
  // time = 0;
  increment(type);
}
else {
  stopClock[type].running = 0;
}
}
function reset(type) {
running = 0;
timer = 0;
}
function increment(type) {
if (stopClock[type].running == 1) {
setTimeout(function () {
  stopClock[type].time++;
  var time = stopClock[type].time;
  var mins = Math.floor(time/10/60);
  var secs = Math.floor(time/10);
      secs -= 60*mins;
  var tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  if (type == "viewOriginal") stats[type].time = mins + ":" + secs + ":" + "0" + tenths;
  else stats[type] = mins + ":" + secs + ":" + "0" + tenths;
  increment(type);
}, 100);
}
}
// end section 7
function getSectionElm(elm) {
  try {
    while (!elm.className.includes("section")) {
      elm = elm.parentElement;
    }
    
  } catch (err) {
    console.err(err);
  }
  return elm;
}
function setupTutorial() {
  sourceURL.value = "https://adi.nicolaiweitkemper.de/Bilder/puzzleCreatorLogo.png";
    useURL();
    setTimeout(() => {
      if (!offline) startTutorial();
      else {
        alert('Bitte importieren Sie ein Bild oder ein Video von diesem Gerät ("Datei (Foto oder Video) auswählen"), um das Tutorial mit dem Bild starten zu können. ');
        state.waitForPictureSelection = true;
      }
      }, 777);
  }
  var tutorialSteps = [];
function startTutorial() {
  showTutorialB.innerHTML = "Tutorial verstecken";
  var mode = modeSelection.value;
  document.getElementById('tutorial').style.display = "inline";
  // document.getElementById(mode + 'Tutorial').style.display = "inline";
  document.getElementById(mode + 'Tutorial' + gerät).style.display = "inline";
  document.getElementById(mode + 'Tutorial' + gerät).appendChild(completePuzzleTutorialDiv);
  tutorial.state = "starting";
  setTimeout(() => {
    // tutorialSteps = Array.from(document.getElementById('tutorial').querySelectorAll('input[type="checkbox"]')).filter(x => x.style.display != "none");
    document.getElementById('tutorial').style.display = "inline";
    tutorialSteps = Array.from(document.getElementById('tutorial').querySelectorAll('input[type="checkbox"]')).filter(x => x.offsetWidth > 0 || x.offsetHeight > 0);
    if (settings.style.display != "none") document.getElementById('tutorial').style.display = "none";
    goTutorialSteps(0);
  }, 777);
  if (mode == "traditional" && !state.helpTutorial) {
    shuffleStyle.value = "listTiles";
    emptyTileBar.checked = true;
  }
  if (state.helpTutorial && missing.length == 1) {
    moveMultipleOptionsSchiebenTutorial.style.display = "none";
  }
  setTimeout(() => {
      if (!state.helpTutorial) {
      create();
      if (mode != "schieben") shufflePuzzle();
      if (mode == "traditional") {
        for (const elm of document.getElementsByClassName('backToTileB')) {
          elm.style.display = "none";
        }
        tileSelectionCanvas.style.display = "none";
        selectBackToBarB.style.display = "none";
      }
      automaticTileSelectionReset.disabled = true;
      doStorePuzzle.disabled = true;
      doStorePuzzle.disabled = true;
      puzzleName.disabled = true;
      keepScrolling.disabled = true;
      swipeSteuerung,disabled = true; 
      listTilesS.style.display = "none";
    }
  }, 500);
  setTimeout(() => {
    if (gerät == "Handy"  && modeSelection.value == "traditional") document.getElementById('tutorial').style.top = mobileControls.getBoundingClientRect().bottom + 10;
  }, 777);
  document.getElementById('tutorial').style.maxHeight = window.innerHeight - mobileControls.getBoundingClientRect().bottom - 10;
  if (modeSelection.value != "traditional") document.getElementById('tutorial').style.maxHeight = window.innerHeight;
}
function goTutorialSteps(steps) {
  var direction = 1;
  if (steps < 0) direction = -1;
  if (steps == 0) direction = 0;
  if (tutorial.state != "starting") document.getElementById(tutorial.state + 'Div').className = "";
  try {
    if (direction > 0) tutorialSteps[tutorial.index].checked = true;
    else if (tutorialSteps.length) tutorialSteps[tutorial.index].checked = false;
    if (steps > 0)  {
     if (!angular.equals(getSectionElm(document.getElementById(tutorial.state + 'Div')), getSectionElm(tutorialSteps[tutorial.index + direction]))) {
      state.scrollToSection = true;
      setTimeout(() => {
        getSectionElm(tutorialSteps[tutorial.index + direction]).scrollIntoView();
        setTimeout(() => {
          state.scrollToSection = false;
        }, 1000);
      }, 100);
    }
  }
  // if (document.getElementById('tutorial').style.display == "inline") {
    tutorial.index += direction;
    tutorial.state = tutorialSteps[tutorial.index].id;
  // }
  if (!tutorialSteps.filter(x => document.getElementById(x.id + 'Div').className.includes('currentTutorialStep')).length) document.getElementById(tutorial.state + 'Div').className = "currentTutorialStep cardGeneral";
    setTimeout(() => {
        if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height - 40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
            document.getElementById(tutorial.state + 'Div').parentElement.parentElement.scrollIntoView();
          setTimeout(() => {
            if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height - 40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
                document.getElementById(tutorial.state + 'Div').parentElement.scrollIntoView();
              setTimeout(() => {
              if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height -40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
                  document.getElementById(tutorial.state + 'Div').scrollIntoView();
              }
            }, 1000);
          }
          }, 1000);
      }
    }, 300);
    if (tutorial.state == "tileClickMoveTutorial" && !state.helpTutorial) automaticTileSelectionReset.checked = false;
    if (steps != 0) {
      if (tutorial.state == "completePuzzleTutorial") alert("Wenn Sie nun aus einem eigenen Bild ein Puzzle erstellen wollen, laden Sie die Seite neu. ");
      if (tutorial.state == "scrollArrowTileBarTutorial") window.scroll(0, 0);
      if (tutorial.state == "selectTileBarTileTutorial" && tileSelectionBar.selectedTile != undefined && steps == 1) goTutorialSteps(1);
      if (tutorial.state == "stopScrollingAutomaticScrollingTutorial") checkAutoscrollStop({x: scrollX, y: scrollY});
      if (tutorial.state == "schiebenSelectTileMoveMultipleTurorial" && !state.helpTutorial) {
        try {
          setTimeout(() => {
            missing.push("0 - 0");
            // positionsBeginning.push(positions.wrong[getTileIByCoord({x: 0, y: 0})]);
            positions.right.splice(getTileIByCoord({x: 0, y: 0}), 1);
            positions.wrong.splice(getTileIByCoord({x: 0, y: 0}), 1);
            missing.push(lengthPerTeil.edit.x*2 + " - 0");
            // positionsBeginning.push(positions.wrong[getTileIByCoord({x: 2, y: 0})]);
            positions.right.splice(getTileIByCoord({x: 2, y: 0}), 1);
            positions.wrong.splice(getTileIByCoord({x: 2, y: 0}), 1);
            layout(true, true);
          }, 1000);
        } catch (e) {}
      }
      if (tutorial.state == "pressShiftMobileUnclippTutorial") {
        selectMultipleTitle.innerHTML = "Shift Taste";
        selectMultipleTitle.style.display = "inline";
      }
      else selectMultipleTitle.style.display = 'none';
      if (tutorial.state == "activateRotateLeftTutorial") rotateLeftTitle.style.display = "inline";
      else rotateLeftTitle.style.display = "none";
      if (tutorial.state == "activateRotateRightTutorial") rotateRightTitle.style.display = "inline";
      else rotateRightTitle.style.display = "none";
      if (moveStyleSettingChosen.checked && tutorial.state == "moveStyleSettingChosen" && steps == 1) goTutorialSteps(1);
      if (steps < 0 && ["pressShiftMobileUnclippTutorial", "selectTileMobileShiftUnclippTutorial"].includes(tutorial.state)) {
        selected.tiles = [];
        layout(true);
      }
      if (tutorial.state == "scrollArrowTileBarTutorial" && !state.helpTutorial) {
        for (const elm of document.getElementsByClassName('backToTileB')) {
          elm.style.display = "inline";
        }
        tileSelectionCanvas.style.display = "inline";
        selectBackToBarB.style.display = "inline";
        listTilesS.style.display = "block";
        for (var i = 0; i < 16; i++) {
          tileSelectionBar.tiles.splice(0, 0, i);
          unclipp(i);
          mouseDown();
        }
        setTimeout(() => {
          scrollTileSelectionRight.style.bottom = (lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionRight.getBoundingClientRect().height/2) + "px";
          scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 - scrollTileSelectionLeft.getBoundingClientRect().height/2 + "px";
        }, 777);
      }
      if (tutorial.state == "scrollArrowTileBarTutorial") {
        scrollTileSelection(1, 'arrowKey');
        tileSelectionBar.leftOffScreenTiles = 1;
        scrollTileBarTitle.style.display = "inline";
        scrollTileBarTitle.style.left = scrollTileSelectionLeft.getBoundingClientRect().left + scrollTileSelectionLeft.getBoundingClientRect().height/2;
        scrollTileBarTitle.style.top = scrollTileSelectionLeft.getBoundingClientRect().top - scrollTileSelectionLeft.getBoundingClientRect().height/2 - 11;
      }
      else scrollTileBarTitle.style.display = "none";
      if (tutorial.state == "mouseDownSelectFirstExchangeAlternativeTutorial") swipeSteuerung.checked = true;
      if (tutorial.state == "selectTileUnselectStandardTutorial") {
        setTimeout(() => {
          swipeSteuerung.checked = false;
        }, 10);
      }
      if (tutorial.state == "mouseDownUnselectAlternativeTutorial") swipeSteuerung.checked = true;
    }
    if (steps != 0) goTutorialSteps(steps + direction*(-1));
  }
  catch (err) {
    if (!state.helpTutorial) {
      console.log('tutorial finished!');
      console.log(tutorial.state);
      console.error(err)
      tutorial.state = "finished";
    }
  }
}
// function goTutorialSteps(steps) {
//   if (tutorial.state != "") document.getElementById(tutorial.state + 'Div').className = "";
//   try {
//     if (steps > 0)  {
//       for (let i = 0; i < steps; i++) {
//        document.getElementById(document.getElementById(modeSelection.value + 'Tutorial' + gerät).querySelectorAll('input[type="checkbox"]')[tutorial.index + i].id).checked = true;
//      }
//      if (!angular.equals(getSectionElm(document.getElementById(tutorial.state + 'Div')), getSectionElm(document.getElementById(modeSelection.value + 'Tutorial' + gerät).querySelectorAll('input[type="checkbox"]')[tutorial.index + steps]))) {
//       // tutorial.index -= getSectionElm(document.getElementById(tutorial.state + 'Div')).querySelectorAll('input[type="checkbox"]').length;
//       // getSectionElm(document.getElementById(tutorial.state + 'Div')).style.display = "none";
//       state.scrollToSection = true;
//       setTimeout(() => {
//         getSectionElm(document.getElementById(modeSelection.value + 'Tutorial' + gerät).querySelectorAll('input[type="checkbox"]')[tutorial.index + steps]).scrollIntoView();
//         setTimeout(() => {
//           state.scrollToSection = false;
//         }, 1000);
//       }, 100);
//     }
//   }
//   if (steps < 0) {
//       for (let i = tutorial.index - 1; i > tutorial.index + steps - 1; i--) {
//        document.getElementById(document.getElementById(modeSelection.value + 'Tutorial' + gerät).querySelectorAll('input[type="checkbox"]')[i].id).checked = false;
//       }
//     }
//     tutorial.index += steps;
//     tutorial.state = document.getElementById(modeSelection.value + 'Tutorial' + gerät).querySelectorAll('input[type="checkbox"]')[tutorial.index].id;
//     document.getElementById(tutorial.state + 'Div').className = "currentTutorialStep cardGeneral";
//     setTimeout(() => {
//         if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height - 40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
//             document.getElementById(tutorial.state + 'Div').parentElement.parentElement.scrollIntoView();
//           setTimeout(() => {
//             if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height - 40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
//                 document.getElementById(tutorial.state + 'Div').parentElement.scrollIntoView();
//               setTimeout(() => {
//               if (!state.scrollToSection && !collides({x: visualViewport.offsetLeft, y: visualViewport.offsetTop + 20, width: visualViewport.width, height: visualViewport.height -40}, document.getElementById(tutorial.state + 'Div').getBoundingClientRect()).boolean) {
//                   document.getElementById(tutorial.state + 'Div').scrollIntoView();
//               }
//             }, 1000);
//           }
//           }, 1000);
//       }
//     }, 300);
//     if (tutorial.state == "scrollArrowTileBarTutorial") window.scroll(0, 0);
//     if (tutorial.state == "selectTileBarTileTutorial" && tileSelectionBar.selectedTile != undefined) goTutorialSteps(1);
//     if (tutorial.state == "pressShiftMobileUnclippTutorial") {
//       selectMultipleTitle.innerHTML = "Shift Taste";
//       selectMultipleTitle.style.display = "inline";
//     }
//     if (tutorial.state == "activateRotateLeftTutorial") rotateLeftTitle.style.display = "inline";
//     else rotateLeftTitle.style.display = "none";
//     if (tutorial.state == "activateRotateRightTutorial") rotateRightTitle.style.display = "inline";
//     else rotateRightTitle.style.display = "none";
//     if (steps < 0 && ["pressShiftMobileUnclippTutorial", "selectTileMobileShiftUnclippTutorial"].includes(tutorial.state)) {
//       selected.tiles = [];
//       layout(true);
//     }
//     if (tutorial.state == "scrollArrowTileBarTutorial") {
//       for (const elm of document.getElementsByClassName('backToTileB')) {
//         elm.style.display = "inline";
//       }
//       tileSelectionCanvas.style.display = "inline";
//       selectBackToBarB.style.display = "inline";
//       listTilesS.style.display = "block";
//       for (var i = 0; i < 16; i++) {
//         tileSelectionBar.tiles.splice(0, 0, i);
//         unclipp(i);
//         mouseDown();
//       }
//       scrollTileSelection(1);
//     }
//     if (tutorial.state == "mouseDownSelectFirstExchangeAlternativeTutorial") swipeSteuerung.checked = true;
//     if (tutorial.state == "selectTileUnselectStandardTutorial") {
//       setTimeout(() => {
//         swipeSteuerung.checked = false;
//       }, 10);
//     }
//     if (tutorial.state == "mouseDownUnselectAlternativeTutorial") swipeSteuerung.checked = true;
//   }
//   catch (err) {
//     console.log('tutorial finished!');
//     console.log(tutorial.state);
//     console.error(err)
//     tutorial.state = "finished";
//   }
// }
</script>
