<meta charset="utf-8">
<meta name="viewport" id="preventAutomaticZoom">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<div id="imageSettings">
<input type="number" min="0" value="4" style="width: 44px;" id="anzahlX" onchange="anzahlVerschieben.value = value*anzahlY.value; anzahlRichtige.max = value*anzahlY.value - 2"> Teile x-Achse
<br>
<input type="number" min="0" value="4" style="width: 44px;" id="anzahlY" onchange="anzahlVerschieben.value = anzahlX.value*value; anzahlRichtige.max = anzahlX.value*value - 2"> Teile y-Achse
<br>
<div id="puzzleManager">
  <h1>Puzzle verwalten</h1>
  <li id="puzzleSelection"></li>
  <div style="display: none;" onmouseout="checkOut();"  class="dropdown-content" id="editPuzzleManager">
    <a onclick="restorePuzzleSource(selected.puzzle);">öffnen/fortfahren</a>
    <a onclick="editPuzzleName();">Name bearbeiten</a>
    <a onclick="deletePuzzle();">löschen</a>
    <a onclick="showInformation();">mehr Informationen</a>
  </div>
  <br>
  <a id="storePuzzleManager">
    <input id="doStorePuzzle" type="checkbox"> im Folgenden erstellte Puzzle unter dem Namen 
    <input oninput="if (Object.keys(puzzles).includes(value)) puzzleNameWarning.style.display = 'inline'; else puzzleNameWarning.style.display = 'none'; doStorePuzzle.checked = true;" id="puzzleName" type="text"> 
    automatisch speichern
    <br>
  </a>
  <p id="puzzleNameWarning" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
    Sie haben ein Puzzle bereits so benannt. Bitte wählen Sie einen anderen Namen! Andernfalls wird das Puzzle das bisher so hieß überschrieben bzw. gelöscht!!!
  </p>
</div>
<h1>Quelle auswählen</h1>
<input type="file" onchange="readImg(this);" style="position: absolute; left: -10000px;" id="fileB">
<input id="sourceIsFile" onclick="fileB.click();" style="font-size: 55px;" type="radio" name="source"><a onclick="fileB.click(); sourceIsFile.checked = true;">Datei (Foto oder Video) auswählen</a></input>
<br>
<input onchange="useURL();" id="useURLCheck" type="radio" name="source">
<input type="text" style="height: 50px;" oninput="useURL();" height="100px" placeholder="URL (drag and drop möglich)" id="sourceURL">
<br>
<p id="URLInfo" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
  Die URL muss direkt auf das Bild/Video verweisen! Führen Sie dafür einen Rechtsklick auf das gewünschte Bild aus und klicken Sie auf "Bildadresse kopieren", um die richtige Adresse/URL zu kopieren!
  <br>
</p>
<a style="display: none; border-radius: 3px; border-style: double; background-color: darkorange; width: max-content; height: max-content;" id="sourceCheckboxes">
  <input id="sourceIsPicture" onchange="state.userSource = 'Picture';" checked="true" name="mediaType" type="radio">Bild
  <input id="sourceIsVideo" onchange="state.userSource = 'Video';" name="mediaType" type="radio">Video
  <br>
</a>
<input id="useLiveCam" type="radio" name="source" onchange="changeCamera(cameraSelection.value);"><a onclick="useLiveCam.checked = true; changeCamera(cameraSelection.value);">nutze live Kamera</a></button>
<select id="cameraSelection" onchange="changeCamera(value);"></select>
<h2>Bild bearbeiten</h2>
<input id="mirrorInput" onclick="mirrorCanvas(checked);" type="checkbox"> Bild/Video spiegeln
<br>
<p1 id="screenIsMaxP"><input id="screenIsMax" onchange="changeAdaptedSizeMax(originalSize.width, originalSize.height);" checked="true" type="checkbox"> maximale Größe des Bildes: Bildschirmgröße</p1>
<br>
<input id="percentSizeAdaption" oninput="größeAnpassenX.value = größeAnpassenX.max*value; größeAnpassenY.value = größeAnpassenY.max*value; zeigeGröße(true);" min="0.01" step="0.01" max="1" type="range"> Breite und Höhe prozentual anpassen
<br>
<input type="range" oninput="zeigeGröße(true);" placeholder="Pixelanzahl x achse" id="größeAnpassenX"> Breite des Bildes
<br>
<input type="range" max="window.innerHeight" oninput="zeigeGröße(true);" placeholder="Pixelanzahl y achse" id="größeAnpassenY"> Höhe des Bildes
<br>
<button type="button" onclick="resetImageSize();" name="button">⟲zurücksetzen</button>
<button type="button" onclick="zuBildschirmgröße();" name="button">Größe auf Bildschirmgröße anpassen</button>
<button type="button" onclick="zuAngepassterBildschirmgröße();" name="button">Größenverhältnis angleichen (quadratische Teile)</button>
<button type="button" onclick="zuOptimalerBildschirmgröße();" title="verkelinert sowohl Höhe als auch Breite des Bildes solange, bis beides auf den Bildschirm passt. " name="button">Größenverhältnis optimieren</button>
<br>
<a id="rotateTilesAdaptionSettings">
  <button type="radio" id="bAdaptAmount" onclick="if (checked) adaptTileAmount(true);" name="adaptionStyle"> Anzahl Puzzleteile anpassen, sodass Breite und Höhe der Teile übereinstimmen (quadratische Teile)</button>
    und insgesamt mindestens <input id="minTileAmount" oninput="adaptTileAmount();" style="width: 45px;" value="16" min="2" type="number"> Teile erstellt werden.
  <br>
</a>
<button type="button" style="font-size: 33px;" onclick="create();" name="button">erstelle Puzzle</button>
</div>
<button type="button" id="showSettings" onclick="changeSettingsVis();" name="button">mehr Einstellungsmöglichkeiten (Moduswahl, Anzeigemöglichkeiten und mehr)</button>
<br>
<button style="position: fixed; display: none; z-index: 3;" id="selectBackToBarB" onclick="generalBackToBar(this);">zurück in Leiste</button>
<p2 style="position: fixed; top: -7px; left: 377px; background-color: rgba(205, 218, 199, 0.77); font-size: 5vh; padding-bottom: 15px; border-radius: 5px; z-index: 2;" id="mobileControls">
  <p id="rotateControls" style="display: none;">
    <a style="display: none;" id="traditionalModeMobileControls">
      <input class="mobileControlsElm" type="checkbox" oninput="rotatesRight.checked = false;" name="rotateB" id="rotatesLeft" name="button"><a1 onclick="showTitle(id, style.display);" id="rotateLeftSymbol">⟲</a1>
      <input class="mobileControlsElm" type="checkbox" oninput="rotatesLeft.checked = false;" name="rotateB" id="rotatesRight"  name="button"><a1 onclick="showTitle(id, style.display);" id="rotateRightSymbol">⟳</a1>
      <!-- <button class="mobileControlsElm" onclick="state.shift = true;"><==></button> -->
      <input type="checkbox" id="selectMultiple" class="mobileControlsElm" onchange="state.shift = true;"><a1 onclick="showTitle(id, style.display);" id="selectMultipleSymbol">⇧</a1>
    </a>
  </p>
    <input class="mobileControlsElm" type="checkbox" id="scrollable" name="button"><a onclick="showTitle(id, style.display);" id="swipeSymbol">scroll</a>
</p2>
<div id="tileElements">
  <div id="rotateLeftTitle" style="left: -143px; top: 30px; display: none;" class="speech top">
    Teil pro klick um 90° nach links verschieben 
  </div>
  <div id="rotateRightTitle" style="left: 1px; top: 30px; display: none;" class="speech top">
    Teil pro klick um 90° nach rechts verschieben 
  </div>
  <div id="selectMultipleTitle" style="left: 102px; top: 30px; display: none;" class="speech top">
    Mehrfachauswahl durch Klicken auf Teile und Teile abtrennen durch Bewegen eines der ausgewählen Teile
  </div>
  <div id="swipeTitle" style="left: 102px; top: 30px; display: none;" class="speech top">
    Scrollen und Zoomen ermöglichen
  </div>
</div>
<style>
  .mobileControlsElm {
    width: 44;
    height: 44;
    top: 7px;
  }
</style>
<div id="settings" style="display: none;">
  <h2 id="modeHeadline">Modus: </h2>
  <select onchange="modeSelected(value);" id="modeSelection">
    <option value="traditional">traditionell</option>
    <option value="exchange">austauschen</option>
    <option value="schieben">nur schieben</option>
  </select>
  <br>
  <p id="traditionalDescription">Die Puzzleteile werden verteilt. Nun müssen Sie die Teile wieder zusammensetzen. 
    <br>
    Wo die Teile zusammengesetzt werden ist egal.
    <br>
    <button onclick="startTutorial('traditional');">tutorial</button>
  </p>
  <p style="display: none;" id="exchangeDescription">
    Die Positionen der Puzzleteile wird ausgetauscht. Danach haben Sie die Aufgabe, durch Klicken auf zwei Teile diese auszutauschen.
  </p>
  <p style="display: none;" id="schiebenDescription">
    Mindestens ein Puzzleteil muss gelöscht werden. Danach vermischt das Programm die Teile durch Schieben.
    <br>
    Ist dies geschehen, können Sie die Teile durch Klicken auf das zu verschiebende Teil (und unter Umständen die gewünschte Zielposition) so verschieben, dass wieder das Originalbild entsteht.
  </p>
  <b style="font-size: 25px;" id="modeSettingsHeading">modusspezifische Einstellungen: </b>
  <div id="traditionalSettings">
    <br>
    <input id="clipOptionsSound" checked="true" type="checkbox"> akustisches Feedback (Audio bei Verbindungsmöglichkeiten)
    <a id="vibrateA">
      <br>
      <input id="vibrate" type="checkbox"> haptisches Feedback (bei neuer Verbindungsmöglichkeit vibrieren)
    </a>
    <br>
    <input id="automaticTileSelectionReset" type="checkbox"> automatisch Teile/Auswahl abwählen
    <br>
    <p style="margin-bottom: 6px;" id="rotateTilesP">
    <input id="rotateTiles" onchange="if (checked) rotateTilesAdaptionSettings.style.display = 'none'; else {rotateTilesAdaptionSettings.style.display = 'inline';}" checked="true" type="checkbox"> drehe Teile
    </p>
    <input id="markWrong" style="accent-color: red;" type="checkbox" > markiere nicht passende
    <a id="shuffleStyleLable">
      <br>
      Art der Verteilung der Teile: 
    </a>
    <select onchange="shuffleStyleVisibilities(value);";  id="shuffleStyle">
      <option value="overlapTiles">Teile verstreuen und überlappen lassen</option>
      <option value="listTiles">Teile nebeneinander auflisten</option>
      <option value="nextToEachOther">Teile mit Abstand nebeneinander legen</option>
    </select>
    <a id="shuffleHeadline" style="display: none;">
      <br>
      <br>
      <b style="font-size: 25px;">Einstellungen zu der Verteilung der Teile:</b>
      <br>
    </a>
    <a style="display: none" id="aEmptyTileBar">
      <br>
      <input id="emptyTileBar" onchange="if (checked) emptyTileBarSettings.style.display = 'inline'; else emptyTileBarSettings.style.display = 'none';" type="checkbox">mit leerer Liste starten
      <a style="display: none;" id="emptyTileBarSettings">
        <br>
        dabei folgendermaßen die Teile mischen: 
        <br>
        <select onchange="if (value == 'nextToEachOther') tilesGapS.style.display = 'inline'; else tilesGapS.style.display = 'none';" id="shuffleStyleBar">
          <option value="overlapTiles">Teile verstreuen und überlappen lassen</option>
          <option value="nextToEachOther">Teile mit Abstand nebeneinander legen</option>
        </select>
      </a>
      <br>
      <a>
    <div style="display: none;" id="listTilesS">
      <br>
      <br>
      <input type="checkbox" checked="true" onchange="backToBarVis(checked)"; id="BackToBarB"> Buttons für Zurückführung der Teile in die Leiste unten
      <br>
      <div id="backToBarBSize">
        <input id="backToBarBWidth" oninput="changeBackToBarB('width', value)" type="range"> Breite der Buttons
        <br>
        <input id="backToBarBHeight" oninput="changeBackToBarB('height', value)" type="range"> Höhe der Buttons
      </div>
      <br>
      <a id="tileBarHeightText">Höhe der Leiste</a>
      <button onclick="changeTileBarHeight(lengthPerTeil.edit.y + 10);" id="resetBarSize">reset</button>
      <input type="range" oninput="changeTileBarHeight(value);" min="25" id="tileBarHeight">
      <div id="autoSelectTileBarP">
        <input type="checkbox" checked=""true id="autoSelectTileBar"> automatisch nächstes Element in Auflistung anwählen
      </div>
    </div>
    <div id="tilesGapS" style="display: none;">
      <br>
      Abstand (in px): <input min="0" id="tilesGap" oninput="gapSizeChanged(value);" value="55" style="width: 55px;" type="number">
      <br>
      <br>
      <canvas id="gapCanvas"></canvas>
      <br>
      <input id="fillScreenTileGap" onchange="if (checked) aScrollXTileGap.style.display = 'none'; else aScrollXTileGap.style.display = 'inline';" checked="true" type="checkbox"> Bildschirm füllen
      <br>
      <a style="display: none" id="aScrollXTileGap">
        <input id="tilesXTileGap" min="1" value="4" style="width: 55px;" type="number"> Teile nebeneinander
        <br>
      </a>
    </div>
    <a id="hitboxCheckbox" style="display: none;"><input onchange="if (checked) tileColliderSettings.style.display = 'inline'; else tileColliderSettings.style.display = 'none'; adaptExpandButtonPosition(); showHitboxes();" type="checkbox"> <b>zeige Einstellung zur Modifizierung der Hitboxen zwischen den Teilen</b></a>
    <a id="tileColliderSettings" style="display: none;">
      <br>
      Hitbox Breite: <input type="range" min="1" oninput="showHitboxes();" id="hitboxWidth">
      <br>
      Hitbox Höhe: <input type="range" min="1" oninput="showHitboxes();" id="hitboxHeight">
      <br>
      <canvas id="hitboxTextur"></canvas>
    </a>
    <br>
    <input id="collideClip" checked="true" type="checkbox"> Teile an verdeckte Ränder nicht anknüpfen lassen
    <br>
    <p id="scrollOnBlancP"><input id="scrollOnBlanc" type="checkbox"> scrollen auf leerem Hintergrund erlauben</p>
  </div>
  <div id="exchangeSettings" style="display: none">
  <p id="swipeSteuerungP"><input type="checkbox"  id="swipeSteuerung"> beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen</p>
  </div>
  <p id="schiebenSettings">
    <br>
    <strong style="font-size:15px;">mit der Anzahl der Schiebevorgänge, die der PC vornimmt, kann die Schwierigkeit am leichtesten kontrolliert werden</strong>
    <br>
    Male PC verschieben: <input type="number" min="2" style="width: 55px;" id="anzahlVerschieben">
    <br>
    <input type="checkbox" onchange="if (checked) {anzahlVerschieben.style.display = 'none'; innerHTML.replace('_', ''); } else {anzahlVerschieben.style.display = 'inline'; innerHTML += '__'}" id="richtigeCheck"> verschieben, bis höchstens<input type="number" style="width:55px;" max="14" min="0" id="anzahlRichtige" value="10"> an origineller Stelle
    <br>
    <input type="checkbox" id="zurrückVermeiden" checked="true"> <font size="5">leeres Feld 2 Mal an selber Stelle nach <input type="number" id="anzahlVerboten" value="3" style="width: 42px;"> Malen verboten (einfacher, weil immer direkt nebeneinander)</font>
    <!-- <input type="checkbox" id="difficultSchieben"> niemals eine verschiebng rückgängig machen (schwierig, weil immer viel verändert wird) -->
  </p>
  <a style="display: none;" id="turnsHistoryS">
    <br>
    <div id="movementPlayer" style="display: none;">
      <input onchange="changeMovementPlayerVis(checked);" type="checkbox"><b>Züge des PCs ansehen</b>
      <div id="innerMovementPlayer" style="display: none;">
        <br>
        <input id="distinctMovement" onchange="movementStepsChanged(checked);" checked="true" onchange="" type="checkbox"> kürzeste Lösung
        <br>
        <button id="movementDirectionLeft" onclick="changeMovementDirection(-1);"><<</button>
        <button onclick="playMovementPos(objMovementPlayer.position - 1);"><</button>
        <button id="movementPlayButton" onclick="playPauseMovement();">play</button>
        <button onclick="playMovementPos(0);">⟲</button>
        <button onclick="playMovementPos(objMovementPlayer.position + 1);">></button>
        <button id="movementDirectionRight" style="background-color: hsla(180, 100%, 50%, 1);" onclick="changeMovementDirection(1);">>></button>
        <br>
        <input id="movementPosition" oninput="playMovementPos(value);" min="0" type="range"> Position
        <button onclick="playMovementPos(getPlayerPosition());">zu Ihrer Positionierung (falls vorhanden)</button>
        <br>
        <b>Geschwindigkeit</b>
        <br>
        schnell <input min="155" value="500" max="1000" id="movementPlayerSpeed" type="range"> langsam
        <button onclick="movementPlayerSpeed.value = 500;">zurücksetzen</button>
        <br>
        <canvas id="movementPlayerTextur"></canvas>
      </div>
      <br>
    </div>
    <input onchange="if (checked) {userMovementPlayer.style.display = 'inline'; generalSettings.style.display = 'none';} else {userMovementPlayer.style.display = 'none'; generalSettings.style.display = 'inline';}" type="checkbox"> <b>zu vorherigen Zug zurückkehren:</b>
    <a style="display: none;" id="userMovementPlayer">
      <br>
      <button onclick="if (userMovement.index - 1 >= 0) {userMovement.index--; playMovementPos(userMovement.index, null, null, userMovement.moves);}"><</button>
      <input id="playerMovementSlider" oninput="playMovementPos(value, null, null, userMovement.moves);" min="0" max="0" type="range">
      <button onclick="if (userMovement.index < userMovement.moves.length) {userMovement.index++; playMovementPos(userMovement.index, null, null, userMovement.moves);}">></button>
      <br>
      <input id="goBackAsTurns" type="checkbox"> als extra Züge werten
    </a>
  </a>
  <a2 id="generalSettings">
  <h2>allgemeine Einstellungen: </h2>
  <a id="futurePuzzleManager">
  </a>
    <input type="checkbox" onchange="adaptExpandButtonPosition(); if (checked) rightMarkerSettings.style.display = 'inline'; else rightMarkerSettings.style.display = 'none'; layout(true);" id="richtigPlazierte" style="accent-color: green;" checked="true"> markiere richtig plazierte
    <!-- <h3>general</h3> -->
    <a id="rightMarkerSettings">
      <br>
      <input type="range" step="0.01" value="1" oninput="layout(true);" min="0.01" max="1" id="rightMarkerRadius"> radius von Mitte (in %)
      <br>
  <input min="0.01" max="1" step="0.01" value="0.3" oninput="layout(true)" id="rightMarkerTransparence" type="range"> Transparenz (in %)
  </a>
  <br>
  <input type="checkbox" id="raender" onchange="adaptExpandButtonPosition(); if (checked) randSettings.style.display = 'inline'; else randSettings.style.display = 'none'; if (preview.src != '') layout(true, true);"> <font size="5"> zeige Ränder</font>
  <p id="randSettings">
    <br>
    <input type="range" min="1" value="13" oninput="randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - value; layout();" id="breiteRand"> Breite des Randes
    <br>
    <input type="range" min="0" value="0" oninput="layout();" id="randPosition"> Position des Randes
  </p>
  <br>
  <!-- <input type="checkbox" onchange="if (checked == true) {schiebenSettings.style.display = 'inline'; swipeSteuerungP.style.display = 'none';} else {schiebenSettings.style.display = 'none'; swipeSteuerungP.style.display = 'inline';}" id="schieben"> <font size="5">nur schieben</font> -->
  <br>
  <input id="reloadWhenFinished" onchange="localStorage.setItem('reloadWhenFinished', checked)" type="checkbox">Lade die Seite automatisch neu, kurz nachdem das Puzzle fertig ist
  <br>
  <input id="keepScrolling" checked="true" type="checkbox"> am Rand scrollen bis Teil abgewählt oder vom Rand entfernt
  <br>
  <button type="button" id="aufgebenId" onclick="showCurrentStats(modeSelection.value);" name="button">vorläufige bzw. beste Ergebnis ansehen</button>
  <br>
  <div style="display: none;" id="videoControls">
    <h3>video controls</h3>
    <a id="timeChangeDiv">
    <input id="loop" checked="true" onchange="if (checked) stopAtEndP.style.display = 'none'; else stopAtEndP.style.display = 'inline'; playPauseVideo('play');" type="checkbox"> Wiederholen
    <br>
    <input type="checkbox" onclick="video.muted = checked;">mute</input>
    <a id="stopAtEndP" style="display: none;"><input id="stopAtEnd" type="checkbox"> am Ende stoppen</a>
    <br>
    beginne bei <input type="text" oninput="if (value > loopEnding.value) {playPauseVideo('pause'); timeSlotWarning.style.display = 'inline';} else timeSlotWarning.style.display = 'none';" id="loopBeginning"> 
    <button onclick="if (timeText.innerHTML.split(' / ')[0] < loopEnding.value || loopEnding.value == '') {loopBeginning.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100); timeSlotWarning.style.display = 'none';} else timeSlotWarning.style.display = 'block';">nimm aktuelle Zeit</button> 
    und ende bei <input id="loopEnding" oninput="if (value < loopBeginning.value) {playPauseVideo('pause'); timeSlotWarning.style.display = 'inline';} else timeSlotWarning.style.display = 'none';" type="text">
     <button onclick="if (timeText.innerHTML.split(' / ')[0] > loopBeginning.value || loopBeginning.value == '') {loopEnding.value = timeText.innerHTML.split(' / ')[0] + ':' + Math.floor((video.currentTime - Math.floor(video.currentTime))*100); timeSlotWarning.style.display = 'none';} else timeSlotWarning.style.display = 'block';">nimm aktuelle Zeit</button>
    <br>
    <p id="timeSlotWarning" style="background-color: #f44336; border-radius: 3px; border-style: double; width: max-content; display: none;">
      Sie haben das Ende des Ausschnittes vor den Anfang gesetzt! Bitte setzen Sie den Startpunkt weiter vorne oder das Ende weiter hinten, damit Ihre Änderung übernommen wird.
      <br>
    </p>
    <button onclick="video.currentTime -= 10;"><<</button>
    </a>
    <button onclick="playPauseVideo(innerHTML);" id="playVideo">pause</button>
    <a id="timeChangeDiv">
    <button onclick="video.currentTime += 10;">>></button>
    <input oninput="video.currentTime = value; playPauseVideo('pause');" step="0.01" type="range" id="videoPosition" min="0">
    <a id="timeText"></a>
    </a>
</div>
<p id="showOriginalP" style="display:none">
  <input id="showOriginal"  onchange="originalDisplayChanged(checked)" type="checkbox"> Original anzeigen
  <br>
  <img style="display: none;" id="preview">
  <canvas style="display: none;" id="videoPreview"></canvas>
</p>
</a2>
</div>
<br>
<button type="button" id="removeTilesFinishedB" style="display: none; font-size: 33px" onclick="shufflePuzzle();" name="button">Fertig</button>
<a id="tileStatusOptions" style="display: none; position: fixed; background-color: rgba(205, 218, 199, 0.77); border-radius: 5px;">
<input type="radio" id="pRemoveTile" checked="true" style="accent-color: red;" name="tileStatus"> Teil löschen
<input type="radio" id="doNotMoveTile" style="accent-color: blue;" name="tileStatus"> Teil beim Mischen nicht bewegen
</a>
<br>
<br>
<button onclick="expandSide('top');" style="height: 55px;" class="expandButtons" id="expandTop">+</button>
<canvas onmousedown="mouseDown(true);" onmouseup="mouseUp();" style="border-width: 3px; border-style: solid; touch-action: manipulation;" id="textur" width="1" onclick="canvasClicked('elm');" height="1"></canvas>
<button onclick="expandSide('right');" style="width: 55px;" class="expandButtons" id="expandRight">+</button>
<button onclick="expandSide('left');" style="width: 55px;" class="expandButtons" id="expandLeft">+</button>
<br>
<button class="expandButtons" style="height: 55px;" onclick="expandSide('bottom');" id="expandBottom">+</button>
<canvas id="tileSelectionCanvas" onmousedown="mouseDown(true);" onmouseup="mouseUp();" width="1" height="1"></canvas>
<div class="expandButtons" id="backToBarButtons">
</div>
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.3'" id="scrollTileSelectionRight" onclick="scrollTileSelection(1, 'elm');">
<img draggable="false" src="https://adi.nicolaiweitkemper.de/Bilder/roterPfeil.png" onmouseover="this.style.opacity = '1'" onmouseout="this.style.opacity = '0.3'" id="scrollTileSelectionLeft" onclick="scrollTileSelection(-1, 'elm');">
<style>
  .dropdown {
position: relative;
display: inline-block;
}

.dropdown-content {
display: none;
position: absolute;
background-color: #f1f1f1;
min-width: 160px;
box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
z-index: 1;
}

.dropdown-content a {
color: black;
padding: 12px 16px;
text-decoration: none;
display: block;
}

.dropdown-content a:hover {background-color: #ddd;}
</style>
<style>
  #tileSelectionCanvas {
    /* position: -webkit-sticky; */
    position: fixed;
    bottom: 0px;
    overflow: hidden;
    background-color: hsla(0, 0%, 64%, 0.77);
    touch-action: none;
  }
  #scrollTileSelectionRight {
    position: fixed;
    right: 0px;
    opacity: 0.3;
    display: none;
  }
  #scrollTileSelectionLeft {
    position: fixed;
    left: 0px;
    opacity: 0.3;
    transform: rotate(180deg);
    display: none;
  }

  .backToTileB {
    position: fixed;
  }
  .expandButtons {
    display: none;
    font-size: 55px;
    position: absolute;

  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  }
</style>
<style name="bubbleStyle">
  /* (A) SPEECH BOX */
  .speech {
    /* (A1) FONT */
    font-family: arial, sans-serif;
    /* font-size: 0.5em; */
    /* font-size: 0.7em; */
    /* font-size: 1vw; */
    font-size: 25px;
  
    /* (A2) COLORS */
    color: #fff;
    background: blue;
  
    /* (A3) DIMENSIONS + POSITION */
    position: absolute;
    padding: 20px;
    border-radius: 10px;
    max-width: 320px;
    z-index: 2;
  }
  
  /* (B) ADD SPEECH "CALLOUT TAIL" */
  /* (B1) USE ::AFTER TO CREATE THE "TAIL" */
  .speech::after {
    /* (B1-1) ATTACH TRANSPARENT BORDERS */
    content: "";
    border: 20px solid transparent;
  
    /* (B1-2) NECESSARY TO POSITION THE "TAIL" */
    position: absolute;
  }
  
  /* (B2) BOTTOM "CALLOUT TAIL" */
  .bottom.speech::after {
    /* (B2-1) DOWN TRIANGLE */
    border-top-color: blue;
    border-bottom: 0;
  
    /* (B2-2) POSITION AT BOTTOM */
    bottom: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C) DIFFERENT TAIL POSITIONS */
  /* (C1) TOP */
  .top.speech::after {
    /* (C1-1) UP TRIANGLE */
    border-bottom-color: blue;
    border-top: 0;
  
    /* (C1-2) POSITION AT TOP */
    top: -20px; left: 50%;
    margin-left: -20px;
  }
  
  /* (C2) LEFT */
  .left.speech::after {
    /* (C2-1) LEFT TRIANGLE */
    border-right-color: blue;
    border-left: 0;
  
    /* (C2-2) POSITION AT LEFT */
    left: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (C3) RIGHT */
  .right.speech::after {
    /* (C3-1) RIGHT TRIANGLE */
    border-left-color: blue;
    border-right: 0;
  
    /* (C3-2) POSITION AT RIGHT */
    right: -20px; top: 50%;
    margin-top: -20px;
  }
  
  /* (X) DOES NOT MATTER - SPACERS */
  /* .speech, .circular { margin: 50px 0 0 50px; } */
  body { padding-bottom: 100px; }
  
  </style>
  <style>
    #tutorial {
      background-color: rgba(205, 218, 199, 0.77);;
      position: absolute;
      right: 0px;
      top: 0px;
      width: 47%;
      box-shadow: 2px 2px 20px #855d5d;
      display: none;
    }
    .tutorialCard {
      box-shadow: 2px 2px 10px #855d5d;
      padding-top: 5px;
      padding-bottom: 5px;
      margin-top: 7px;
      margin-bottom: 7px;
      /* display: none; */
    }
    .tutorialGeneral {
      border-radius: 10px;
      padding-left: 10px;
      padding-right: 10px;
    }
    .currentTutorialStep {
      box-shadow: 2px 2px 10px red;
      margin-top: 3px;
      margin-bottom: 3px;
    }
  </style>
  <div id="tutorial" class="tutorialGeneral">
    <div style="display: none;" id="traditionalTutorial">
    <div class="tutorialCard tutorialGeneral section" id="moveTutorial">
      <h2>Teile bewegen und drehen</h2>
      <div class="tutorialCard tutorialGeneral">
        <b>Informationen zum Teile drehen</b>
        <br>
        Wenn es nicht in den Einstellungen geädert wird, müssen die Teile rotiert werden, um zu passen. Deshalb werden beim Laden eines Bildes oder Videos automatisch die Breite und Höhe angeglichen. Wenn Sie die Breite oder Höhe des Bildes bzw. Videos ändern, können Sie das Teil zwar immer noch drehen, jedoch nur noch an den logischen Seiten miteinander verbinden. 
      </div>
      <div class="tutorialCard tutorialGeneral" id="moveStandardPC">
        <input type="radio" id="moveStyleStandard" onclick="unclippStandard.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {goTutorialSteps(1); automaticTileSelectionReset.checked = !checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', !checked);" name="moveStyle"> <b>Standard</b>
        <div id="tileClickMoveTutorialDiv"><input type="checkbox" id="tileClickMoveTutorial" onclick="checked = !checked"> Klicken Sie auf das gewünschte Teil. </div>
        <div id="moveMouseMoveTutorialDiv"><input type="checkbox" id="moveMouseMoveTutorial" onclick="checked = !checked"> Bewegen Sie dann den Mauszeiger, um das Teil zu bewegen. </div>
        <div id="rotateTileTutorialDiv"><input type="checkbox" id="rotateTileTutorial" onclick="checked = !checked"> Drücken Sie die linke bzw. rechte Pfeiltaste, um das Teil nach links bzw. rechts zu rotieren.</div>
        <div id="clickUnselectMoveTutorialDiv"><input type="checkbox" id="clickUnselectMoveTutorial" onclick="checked = !checked"> Durch einen erneuten Mausklick auf das Teil können Sie es wieder loslassen bzw. abwählen.</div>
      </div>
      <div class="tutorialCard tutorialGeneral" id="moveAlternativePC">
          <input type="radio" id="moveStyleAlternative" onclick="unclippAlternative.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {goTutorialSteps(1); automaticTileSelectionReset.checked = checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" name="moveStyle"> <b>Alternative</b>
          <div id="holdMouseMoveTutorialDiv"><input type="checkbox" id="holdMouseMoveTutorial" onclick="checked = !checked"> Halten Sie die Maustaste gedrückt (oder doppelklicken Sie und lassen Sie Ihren Finger auf dem Touchpad).</div>
          <div id="moveMouseMoveTutorialAlternativeDiv"><input type="checkbox" id="moveMouseMoveTutorialAlternative" onclick="checked = !checked"> Bewegen Sie den Mauszeiger, um das Teil zu bewegen. </div>
          <div id="rotateTileTutorialAlternativeDiv"><input type="checkbox" id="rotateTileTutorialAlternative" onclick="checked = !checked"> Drücken Sie die linke bzw. rechte Pfeiltaste, um das Teil nach links bzw. rechts zu rotieren. </div>
          <div id="releaseMoveTutorialDiv"><input type="checkbox" id="releaseMoveTutorial" onclick="checked = !checked"> Lassen Sie die Taste bzw. das Touchpad los. </div>
      </div>
      <div id="moveStyleSettingChosenDiv"><input id="moveStyleSettingChosen" type="checkbox" onclick="checked = !checked"> Wählen Sie, ob Sie standardmäßig den Standard oder die Alternative haben wollen. Sie können diese Einstellung jederzeit in dem Einstellungsmenü ändern. </div>
    </div>
      <div class="tutorialCard tutorialGeneral section" id="clippTutorial">
      <h2>Teile verbinden und lösen</h2>
      <div class="tutorialCard tutorialGeneral" id="connectTiles">
        <h3>Teile verbinden</h3>
        <!-- <div class="tutorialCard tutorialGeneral"> -->
          <!-- <b>Informationen zum Teile verbinden</b> -->
          <div class="tutorialCard tutorialGeneral">
            <b style="font-size: 15px;">Hitboxen</b>
            <br>
            In den Einstellungen haben Sie die Möglichkeit, die Hitboxen zu verkleinern, wodurch Sie näher am Teil sein müssen, damit die Verbindung angeboten wird. Dies kann beispielsweise helfen, wenn Sie mit den vielen Verbindungsvorschlägen überfordert sind oder häufig ausversehen Teile verbinden. Andersrum können Sie die Hitbox auch vergrößern, damit Sie die Teile nicht so weit bewegen müssen.
          </div>
          <div class="tutorialCard tutorialGeneral">
            <b style="font-size: 15px;">Verbindungsmöglichkeiten bei Teilkollisionen werden nicht angeboten</b>
            <br>
           Standardmäßig werden Verbindungsmöglichkeiten von Teilen, an dessen Rand ein Teil angeknüpft werden soll und unter einem anderen Teil liegen, nicht angeboten. Falls Sie dies stört, können Sie auch das in den Einstellungen ändern ("Teile an verdeckte Ränder nicht anknüpfen lassen")
          </div>
        <!-- </div> -->
        <div class="tutorialCard tutorialGeneral">
        <div id="selectTileConnectTileTutorialDiv"><input type="checkbox" id="selectTileConnectTileTutorial" onclick="checked = !checked"> Wählen Sie ein Teil an. </div>
        <div id="getClippingOptionConnectTileTutorialDiv"><input type="checkbox" id="getClippingOptionConnectTileTutorial" onclick="checked = !checked"> Nähern Sie sich einem anderen Teil. </div>
        <div id="clipTileTutorialDiv"><input type="checkbox" id="clipTileTutorial" onclick="checked = !checked"> Wählen Sie das Teil ab, wenn Sie einen blauen Strich sehen, um es mit dem anderen zu verbinden. </div>
        </div>
        <div id="clippSecondTutorialDiv"><input id="clippSecondTutorial" type="checkbox" onclick="checked = !checked"> Verbinden Sie ein weiteres Teil. </div>
      </div>
      <div class="tutorialCard tutorialGeneral" id="disconnectTiles">
        <h3>Teile lösen</h3>
        <div class="tutorialCard tutorialGeneral">
          <input type="radio" onclick="moveStyleStandard.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {tutorial.state = 'selectTileConnectTileTutorial';  automaticTileSelectionReset.checked = !checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', !checked);" id="unclippStandard" name="unclippStyle"><b> Standard (verbunden mit Standard für Bewegen der Teile) </b>
          <div id="pressShiftStandardUnclippTutorialDiv"><input type="checkbox" id="pressShiftStandardUnclippTutorial" onclick="checked = !checked"> Drücken Sie die Shift Taste. </div>
          <div id="selectTileStandardUnclippTutorialDiv"><input type="checkbox" id="selectTileStandardUnclippTutorial" onclick="checked = !checked"> Wählen Sie ein Teil aus (außerhalb des Tutorials beliebige Anzahl möglich) </div>
          <div id="releaseShiftStandardUnclippTutorialDiv"><input type="checkbox" id="releaseShiftStandardUnclippTutorial" onclick="checked = !checked"> Lassen Sie die Shift Taste los. </div>
          <div id="unclippStandardTutorialDiv"><input type="checkbox" id="unclippStandardTutorial" onclick="checked = !checked"> Bewegen Sie den Mauszeiger, um die Teile zu lösen. </div>
          <div id="unselectUnclippStandardTutorialDiv"><input type="checkbox" id="unselectUnclippStandardTutorial" onclick="checked = !checked"> Klicken Sie, um die ausgewählen Teile abzuwählen. </div>
        </div>
        <div class="tutorialCard tutorialGeneral">
          <input type="radio" onclick="moveStyleAlternative.checked = checked; moveStyleSettingChosen.checked = true; if (tutorial.state == 'moveStyleSettingChosen' || tutorial.state == 'selectTileConnectTileTutorial') {tutorial.state = 'selectTileConnectTileTutorial';  automaticTileSelectionReset.checked = checked;} localStorage.setItem('automaticTileSelectionResetPuzzleCreator', checked);" id="unclippAlternative" name="unclippStyle"> <b>Alternative (verbunden mit Alternative für Bewegen der Teile)</b>
          <div id="pressShiftAlternativeUnclippTutorialDiv"><input type="checkbox" id="pressShiftAlternativeUnclippTutorial" onclick="checked = !checked"> Drücken Sie die Shift Taste. </div>
          <div id="selectTileAlternativeUnclippTutorialDiv"><input type="checkbox" id="selectTileAlternativeUnclippTutorial" onclick="checked = !checked"> Wählen Sie ein Teil aus (außerhalb des UnclippTutorials beliebige Anzahl möglich, Maustaste drücken und halten oder Doppelklick auf Touchpad) </div>
          <div id="unclippTileAlternativeUnclippTutorialDiv"><input type="checkbox" id="unclippTileAlternativeUnclippTutorial" onclick="checked = !checked"> Bewegen Sie den Mauszeiger, um die Teile zu lösen. </div>
          <div id="releaseShiftAlternativeUnclippTutorialDiv"><input type="checkbox" id="releaseShiftAlternativeUnclippTutorial" onclick="checked = !checked"> Lassen Sie die Shift Taste los. </div>
          <div id="unselectAlternativeUnclippTutorialDiv"><input type="checkbox" id="unselectAlternativeUnclippTutorial" onclick="checked = !checked"> Lassen Sie das Touchpad bzw. die Maustaste los, um das Teil abzuwählen. </div>
        </div>
      </div>
    </div>
    <div class="tutorialCard tutorialGeneral section" id="generalSkills">
      <h2>allgemeine Fertigkeiten</h2>
      <div id="scrollTutorial" class="tutorialCard tutorialGeneral">
        <b style="font-size: 21px;">scroling</b>
        <br>
        <div class="tutorialCard tutorialGeneral" id="manualScrollingTutorial">
          <h3>manuell scrollen</h3>
          <div id="selectTileScrollingTutorialDiv"><input type="checkbox" id="selectTileScrollingTutorial" onclick="checked = !checked">Teil anwählen (wenn Sie 2 Finger Geste nutzen wollen mit der linken Maustaste)</div> 
          <div id="manuallyScrollingTutorialDiv"><input type="checkbox" id="manuallyScrollingTutorial" onclick="checked = !checked">scrollen (z.B. mit 2 Finger Geste auf dem Touchpad oder mit dem Mausrad)</div> 
          <div id="unselectTileScrollingTutorialDiv"><input type="checkbox" id="unselectTileScrollingTutorial" onclick="checked = !checked">Teil abwählen</div> 
        </div>
        <div class="tutorialCard tutorialGeneral" id="autoScrollTutorial">
          <h3>automatisch scrollen</h3>
          <div id="selectTileAutomaticScrollingTutorialDiv"><input type="checkbox" id="selectTileAutomaticScrollingTutorial" onclick="checked = !checked">Teil anwählen</div> 
          <div id="automaticScrollingTutorialDiv"><input type="checkbox" id="automaticScrollingTutorial" onclick="checked = !checked">Teil so weit nach unten schieben, dass mehr als die Hälfte des Teils den Bildschirm verlassen hat (außerhalb des tutorials alle Richtungen möglich)</div> 
          <!-- TODO: vom Rand weg bewegen -->
          <div id="stopScrollingAutomaticScrollingTutorialDiv"><input type="checkbox" id="stopScrollingAutomaticScrollingTutorial" onclick="checked = !checked">Teil abwählen oder vom Rand weg bewegen, um das Scrolling zu stoppen</div> 
        </div>
      </div>
      <div class="tutorialCard tutorialGeneral" id="autoScrollTutorial">
        <h3>Zoomen</h3>
        Wie auch auf jeder anderen Website, können Sie rein- und rauszoomen. Das übliche ist Str. + "-" zum Rauszoomen und Str. + "+" zum Reinzoomen (es kann auch das Mausrad statt plus und minus benutzt werden). Dadurch können Sie das "Spielfeld" besser überblicken, haben jedoch auch kleinere Teile und umgekehrt. 
      </div>
    </div>
      <div class="tutorialCard tutorialGeneral section" id="tileSelectionBarTutorial">
        <h3>Die Teilliste</h3>
        <div class="tutorialCard tutorialGeneral">
          <b>Informationen zur aufbereitung der Teile (ink. Teilliste)</b>
          <br>
          In den Einstellungen können Sie auswählen, wie die Teile aufbereitet werden. Sie können verteil werden (mit Überlappen), in die Teilliste gebracht werden, um die es im Folgenden geht, oder auf dem Spielfeld nebeneinander gelegt werden. Zudem können Sie mit leerer Liste starten, sodass Sie die Teile sortiert dort ablegen oder auf dem Spielfeld behalten können. 
        </div>
        <div class="tutorialCard tutorialGeneral" id="controlTileBarScrollTutorial">
          <h3>Scrolling in der Teilliste</h3>
          <div id="scrollArrowTileBarTutorialDiv"><input type="checkbox" id="scrollArrowTileBarTutorial" onclick="checked = !checked">Scrollen durch Anklicken der roten Pfeile an den Rändern des Bildschirms</div> 
          <div class="tutorialCard tutorialGeneral" id="scrollWithMouse">
            <h4>Scrollen mit der Maustaste</h4>
            <div id="MouseDownScrollTileBarTutorialDiv"><input type="checkbox" id="MouseDownScrollTileBarTutorial" onclick="checked = !checked">Maustaste drücken oder auf Touchpad doppelklicken und gedrückt halten bzw. Finger auf Touchpad lassen</div> 
            <div id="moveMouseScrollTileSelectionBarTutorialDiv"><input type="checkbox" id="moveMouseScrollTileSelectionBarTutorial" onclick="checked = !checked">Zeiger bewegen, um die Liste in die entsprechende Richtung zu bewegen </div> 
            <div id="stopScrollingTileBarTutorialDiv"><input type="checkbox" id="stopScrollingTileBarTutorial" onclick="checked = !checked">Maustaste bzw. Touchpad loslassen</div> 
          </div>
          <div id="ScrollkeyTileBarTutorialDiv"><input type="checkbox" id="ScrollkeyTileBarTutorial" onclick="checked = !checked">Scrollen durch drücken der linken bzw. rechten Pfeiltaste (Mauszeiger muss auf Liste sein)</div> 
        </div>
        <div class="tutorialCard tutorialGeneral" id="leaveTileBarTutorial">
          <h3>Teile auf "Spielfeld" bringen</h3>
          <div class="tutorialCard tutorialGeneral" id="leaveTileBarTutorial">
            <div id="selectTileBarTileTutorialDiv"><input type="checkbox" id="selectTileBarTileTutorial" onclick="checked = !checked">Klicken Sie auf ein Teil in der Liste, um es anzuwählen.</div> 
            <div id="placeTileOnFiledTutorialDiv"><input type="checkbox" id="placeTileOnFiledTutorial" onclick="checked = !checked">Klicken Sie auf das "Spielfeld", um das Teil dort "abzulegen". </div> 
            <div id="unselecTileAfterTileBarTilePlacementTutorialDiv"><input type="checkbox" id="unselecTileAfterTileBarTilePlacementTutorial" onclick="checked = !checked">Wählen Sie das Teil ab.</div> 
          </div>
          <div id="SecondPlaceTileTutorialDiv"><input type="checkbox" id="SecondPlaceTileTutorial" onclick="checked = !checked">Legen Sie ein weiteres Teil auf dem Spielfeld ab.</div> 
        </div>
        <div class="tutorialCard tutorialGeneral" id="backToBarTutorial">
          <h3>Teile zurück in Teilliste bringen</h3>
          <div class="tutorialCard tutorialGeneral" id="backToBarPlusBTutoria">
            <h4>mit "+"-Button</h4>
            <div id="BackToTileBarTutorialDiv"><input type="checkbox" id="BackToTileBarTutorial" onclick="checked = !checked">Klicken Sie auf einen der "+"-Bottons</div> 
            <div id="backToTileBarPlusBTutorialDiv"><input type="checkbox" id="backToTileBarPlusBTutorial" onclick="checked = !checked">Klicken Sie auf ein Teil, um es an der ausgewählen Stelle zurück in die Teilliste zu bringen. </div> 
          </div>
          <div class="tutorialCard tutorialGeneral" id="backToBarBTutorial">
            <h4>mit "zurück in Leiste"-Button</h4>
            <div id="selectTileTileBarZurückInLeisteTutorialDiv"><input type="checkbox" id="selectTileTileBarZurückInLeisteTutorial" onclick="checked = !checked">Wählen Sie ein Teil in der Teilleiste an. Rechts von dem ausgewählen Teil wird das neue Teil eingereiht werden. </div> 
            <div id="clickBackToBarBTurotialDiv"><input type="checkbox" id="clickBackToBarBTurotial" onclick="checked = !checked">Klicken Sie auf den "zurück in Leiste"-Botton </div> 
            <div id="selectBackToBarTileZurückInLeisteTutorialDiv"><input type="checkbox" id="selectBackToBarTileZurückInLeisteTutorial" onclick="checked = !checked">Klicken Sie das Teil an, das Sie zurückholen wollen. </div> 
          </div>
        </div>
      </div>
    </div>
    <div class="tutorialCard tutorialGeneral">
      <h3>Einstellungen</h3>
      Es gibt viele weitere Einstellungen, auf die in diesem Tutorial nicht eingegangen wurde, da diese selbsterklärend sein sollten. Gucken Sie doch einfach mal durch!
    </div>
  <div id="completePuzzleTutorialDiv"><input type="checkbox" id="completePuzzleTutorial" onclick="checked = !checked">Vervollständigen Sie das Puzzle.</div> 
</div>
<script>
    window.onbeforeunload = function(){
    console.log("Leave Website");
      return 'Are you sure you want to leave?';
  };
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
    automaticTileSelectionReset.checked = true;
    automaticTileSelectionReset.style.display = 'none';
    // tileSelectionCanvas.style.position = "fixed";
  } else {
    var gerät = "PC"
    console.log("PC");
    swipeSteuerungP.innerHTML = swipeSteuerungP.innerHTML.replace('beginne Sipe bei erstem und beende ihn beim 2. Teil, um sie zu vertauschen', 'drücken Sie die Maustaste runter oder vollführen Sie einen Doppelklick beim ersten Teil und lassen Sie beim 2. Teil los. ');
    scrollOnBlancP.style.display = "none";
    vibrateA.style.display = "none";
  }
  gapSizeChanged(tilesGap.value);
  expandBottom.style.height = window.innerWidth/29;
  expandTop.style.height = window.innerWidth/29;
  expandLeft.style.width = window.innerWidth/29;
  expandRight.style.width = window.innerWidth/29;
  mobileControls.style.display = 'none';
  reloadWhenFinished.checked = JSON.parse(localStorage.getItem("reloadWhenFinished"));
  anzahlVerschieben.value = anzahlX.value*anzahlY.value;
  aufgebenId.style.display = "none";
  // schiebenSettings.style.display  = "inline"
  randSettings.style.display = "none";
  schiebenSettings.style.display = "none";
  größeAnpassenX.max = window.innerWidth
  größeAnpassenY.max = window.innerHeight
  var canvas = textur.getContext('2d');
  // section 1: mainly change element style and visibility
  function checkOut(closeAnyway) {
    var stillIn = false;
      for (var elm of document.getElementsByClassName('dropdown-content')[0].children) {
        if (window.getComputedStyle(elm).backgroundColor == "rgb(221, 221, 221)") stillIn = true;
      }
    if (!stillIn || closeAnyway) document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function shuffleStyleVisibilities(value) {
    if (value == 'nextToEachOther') tilesGapS.style.display = 'inline'; 
    else tilesGapS.style.display = 'none';
    if (value == "listTiles") aEmptyTileBar.style.display = "inline";
    else aEmptyTileBar.style.display = "none";
    if (value == "overlapTiles") shuffleHeadline.style.display = 'none';
    else shuffleHeadline.style.display = 'inline';
    if (value == 'listTiles' && emptyTileBar.checked) {
      emptyTileBarSettings.style.display = 'inline';  
      if (shuffleStyleBar.value == "nextToEachOther") tilesGapS.style.display = 'inline';
    }
    else emptyTileBarSettings.style.display = 'none';
  }
  function backToBarVis(checked) {
    if (checked) {
      backToBarButtons.style.display = 'inline';
      backToBarBSize.style.display = 'inline';
    }
    else {
      backToBarButtons.style.display = 'none';
      backToBarBSize.style.display = 'none';
    }
  }
  function showTitle(id, display) {
    id = id.replace('Symbol', 'Title');
    if (id != "rotateLeftTitle") rotateLeftTitle.style.display = 'none'; 
    if (id != "rotateRightTitle") rotateRightTitle.style.display = 'none'; 
    if (id != "selectMultipleTitle") selectMultipleTitle.style.display = 'none'; 
    if (id != "swipeTitle") swipeTitle.style.display = 'none'; 
    if (document.getElementById(id).style.display == "inline") document.getElementById(id).style.display = "none";
    else {
      document.getElementById(id).style.display = "inline";
      setTimeout(function () {
        document.getElementById(id).style.display = "none";
      }, 5000);
    }
  }
  function changeSettingsVis(vis) {
    if ((settings.style.display == 'none' || vis == "inline") && vis != "none") {
      settings.style.display = 'inline'; 
      if (!state.removeTile && aufgebenId.style.display == "inline") wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
    }
    else {
      settings.style.display = 'none';
      originalDisplayChanged(false);
      canvas = textur.getContext('2d');
      if (wrongPosition && !state.changedPos) positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
      state.changedPos = false; 
    }
    if (modeSelection.value == "traditional") adaptExpandButtonPosition();
    texturTop = textur.getBoundingClientRect().top + scrollY;
  }
  function adaptExpandButtonPosition() {
    setTimeout(() => {
      if (settings.style.display == "inline") expandTop.style.top = settings.getBoundingClientRect().bottom + scrollY + 17;
      else expandTop.style.top = showSettings.getBoundingClientRect().bottom + scrollY + 17;
      textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY;
      texturTop = textur.getBoundingClientRect().top + scrollY;
      expandRight.style.top = textur.getBoundingClientRect().top + scrollY;
      expandLeft.style.top = textur.getBoundingClientRect().top + scrollY;
      expandBottom.style.top = textur.getBoundingClientRect().top + scrollY;
      // update canvas and expand buttons position
      expandSide();
      textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
    }, 10);
  }
  function mirrorCanvas(checked) {
    if (checked) textur.style = "-webkit-transform: scaleX(-1); transform: scaleX(-1);";
    else {
      textur.style.transform = "";
      textur.style.webkitTransform = "";
    }
  }
  // change visibility of player of PC movement in schieben mode
  function changeMovementPlayerVis(checked) {
    if (checked) {
      innerMovementPlayer.style.display = 'inline'; 
      playMovementPos(getPlayerPosition(true));
      texturTop = textur.getBoundingClientRect().top + scrollY;
      movementPlayer.scrollIntoView();
      window.scroll(0, scrollY);
    }
    else {
      innerMovementPlayer.style.display = 'none';
      texturTop = textur.getBoundingClientRect().top + scrollY;
      canvas = textur.getContext('2d');
    }
  }
  // change size of + buttons for backToBar
  function changeBackToBarB(side, value) {
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var button = document.getElementsByClassName('backToTileB')[i];
      button.style[side] = value + 'px';
      button.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2 + 'px';
      button.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(button.style.width)/2 + 'px';
    }
  }
  // change play direction of movement player (player which shows the moves the PC did in schieben mode)
  function changeMovementDirection(direc) {
    objMovementPlayer.direc = direc;
    movementDirectionLeft.style.backgroundColor = '';
    movementDirectionRight.style.backgroundColor = '';
    if (direc == -1) movementDirectionLeft.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
    else movementDirectionRight.style.backgroundColor = 'hsla(180, 100%, 50%, 1)';
  }
  function changeTileBarHeight(value) {
    tileBarHeight.value = value;
    tileSelectionCanvas.style.height = JSON.parse(value) + 'px';
    // TODO: handle sides seperately
    tileSelectionBar.pictureSize = {width: JSON.parse(value - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)), height:JSON.parse(value) - 10*(JSON.parse(value - 10)/lengthPerTeil.edit.x)};
    lengthPerTeil.sizeAdapted = {x: tileSelectionBar.pictureSize.width, y: tileSelectionBar.pictureSize.height};
    tileSelectionCanvas.width = 10000;
    layout();
    for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
      backToBarBWidth.value = lengthPerTeil.sizeAdapted.x/7;
      backToBarBHeight.value = lengthPerTeil.sizeAdapted.y/7;
      elm.style.width = backToBarBWidth.value;
      elm.style.height = backToBarBHeight.value;
      elm.style.bottom = (lengthPerTeil.sizeAdapted.y + 5)/2 - (backToBarBHeight.value)/2;
      elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
    }
    backToBarBWidth.max = lengthPerTeil.sizeAdapted.x;
    backToBarBHeight.max = lengthPerTeil.sizeAdapted.y;
    scrollTileSelectionRight.style.bottom = lengthPerTeil.sizeAdapted.y/4 + "px";
    scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/4 + "px";
    scrollTileSelectionLeft.height = lengthPerTeil.sizeAdapted.y/2;
    scrollTileSelectionRight.height = lengthPerTeil.sizeAdapted.y/2;
    if (gerät == "Handy") {
      scrollTileSelectionRight.style.bottom = lengthPerTeil.sizeAdapted.y/2 + "px";
      scrollTileSelectionLeft.style.bottom = lengthPerTeil.sizeAdapted.y/2 + "px";
    }
  }
  function originalDisplayChanged(checked) {
    startPause('viewOriginal');
    if (checked) stats.viewOriginal.times++;
    if (checked) {
      if (sourceIsPicture.checked) preview.style.display = "inline";
      else videoPreview.style.display = "inline";
      showOriginal.scrollIntoView();
    }
    else {
      if (sourceIsPicture.checked) preview.style.display = "none";
      else videoPreview.style.display = "none";
    }
    adaptExpandButtonPosition();
  }
  // section 2: actions followed by element change/user input
  function showInformation() {
    var puzzle = puzzles[selected.puzzle];
    alert(`Dieses Puzzle nutzt den Modus "${puzzle.mode}". Sie haben bereits ${getTimeString(puzzle.completionTime)} Minuten mit dem Puzzle verbracht. Das Puzzle enthält ${puzzle.positions.wrong.length} Teile. `);
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function editPuzzleName() {
    var newName = prompt("Bitte geben Sie hier den neuen Namen ein.", selected.puzzle);
    if (newName && newName != selected.puzzle) {
      getPuzzles();
      puzzles[newName] = puzzles[selected.puzzle];
      delete puzzles[selected.puzzle];
      localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
      getPuzzles();
    }
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function deletePuzzle() {
    getPuzzles();
    delete puzzles[selected.puzzle]; 
    localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
    getPuzzles();
    document.getElementsByClassName('dropdown-content')[0].style.display = 'none';
  }
  function showHitboxes() {
    var canvas = hitboxTextur.getContext('2d');
    canvas.clearRect(0, 0, hitboxTextur.width, hitboxTextur.height);
    canvas.fillStyle = "red";
    canvas.fillRect(0, 0, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillRect(lengthPerTeil.edit.x + 11, 0, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillRect(0, lengthPerTeil.edit.y + 11, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
    canvas.fillRect(lengthPerTeil.edit.x, lengthPerTeil.edit.y/2 - hitboxHeight.value/2, 10, hitboxHeight.value);
    canvas.fillRect(lengthPerTeil.edit.x/2 - hitboxWidth.value/2, lengthPerTeil.edit.y, hitboxWidth.value, 10);
  }
  function changeAdaptedSizeMax(width, height) {
    textur.width = width// + 111;
    textur.height = height// + 111;
    if (window.innerWidth > width || screenIsMax.checked) größeAnpassenX.max = window.innerWidth;
    else größeAnpassenX.max = width;
    if (window.innerHeight > height || screenIsMax.checked) größeAnpassenY.max = window.innerHeight;
    else größeAnpassenY.max = height;
    größeAnpassenX.value = width;
    größeAnpassenY.value = height;
    zeigeGröße();
  }
    // back to bar to the right of the selected tile in the tileBar
    function generalBackToBar(elm) {
    if (tileSelectionBar.tiles.length != anzahlX.value*anzahlY.value) {
      if (tutorial.state == "clickBackToBarBTurotial") goTutorialSteps(1);
      state.backToBar = tileSelectionBar.selectedTile.i + 1; 
      elm.style.backgroundColor = 'red';
      tileSelectionBar.selectedTile = undefined;
    }
  }
  function expandSide(side) {
    // if (!state.sideExpanded && aufgebenId.style.display == 'inline') {
    if (['right', 'left'].includes(side)) textur.width += lengthPerTeil.edit.x*3;
    if (['bottom', 'top'].includes(side)) textur.height += lengthPerTeil.edit.y*3;
    expandRight.style.left = textur.getBoundingClientRect().right + scrollX + 'px';
    expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY; + 'px';
    expandBottom.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandTop.style.width = (textur.getBoundingClientRect().right + scrollX) - (textur.getBoundingClientRect().left + scrollX);
    expandRight.style.height = textur.height + 6; 
    expandLeft.style.height = textur.height + 6; 
    if (['top', 'left'].includes(side)) {
      var moveDirection = "x";
      if (side == "top") moveDirection = "y";
      for (const position of positions.wrong) {
        position.edit[moveDirection] += lengthPerTeil.edit[moveDirection]*3;
      }
    }
    state.rightScroll = 0;
    state.upScroll = 0;
    layout(true, true);
  }
  function showCurrentStats(mode) {
    if (mode == "traditional") alert(`Ihre vorläufigen Daten: Sie haben ${stats.turns} Mal Teile verbunden (es ist mit mindestens ${anzahlX.value*anzahlY.value - 1} Malen möglich) und ${stats.unclipped} Mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} Mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} Mal ein Teil gedreht.`);
    if (mode == "exchange") alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen (Es ist mit " + (positions.wrong.length - stats.preOrdered) + "Zügen möglich! Werden Sie es wohl schaffen?)");
    if (mode == "schieben") alert("Ihre Höchste Übereinstimmung mit dem Original beträgt " + stats.highestRight.right + " von " + positions.wrong.length + " Teilen nach " + stats.highestRight.turns + " Zügen (Es ist mit " + distinctMoves.length + "Zügen oder weniger möglich! Werden Sie es wohl schaffen?)");
    if (mode != "traditional" && stats.preOrdered) alert(`Bedenken Sie jedoch, dass Sie von den ${stats.highestRight.right} Richtigen von Anfang an ${stats.preOrdered} Teile von den insgesamt ${positions.wrong.length} Teilen an der richtigen Position hatten!`);
    alert(`Zudem haben Sie bis jetzt ${stats.viewOriginal.times} Mal für insgesamt ${stats.viewOriginal.time} Minuten auf das Originalbild geguckt und bis jetzt insgesant ${stats.completionTime} mit diesem Puzzle verbracht.`.replace('undefined', '0'));
  }
  function zuBildschirmgröße() {
    größeAnpassenX.value = window.innerWidth;
    größeAnpassenY.value = window.innerHeight;
    zeigeGröße();
  }
  function resetImageSize() {
    größeAnpassenX.value = preview.naturalWidth;
    größeAnpassenY.value = preview.naturalHeight;
    zeigeGröße();
  }
  // Seitenverhältnisse des Bildes anpassen
  function zuAngepassterBildschirmgröße(noShowing) {
    var referenceSize = originalSize;
    if (!screenIsMax.checked) referenceSize = {width: JSON.parse(JSON.stringify(größeAnpassenX.value)), height: größeAnpassenY.value};
    else referenceSize = {width: window.innerWidth + 1, height: window.innerHeight + 1};
    if (window.innerWidth < referenceSize.width && window.innerHeight < referenceSize.height) {
      größeAnpassenX.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [window.innerWidth, window.innerHeight].sort((a, b) => a - b)[0];
    }
    else {
      größeAnpassenX.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
      größeAnpassenY.value = [referenceSize.width, referenceSize.height].sort((a, b) => a - b)[0];
    }
    if (!noShowing || noShowing == "repeat") zeigeGröße(true);
    if (screenIsMax.checked) {
      preventAutomaticZoom.content = `width=${größeAnpassenX.value}, height=${größeAnpassenY.value}, initial-scale=1.0, maximum-scale=1.0, user-scalable=0`;
      if (!noShowing) zuAngepassterBildschirmgröße("repeat");
    }
  }
  function zuOptimalerBildschirmgröße() {
    größeAnpassenX.value = preview.width;
    größeAnpassenY.value = preview.height;
    while (größeAnpassenX.value > window.innerWidth || größeAnpassenY.value > window.innerHeight) {
      größeAnpassenX.value--;
      größeAnpassenY.value--;
    }
    zeigeGröße();
  }
  function zeigeGröße(adapted, onInput) {
    if (größeAnpassenX.value != größeAnpassenY.value && !state.loadImage) bAdaptAmount.checked = true;
    if (state.loadImage && !adapted) zuAngepassterBildschirmgröße();
    delete state.loadImage;
    textur.width = größeAnpassenX.value;
    textur.height = größeAnpassenY.value
    // canvas.clearRect(0, 0, textur.width, textur.height);
    if (preview.src == "") {
    canvas.fillStyle = "blue";
    canvas.fillRect(0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  else {
    canvas.drawImage(document.getElementById('preview'), 0, 0, größeAnpassenX.value, größeAnpassenY.value);
  }
  }
  function playPauseVideo(innerHTML) {
    if (innerHTML == "play") {
      video.play();
      playVideo.innerHTML = 'pause';
    } 
    else {
      video.pause();
      playVideo.innerHTML = 'play';
    }
  }
  function modeSelected(value) {
    modeSelection.value = value;
    traditionalDescription.style.display = 'none';
    exchangeDescription.style.display = 'none';
    schiebenDescription.style.display = 'none';
    document.getElementById(value + 'Description').style.display = 'block';
    if (value == "traditional") zeigeGröße();
    if (value == "exchange") modeSettingsHeading.style.display = 'none';
    else modeSettingsHeading.style.display = 'inline';
    traditionalSettings.style.display = 'none';
    exchangeSettings.style.display = 'none';
    schiebenSettings.style.display = 'none';
    document.getElementById(value + 'Settings').style.display = 'inline';
  }
  var originalSize = {width: 0, height: 0};
  function gapSizeChanged(value) {
    gapCanvas.width = 100 + JSON.parse(tilesGap.value);
    gapCanvas.height = 100;
    var gCanvas = gapCanvas.getContext('2d');
    gCanvas.clearRect(0, 0, gCanvas.width, gCanvas.height);
    gCanvas.fillStyle = 'red';
    gCanvas.fillRect(0, 0, 50, 50);
    gCanvas.fillRect(50 + JSON.parse(tilesGap.value), 0, 50, 50);
  }
    // create the puzzle
    function create() {
    if (document.getElementById('preview').src == '' && video.src == '' && !pMediaStream) alert('Bitte laden Sie ein Bild oder ein Video bevor Sie auf diesen Button klicken um ein Puzzel zu erstellen!') 
    else if (!state.removeTile) {
      if (modeSelection.value != "traditional") shuffleStyle.value = "none";
      if (modeSelection.value == "exchange") doNotMoveTile.checked = true;
      if (screenIsMax.checked) preventAutomaticZoom.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
      positions = {right: [], wrong: []};
      if (modeSelection.value == "traditional") {
        positions.layoutOrder = new Array(anzahlX.value*anzahlY.value);
        for (var i = 0; i < positions.layoutOrder.length; i++) {
          positions.layoutOrder[i] = i;
        }
      }
      automaticTileSelectionReset.checked = true;
      removeTilesFinishedB.style.display = 'inline';
      if (modeSelection.value == "schieben") tileStatusOptions.style.display = 'inline';
      showSettings.innerHTML = "Einstellungsmöglichkeiten und Möglichkeit aufzugeben";
      imageSettings.style.display = "none";
      modeSelection.style.display = "none";
      schiebenSettings.style.display = "none";
      rotateTilesP.style.display = "none";
      missing = [];
      if (gerät == "Handy") mobileControls.style.display = "inline";
      if (sourceIsVideo.checked) {
        videoControls.style.display = 'inline';
        videoPosition.max = video.duration;
        settings.style.display = 'inline';
        videoPosition.style.width = window.innerWidth;
        while (timeText.getBoundingClientRect().x < videoPosition.getBoundingClientRect().x + convertStyle(videoPosition.style.width)) {
          videoPosition.style.width = (convertStyle(videoPosition.style.width) - 1) + 'px';
        }
        videoPosition.style.width = (convertStyle(videoPosition.style.width) - 15) + 'px';
        playVideo.style.width = playVideo.getBoundingClientRect().width;
        settings.style.display = 'none';
        if (video.srcObject) {
          for (const elm of timeChangeDiv) {
            elm.style.display = 'none';
          }
        }
      }
      originalSize.width = preview.width;
      originalSize.height = preview.height;
      preview.width = größeAnpassenX.value;
      preview.height = größeAnpassenY.value;
      textur.width = preview.width + 3*(anzahlX.value - 1) - 1// + 111;
      textur.height = preview.height + 3*(anzahlY.value - 1) - 1// + 111;
      videoPreview.width = größeAnpassenX.value;
      videoPreview.height = größeAnpassenY.value;
      var pAnzahlX = anzahlX.value;
      var pAnzahlY = anzahlY.value;
      if (sourceIsPicture.checked) lengthPerTeil = {original: {x: Math.round(originalSize.width/pAnzahlX), y: Math.round(originalSize.height/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
      else lengthPerTeil = {original: {x: Math.round(video.videoWidth/pAnzahlX), y: Math.round(video.videoHeight/pAnzahlY)}, edit: {x: Math.round(preview.width/pAnzahlX), y: Math.round(preview.height/pAnzahlY)}};
      breiteRand.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3;
      randPosition.max = ((lengthPerTeil.edit.x + lengthPerTeil.edit.y)/2)/3 - breiteRand.value;
      for (var i = 0; i < pAnzahlY; i++) {
        for (var i1 = 0; i1 < pAnzahlX; i1++) {
          if (modeSelection.value == "traditional") {
            var newTile = {original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}};
            if (i1) newTile.original.left = {x: positions.right[i*pAnzahlX + i1 - 1]?.original.x, y: positions.right[i*pAnzahlX + i1 - 1]?.original.y};
            if (i) newTile.original.top = {x: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.x, y: positions.right[i*pAnzahlX + i1 - pAnzahlX]?.original.y};
            positions.right.push(newTile);
            if (i) positions.right[i*pAnzahlX + i1 - pAnzahlX].original.bottom = {x: newTile.original.x, y: newTile.original.y};
            if (i1) positions.right[i*pAnzahlX + i1 - 1].original.right = {x: newTile.original.x, y: newTile.original.y};
          }
          else {
            positions.right.push({original: {x: lengthPerTeil.original.x*i1, y: lengthPerTeil.original.y*i, degree: 0}, edit: {x: lengthPerTeil.edit.x*i1, y: lengthPerTeil.edit.y*i, degree: 0}})
          }
          positions.right[positions.right.length - 1].border = [];
          if (i1 == 0) positions.right[positions.right.length - 1].border.push("left");
          if (i1 == pAnzahlX - 1) positions.right[positions.right.length - 1].border.push("right");
          if (i == 0) positions.right[positions.right.length - 1].border.push("top");
          if (i == pAnzahlY - 1) positions.right[positions.right.length - 1].border.push("bottom");
          positions.right[i*pAnzahlX + i1].x = i1;
          positions.right[i*pAnzahlX + i1].y = i;
        }
      }
      positions.wrong = JSON.parse(JSON.stringify(positions.right));
      for (var i = 0; i < pAnzahlY; i++) {
        for (var i1 = 0; i1 < pAnzahlX; i1++) {
          positions.wrong[i*pAnzahlX + i1].edit.x += 3*i1;
          positions.wrong[i*pAnzahlX + i1].edit.y += 3*i;
        }
      }
      //canvas.drawImage(document.getElementById('preview'), /*xFromPixture*/200, /*yFromPicture*/200, 200, 200, /*xFromPlacement*/0, /*yFromPlacement*/0, 200, 200);
      window.scroll(0, /*96 50*/32);
      if (modeSelection.value == "schieben") {
        if (!state.restorePuzzle) alert("Bitte wählen Sie ein Teilstück aus, das entfernt wird. Im besten Fall ist es ein unwichtiger Teil des Bildes!");
        state.removeTile = true;
        layout(true, false, false, true);
      }
      else removeTile(true);
      // else layout();
      if (sourceIsVideo.checked) canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
      showSettings.scrollIntoView();
      window.scroll(0, 0);
      changeSettingsVis('none');
      swipeTitle.style.display = "inline";
      swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + 20;
      swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
      swipeTitle.style.display = "none";
      modeHeadline.style.display = 'none';
      shuffleHeadline.style.display = 'none';
      texturTop = textur.getBoundingClientRect().top + scrollY;
      futurePuzzleManager.appendChild(storePuzzleManager);
    }
    autoScroll = setInterval(function () {
      if (!selected.position.manualScrolling) {
  // up
  if (!scrollable.checked && aufgebenId.style.display == "inline" && (((modeSelection.value == "traditional" && positions.wrong[selected.tiles[0]]?.edit.y + lengthPerTeil.edit.y/3 < visualViewport.pageTop + state.upScroll && selected.tiles.length) || (((modeSelection.value == "exchange" && selected.boolean.swipe) || (modeSelection.value == "schieben" && state.mouse == "down")) && mausy - scrollY < 30)))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    // window.scroll(scrollX, scrollY - 3);
    // mausy -= 3;
    fAutoScroll({x: 0, y: -3});
}
// right 
if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX + lengthPerTeil.edit.x/2 > visualViewport.pageLeft + window.visualViewport.width/* - texturLeft*/ && selected.tiles?.length) {
      // window.scroll(scrollX + 3, scrollY);
      fAutoScroll({x: 3, y: 0});
    }
if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.x + lengthPerTeil.edit.x/2 > visualViewport.pageLeft + window.visualViewport.width + state.rightScroll/* + scrollX*/) || (modeSelection.value != "traditional" && mausx + texturLeft > visualViewport.pageLeft + window.visualViewport.width  - 50))) && (modeSelection.value !=
      "traditional" || (state.mouse == "down" && modeSelection.value == "traditional")))) {
        // window.scroll(scrollX + 3, scrollY);
        // mausx += 3;
        fAutoScroll({x: 3, y: 0});
      }
      // left
      if (modeSelection.value == "traditional" && mirrorInput.checked && originalMausX - lengthPerTeil.edit?.x/2 < 0 && selected.tiles.length) {
      // window.scroll(scrollX - 3, scrollY);
      fAutoScroll({x: -3, y: 0});
    }
  if (!scrollable.checked && !mirrorInput.checked && aufgebenId.style.display == "inline" && (mausx - visualViewport.pageLeft - state.rightScroll < 50 && ((state.mouse == "down" && modeSelection.value == "traditional") || gerät == "handy"))/* || (mausy - scrollY*2 < 160 && gerät == "Handy")*/) {
    // window.scroll(scrollX - 3, scrollY);
    // mausx -= 3;
    fAutoScroll({x: -3, y: 0});
}
  }
// down
var pScrollY = scrollY;
    if (shuffleStyle.value == "listTiles") pScrollY -= tileSelectionCanvas.getBoundingClientRect().height;// lengthPerTeil.edit.y - 10;
    var ptexturTop = textur.getBoundingClientRect().top - visualViewport.offsetTop; 
    if (ptexturTop < 0) ptexturTop = 0;
    if (!scrollable.checked && aufgebenId.style.display == "inline" && ((((modeSelection.value == "traditional" && selected.tiles.length && positions.wrong[selected.tiles[0]].edit.y > visualViewport.pageTop + window.visualViewport.height + state.upScroll - ptexturTop - texturTop/* + pScrollY - texturTop*/) || (modeSelection.value != "traditional" && mausy + texturTop > visualViewport.pageTop + window.visualViewport.height  - 70))) && (selected.boolean.swipe || modeSelection.value != "exchange") && state.mouse == "down")) {
        // window.scroll(scrollX, scrollY + 3);
        // mausy += 3;
        fAutoScroll({x: 0, y: +3});
      }
}, 10);
  }
  function fAutoScroll(direction) {
    pcScrolls = true;
    if (tutorial.state == "automaticScrollingTutorial") goTutorialSteps(1);
    var scrollYBefore = scrollY;
    if (!positions.wrong[selected.tiles[0]] || positions.wrong[selected.tiles[0]].edit.y > 0) window.scrollBy(direction.x, direction.y);
    mausx += direction.x;
    mausy += direction.y;
    if (gerät == "Handy") {
      if (direction.x && (positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.x < textur.width/*state.rightScroll < textur.width - visualViewport.width*/ && direction.x > 0) || (direction.x < 0 && positions.wrong[selected.tiles[0]].edit.x > 0/*state.rightScroll > 0*/)) {
        state.rightScroll += direction.x;
        canvas.translate(-direction.x, 0);
        layout(true, true);
      }
      if (direction.y && scrollY == scrollYBefore && (positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.y < textur.height/*textur.height - visualViewport.height*/ && direction.y > 0) || (direction.y < 0 && positions.wrong[selected.tiles[0]] && positions.wrong[selected.tiles[0]].edit.y > 0)) {
        state.upScroll += direction.y;
        canvas.translate(0, -direction.y);
        layout(true, true);
        folgenMouseMove();
      }
    }
  }
  function shufflePuzzle() {
    var shuffleStyleBefore = shuffleStyle.value;
    if (emptyTileBar.checked) {
      shuffleStyle.value = shuffleStyleBar.value;
      autoSelectTileBar.checked = false;
    }
    if (modeSelection.value == "schieben" && !selected.tiles.length && !state.restorePuzzle) alert("Sie müssen mindestens ein Teil ausgeählt haben, das wegfällt, damit Sie schieben können!");
    else {
      for (var i = 0; i < anzahlY.value; i++) {
      for (var i1 = 0; i1 < anzahlX.value; i1++) {
        positions.wrong[i*anzahlX.value + i1].edit.x -= 3*i1;
        positions.wrong[i*anzahlX.value + i1].edit.y -= 3*i;
      }
    }
    textur.width -= 3*(anzahlX.value - 1);
    textur.height -= 3*(anzahlY.value - 1);
      var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
      for (var i of selected.tiles) {
        missing.push(JSON.parse(JSON.stringify(positions.wrong[i].edit.x + ' - ' + positions.wrong[i].edit.y)));
        positions.wrong.forEach((position, i1) => {
          for (var direc of ['top', 'right', 'bottom', 'left']) {
            if (positions.wrong[i].border.includes(directionConverter[direc]) && positions.wrong[i].original[direc] && !i1/* && !selected.tiles.includes(getTile(positions.wrong[i].original[direc]))*/) {
              positions.wrong[getTile(positions.wrong[i].original[direc])].border.push(directionConverter[direc]);
            }
            if (position.original[direc]) {
            position.original[direc].degree = 0;// position.edit.degree;
            if (angular.equals(position.original[direc], {x: positions.wrong[i].original.x, y: positions.wrong[i].original.y, degree: 0})) {
              delete position.original[direc].degree;
              delete positions.right[i1].original[direc];
              // delete position.original[direc];
            }
            else delete position.original[direc].degree;
          }
          }
        });
      }
      if (modeSelection.value != "exchange") {
        for (var i = 0; i < positions.wrong.length; i++) {
          if (selected.objTiles.includes(JSON.stringify(positions.wrong[i].edit))) {
            positions.wrong.splice(i, 1);
            positions.right.splice(i, 1);
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
              if (doNotChange[i1] > i) doNotChange[i1]--;
            }
            if (modeSelection.value == "traditional") {
              positions.layoutOrder.splice(i, 1);
              for (var i1 = i; i1 < positions.layoutOrder.length; i1++) {
                positions.layoutOrder[i1]--;
              }
            }
            i--;
          }
        }
      }
      selected.tiles = [];
      removeTilesFinishedB.style.display = 'none';
      state.removeTile = false;
      if (modeSelection.value == "schieben") {
        getShortestPCMovement();
      }
      else {
      if (modeSelection.value == "traditional") {
        textur.width += 500;
        textur.height += 500;
        positions.wrong.forEach((position, i) => {
          if (shuffleStyle.value != "listTiles" || emptyTileBar.checked) {
            position.edit = {x: Math.round(Math.random()*(textur.width - lengthPerTeil.edit.x)), y: Math.round(Math.random()*(textur.height - lengthPerTeil.edit.y)), degree: 0};
            if (emptyTileBar.checked) tileSelectionBar.tiles.push(i);
          }
          else {
            position.edit = {x: i*(lengthPerTeil.edit.x + 5) + lengthPerTeil.edit.x/2, y: 5 + lengthPerTeil.edit.y/2, degree: 0};
            tileSelectionBar.tiles.push(i);
          }
          position.original = {x: position.original.x, y: position.original.y, degree: [0, 90, 180, 270][Math.round(Math.random()*3)]};
          stats.minimumRotations += Math.abs(position.original.degree/90);
          if (!rotateTiles.checked) position.original.degree = 0;
      });
      if (emptyTileBar.checked) {
        state.modelEmptybar = true;
        setTimeout(function () {
          tileSelectionBar.tiles = [];
          state.modelEmptybar = false;
          layout();
        }, 100);  
      }
    }
    if (shuffleStyle.value == "nextToEachOther") {
        if (isNaN(tilesGap.value) || tilesGap.value == '') tilesGap.value = 55;
        if (isNaN(tilesXTileGap.value) || tilesXTileGap.value == '') tilesXTileGap.value = anzahlX.value;
        var pos = {x: lengthPerTeil.edit.x/2, y: lengthPerTeil.edit.y/2};
        for (let i = 0; i < positions.wrong.length; i++) {
          positions.wrong[i].edit = {x: pos.x, y: pos.y, degree: 0};
          pos.x += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
          if ((pos.x + lengthPerTeil.edit.x/2 > window.innerWidth && fillScreenTileGap.checked) || (!fillScreenTileGap.checked && pos.x > lengthPerTeil.edit.x + (lengthPerTeil.edit.x + JSON.parse(tilesGap.value))*(parseInt(tilesXTileGap.value) - 1))) {
            pos.x = lengthPerTeil.edit.x/2;
            if (pos.x + lengthPerTeil.edit.x/2 > textur.width) textur.width += lengthPerTeil.edit.x + parseInt(tilesGap.value);
            pos.y += lengthPerTeil.edit.x + JSON.parse(tilesGap.value);
            if (pos.y + lengthPerTeil.edit.y/2 > textur.height) textur.height += lengthPerTeil.edit.y + parseInt(tilesGap.value);
          }
        }
      }
      for (i = positions.wrong.length - 1; (modeSelection.value == "exchange" || shuffleStyle.value != "overlapTiles") && i > 0; i--) {
        do {
          j = Math.floor(Math.random() * (i + 1));
        } while (doNotChange.includes(j) && j != i && doNotChange.length != positions.wrong.length);
        x = positions.wrong[i].edit;
        if (!doNotChange.includes(i)) {
          positions.wrong[i].edit = positions.wrong[j].edit;
          positions.wrong[j].edit = x;
        }
      }
      stats.preOrdered = "pending";
    }
    if (shuffleStyle.value == "nextToEachOther") tilesGapS.style.display = "none";
    shuffleStyle.value = shuffleStyleBefore;
    doNotChange = [];
    aufgebenId.style.display = "inline";
  showOriginalP.style.display = 'inline';
  shuffleStyle.style.display = 'none';
  tileStatusOptions.style.display = 'none';
  shuffleStyleLable.style.display = 'none';
  if (modeSelection.value == "schieben") turnsHistoryS.style.display = 'inline';
  // expand textur buttons
  if (modeSelection.value == "traditional") { 
  textur.style.position = "absolute";
  expandBottom.style.width = textur.width + 6; 
  expandTop.style.width = textur.width + 6;  
  // expandTop.style.position = "static";  
  for (const elm of document.getElementsByClassName('expandButtons')) {
    elm.style.display = 'inline';
  }
  textur.style.top = expandTop.getBoundingClientRect().bottom + scrollY + 'px';
  texturTop = textur.getBoundingClientRect().top + scrollY;
  expandLeft.style.left = '0px';
  expandLeft.style.height = textur.height + 6;  
  expandLeft.style.top = textur.getBoundingClientRect().top + scrollY// texturTop;
  textur.style.left = expandLeft.getBoundingClientRect().right + scrollX + 'px';
  expandTop.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandBottom.style.left = textur.getBoundingClientRect().left + scrollX + 'px';
  expandRight.style.top = texturTop;
  expandRight.style.height = textur.height + 6;  
  expandRight.style.left = textur.getBoundingClientRect().right + scrollX// textur.getBoundingClientRect().x + scrollX + textur.width + 6 + 'px';
  expandBottom.style.top = textur.getBoundingClientRect().bottom + scrollY;// texturTop + scrollY + textur.height + 6 + 'px'; 
}
  texturLeft = textur.getBoundingClientRect().left + scrollX;
  if (gerät == "Handy") autoSelectTileBar.checked = false;
  tileSelectionBar.height = lengthPerTeil.edit.y + 10;
  tileBarHeight.max = window.innerHeight - texturTop - lengthPerTeil.edit.y;
  changeTileBarHeight(lengthPerTeil.edit.y + 10);
  tileSelectionCanvas.height = lengthPerTeil.edit.y + 10;
  backToBarBWidth.max = lengthPerTeil.edit.x;
  backToBarBHeight.max = lengthPerTeil.edit.y;
  backToBarBWidth.value = lengthPerTeil.edit.x/7;
  backToBarBHeight.value = lengthPerTeil.edit.y/7;
  hitboxCheckbox.style.display = "inline";
  hitboxWidth.max = lengthPerTeil.edit.x;
  hitboxWidth.value = lengthPerTeil.edit.x/4;
  hitboxHeight.max = lengthPerTeil.edit.y;
  hitboxHeight.value = lengthPerTeil.edit.y/4;
  hitboxTextur.width = lengthPerTeil.edit.x*2 + 33;
  hitboxTextur.height = lengthPerTeil.edit.y*2 + 33;
  if (gerät == "PC") automaticTileSelectionReset.checked = false;
  if (shuffleStyle.value == "listTiles") {
    selectBackToBarB.style.display = 'inline';
    listTilesS.style.display = 'inline';
    settings.style.display = 'inline';
    tileBarHeight.style.width = window.innerWidth - tileBarHeightText.getBoundingClientRect().width - resetBarSize.getBoundingClientRect().width - 100;
    settings.style.display = 'none';
  }
  else tileSelectionCanvas.style.display = "none";
  scrollTileSelectionRight.style.bottom = lengthPerTeil.edit.y/4 + "px";
  scrollTileSelectionLeft.style.bottom = lengthPerTeil.edit.y/4 + "px";
  if (gerät == "Handy") {
    scrollTileSelectionRight.style.bottom = lengthPerTeil.edit.y/2 + "px";
    scrollTileSelectionLeft.style.bottom = lengthPerTeil.edit.y/2 + "px";
    selectBackToBarB.style.fontSize = '5vh';
    // zoom out: 
    var newElm = document.createElement('meta');
      newElm.name = "viewport";
      newElm.id = "zoomLevelControler";
      newElm.content = "initial-scale=0.25";
      document.getElementsByTagName('head')[0].appendChild(newElm);
  }
  if (shuffleStyle.value == "listTiles") {
    scrollTileSelection(0);
    for (var i = 0; i < tileSelectionBar.tiles.length + 1; i++) {
      addElement({class: "backToTileB", innerText: '+', style: `width: ${backToBarBWidth.value}px; height: ${backToBarBHeight.value}; bottom: ${(lengthPerTeil.edit.y + 5)/2 - (backToBarBHeight.value)/2}px; left: ${10 + (5 + lengthPerTeil.edit.x)*(i) - (backToBarBWidth.value)/2}px`, onclick: `posInBarSelected(${i});`}, 'button', 'backToBarButtons');
    }
  }
    if (gerät == "Handy") {
    mobileControls.style.display = 'inline';
    rotateControls.style.display = "inline";
  }
  selected.boolean = {click: false, swipe: false};
  try {
  preventAutomaticZoom.content = "";
  } catch (err) {}
  window.scroll(0, 0);
  }
  adaptTitlesPosition();
  emptyTileBar.style.display = "none";
  if (modeSelection.value == "traditional") {
    traditionalModeMobileControls.style.display = 'inline';
  }
  canvas = textur.getContext('2d');
  layout(true, true);
  startPause('completionTime');
  setTimeout(() => {
    adaptMobileControlsPosition();
  }, 100);
}
// #importantUserInputs
// select tiles to remove and move tiles or exchange them depending on the mode
function canvasClicked(calledBy) {
  if (calledBy == "elm") selected.boolean.swipe = false;
  selected.tile = checkSelected();
  if (!state.removeTile && !scrollable.checked && !finished) { 
    if (aufgebenId.style.display == "inline" && settings.style.display == "inline") changeSettingsVis('none');
    if (selected.tile && (selected.boolean.click || selected.boolean.swipe) && modeSelection.value == "exchange" && !state.removeTile && selected.tile.x + "-" + selected.tile.y != selected.coord.x + "-" + selected.coord.y) {
      for (var i = 0; i < positions.wrong.length; i++) {
        if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == selected.tile.x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == selected.tile.y) {
          for (var i1 = 0; i1 < positions.wrong.length; i1++) {
            if (positions.wrong[i1].edit.x/lengthPerTeil.edit.x == selected.coord.x && positions.wrong[i1].edit.y/lengthPerTeil.edit.y == selected.coord.y) {
              console.log("vertausche " + selected.tile.x + "-" + selected.tile.y + " mit " + selected.coord.x + "-" + selected.coord.y);
              stats.turns++;
              vertauscheZwei(i, i1);
              i = positions.wrong.length;
              i1 = positions.wrong.length;
              if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
              state.exchangedTiles = true;
              setTimeout(() => {
                state.exchangedTiles = false;
              }, 500);
            }
          }
        }
      }
      selected.boolean = {click: false, swipe: false};
    }
    else if (modeSelection.value == "schieben" && selected.tile/* && selected.boolean*/ && missing.length && !state.removeTile) {
      for (var i1 = 0; i1 < missing.length; i1++) {
        pMissing = missing[i1];
        if (possibleMissing.length && pMissing == (selected.tile.x)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y) {
          moveTile(possibleMissing.filter(x => x.i1 == i1)[0].i, i1);
        }
        else {
        if ((pMissing == (selected.tile.x + 1)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y) /*right*/ || (pMissing ==(selected.tile.x - 1)*lengthPerTeil.edit.x + ' - ' + selected.tile.y*lengthPerTeil.edit.y)/*left*/ || (pMissing == selected.tile.x*lengthPerTeil.edit.x + ' - ' + (selected.tile.y + 1)*lengthPerTeil.edit.y)/*down*/ || (pMissing == (selected.tile.x*lengthPerTeil.edit.x + ' - ' + (selected.tile.y - 1)*lengthPerTeil.edit.y)/*up*/)) {
          for (var i = 0; i < positions.wrong.length; i++) {
            if (positions.wrong[i].edit.x/lengthPerTeil.edit.x == selected.tile.x && positions.wrong[i].edit.y/lengthPerTeil.edit.y == selected.tile.y) {
              possibleMissing.push({i: i, i1: i1});
            }
          }
        }
      }
  }
  if (possibleMissing.length == 1) moveTile(possibleMissing[0].i, possibleMissing[0].i1);
}
    else if (selected.tile && (modeSelection.value != "schieben"/* || missing*/) && !state.exchangedTiles) {
      selected.coord = {x: selected.tile.x, y: selected.tile.y};
      selected.boolean.click = true;
    }
  }
    selected.tile = checkSelected(true);
    if (selected.tile && ((!missing.length && modeSelection.value == "schieben") || state.removeTile) && (!lastCoord || JSON.stringify(lastCoord) != JSON.stringify(selected.tile) || (((state.mouse == "up" && calledBy != "elm") || calledBy == "mouseDown") && JSON.stringify(state.coord) == JSON.stringify(selected.tile)))) {
      removeTile(null, calledBy);
      lastCoord = selected.tile;
    }
    else {
      if (aufgebenId.style.display == "inline") layout(false, true);
    }
    selected.tile = checkSelected();
  }
  // section 2.1: movementPlayer (player of PC movement in schieben mode)
  function getShortestPCMovement(restorePuzzle) {
  if (!state.restorePuzzle && !restorePuzzle) {
    movement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
    verschiebenPC();
  }
  wrongPosition = JSON.parse(JSON.stringify(positions.wrong));
  setTimeout(function () {
    // create misstingDistinct
    distinctMoves = JSON.parse(JSON.stringify(movement.move));
    var distinctPositions = [];
    var change;
    var firstRunThrough = true;
    playerMovement = movement.move;
    do {
      change = false;
      var leftBeginning = 1;
      for (let i = 0; i < movement.move.length; i++) {
        var move = JSON.stringify(playMovementPos(i, true, true));
      if (distinctPositions.includes(move) || JSON.stringify(movement.startPosition) == move) {
        for (let i1 = leftBeginning; i1 < /*movement.move.length*/i; i1++) {
          if (JSON.stringify(playMovementPos(i1, true, true)) == move && distinctMoves[i1] != undefined && distinctMoves[i] != undefined) {
            distinctPositions.splice(i1, (i - i1));
            // distinctMoves.splice(i1, (i - i1));
            // console.log('lösche ' + i1 + ' bis ' + (i-1));
            distinctMoves.fill(undefined, i1, i);
            leftBeginning = i1 + (i - i1);
            // i1 = i1 + (i - i1);
            change = true;
            break;
          }
        }
        }
        if (firstRunThrough) distinctPositions.push(move);
      }
      firstRunThrough = false;
    } while (change)
    distinctMoves = distinctMoves.filter(x => x != undefined);
    if (distinctMoves[0] && ((Math.abs(distinctMoves[0].x) == Math.abs(distinctMoves[1].x) || Math.abs(distinctMoves[0].y) == Math.abs(distinctMoves[1].y)) && distinctMoves[0].tile == distinctMoves[1].tile)) distinctMoves.splice(0, 2);
    positions.wrong = JSON.parse(JSON.stringify(wrongPosition));
    movementStepsChanged(distinctMovement.checked);
    state.redoI1 = undefined;
  }, 500);
  movementPlayer.style.display = 'inline';
  movementPlayerTextur.width = textur.width;
  movementPlayerTextur.height = textur.height;
}
  var userMovement = {index: 0, moves: []};
  function movementStepsChanged(checked, doNotSetChecked) {
    if (!doNotSetChecked)  distinctMovement.checked = checked;
    if (checked) playerMovement = distinctMoves;
    else playerMovement = movement.move;
    movementPosition.max = playerMovement.length;
  }
  function playPauseMovement() {
    if (movementPlayButton.innerHTML == "play") {
      movementPlayButton.innerHTML = "pause";
      playMovementFunction();
    }
    else movementPlayButton.innerHTML = "play";
  }
  var playerMovement = [];
  function playMovementFunction() {
    if (movementPlayButton.innerHTML == "pause") {
      if (JSON.parse(movementPosition.value) < playerMovement.length || JSON.parse(movementPosition.value) + objMovementPlayer.direc < 0) playMovementPos(JSON.parse(movementPosition.value) + objMovementPlayer.direc);
      else movementPlayButton.innerHTML = "play";
      setTimeout(function () {
        playMovementFunction();
      }, JSON.parse(movementPlayerSpeed.value));
    }
  }
  var objMovementPlayer = {pause: false, position: 0, direc: 1};
  function getPlayerPosition(backToBeginningIfNeeded, easySteps) {
    for (let i = 0; i < playerMovement.length; i++) {
      if (JSON.stringify(playMovementPos(i, true, true)) == JSON.stringify(movement.playerPosition)) {
        return i;
      }
    }
    if (easySteps != undefined) {
      movementStepsChanged(easySteps);
    }
    else {
      movementStepsChanged(false, true);
      getPlayerPosition(false, distinctMovement.checked);
    }
    if (backToBeginningIfNeeded) return 0;
    else return JSON.parse(movementPosition.value);
  }
  var wrongPosition;
  function playMovementPos(position, pReturn, doNotChangeVal, pPlayerMovement) {
    var isUserMovement = pPlayerMovement != undefined;
    if (!pPlayerMovement) pPlayerMovement = playerMovement;
    else {
      if (goBackAsTurns.checked) stats.turns += Math.abs(position - playerMovementSlider.value);
      playerMovementSlider.value = position;
      state.changedPos = true;
      userMovement.index = position;
      setTimeout(() => {
        movement.playerPosition = positions.wrong;
        storePuzzle();
      }, 100);
    }
    if (position < 0) position = 0;
    if (position > pPlayerMovement.length) position = pPlayerMovement.length;
    if (!doNotChangeVal) movementPosition.value = position;
    if (!isUserMovement) positions.wrong = JSON.parse(JSON.stringify(movement.startPosition));
    else positions.wrong = JSON.parse(JSON.stringify(userMovement.startPosition));
    for (let i = pPlayerMovement.length - 1; i >= position; i--) {
      if (isUserMovement) missing[pPlayerMovement[i].i1] = positions.wrong[pPlayerMovement[i].tile].edit.x + ' - ' + positions.wrong[pPlayerMovement[i].tile].edit.y;
      positions.wrong[pPlayerMovement[i].tile].edit.x += pPlayerMovement[i].x;
      positions.wrong[pPlayerMovement[i].tile].edit.y += pPlayerMovement[i].y;
    }
    if (pReturn) return positions.wrong;
    // PC movement player
    if (!isUserMovement) {
      canvas = movementPlayerTextur.getContext('2d');
      objMovementPlayer.position = JSON.parse(position);
    }
    layout(true, true);
  }
  // end section 2.1
    // backTobar button clicked
    function posInBarSelected(i) {
      if (tutorial.state == "BackToTileBarTutorial") goTutorialSteps(1);
    for (const elm of document.getElementsByClassName('backToTileB')) {
      elm.style.backgroundColor = '';
    }
    if (tileSelectionBar.tiles.length != positions.wrong.length) {
      state.backToBar = i; 
      document.getElementsByClassName('backToTileB')[i].style.backgroundColor = 'red';
    }
    tileSelectionBar.selectedTile = undefined;
    layout();
  }
  // section 2.2: handle input data (picture, video, URL)
  // load selected file
  function readImg(input) {
    var cancelLoading = false;
    sourceCheckboxes.style.display = 'none';
    var reader = new FileReader();
    stopLiveFeed();
    if (!state.restorePuzzle || state.restorePuzzle.fileName == input.files[0].name || confirm("Sie haben wohl das falsche Puzzle ausgewählt. Wenn Sie trotzdem fortfahren wollen, klicken Sie auf OK o.ä. (andernfalls klicken Sie auf abbrechen o.ä. und erneut auf den Namen des Bildes, um das rictige Bild auszuwählen. )")) {
      reader.onload = function (e) {
        if (sourceIsPicture.checked) document.getElementById('preview').setAttribute("src", e.target.result);
        else {
          video.setAttribute("src", e.target.result);
          setTimeout(function () {
            loadImage(video.videoWidth, video.videoHeight);
          }, 1000);
        }
      };
    }
      else if (state.restorePuzzle) {
        cancelLoading = true;
      }
    reader.readAsDataURL(input.files[0]);
    if (input.files[0].type.includes('video')) sourceIsVideo.checked = true;
    else sourceIsPicture.checked = true;
    for (const puzzle of Object.keys(puzzles)) {
      if (!state.restorePuzzle && puzzles[puzzle].fileName == input.files[0].name && confirm('Sie haben bereits ein Puzzle mit dieser Datei im Modus "' + puzzles[puzzle].mode + '" begonnen! Sie haben es unter dem Namen "' + puzzle + '" gespeichert. Wollen Sie dieses laden?')) {
        restorePuzzleSource(puzzle, true);
        break;
      }
    }
    if (!cancelLoading && sourceIsPicture.checked) loadImage();
    fileName = input.files[0].name;
  }
  var fileName;
  var video = document.createElement("video");
  function useURL() {
    useURLCheck.checked = true;
    sourceCheckboxes.style.display = 'none';
    if (sourceURL.value.includes('.mp4') || sourceURL.value.includes('.move')) sourceIsVideo.checked = true;
    else if (sourceURL.value.includes('.png') || sourceURL.value.includes('.jpg') || sourceURL.value.includes('.jpeg')) sourceIsPicture.checked = true;
    else {
     document.getElementById('sourceIs' + state.userSource).checked = true;
     sourceCheckboxes.style.display = 'block';
  }
    stopLiveFeed();
    for (const puzzle of Object.keys(puzzles)) {
      if (!state.restorePuzzle && sourceURL.value == puzzles[puzzle].URL && confirm('Sie haben bereits ein Puzzle mit diesem Link/dieser URL im Modus "' + puzzles[puzzle].mode + '" begonnen! Sie haben es unter dem Namen "' + puzzle + '" gespeichert. Wollen Sie dieses laden?')) {
        restorePuzzleSource(puzzle, true);
        break;
      }
    }
    if (sourceIsPicture.checked) {
    preview.src = sourceURL.value;
    loadImage();
  }
  else {
    video.src = sourceURL.value;
  }
  }
  function startVideo() {
    video.play();  // start playing
    updateVideo(); //Start rendering
  }
  video.addEventListener('loadeddata', function() {
    startVideo();
    loadImage(video.videoWidth, video.videoHeight);
  }, false);
  var originalSize = {};
  function loadImage(width, height) {
    setTimeout(function () {
      URLInfo.style.display = 'none';
      // videoPosition.style.width = window.innerWidth - 33 - timeText.getBoundingClientRect().width - 126.234375*2;
      if (!width) {
        width = preview.width;
        height = preview.height;
      }
      originalSize = {width: width, height: height};
      try {
        canvas.drawImage(document.getElementById('preview'), 0, 0);
      } catch (err) {
        URLInfo.style.display = 'block';
      }
      if (aufgebenId.style.display != "inline") {
        changeAdaptedSizeMax(width, height);
        zuAngepassterBildschirmgröße();
      } 
       if (state.restorePuzzle) {
        größeAnpassenX.max =  state.restorePuzzle.width;
        größeAnpassenY.max =  state.restorePuzzle.height;
        größeAnpassenX.value = state.restorePuzzle.width;
        größeAnpassenY.value = state.restorePuzzle.height;
        if (state.restorePuzzle.tileBarTiles) shuffleStyle.value = "listTiles";
        else shuffleStyle.value = "nextToEachOther";
        create();
        shufflePuzzle();
        restorePuzzle(state.restorePuzzle);
        delete state.restorePuzzle;
       }
    }, 500);
  }
  // end section 2
  // section 3: handle videos

  // returns string with UI time
// @param: pTime: total time in seconds
function getTimeString(pTime) {
  pTime = Math.floor(pTime);
  var sec, mins, hours;
  hours = Math.floor(pTime / 60 / 60);
  mins = Math.floor(pTime / 60) - hours*60;
  sec = pTime - mins*60 - hours*60*60;
  if (sec < 10) sec = '0' + sec; 
  if (mins < 10) mins = '0' + mins; 
  if (hours < 10) hours = '0' + hours;
  return `${hours}:${mins}:${sec}`;
}
// converts time string back into time in seconds
// @param: 
  // value: String with UI time layout
  // id: undefined or loopEnding (value then is time stamp of loop ending)
  function convertTime(value, id){
  var time = 0;
  var sec = value.split(':')[2];
  var mins = value.split(':')[1];
  var hours = value.split(':')[0];
  if (sec < 10) sec = sec[1];
  if (mins < 10) mins = mins[1];
  if (hours < 10) hours = hours[1];
  if (value.split(':')[3]) time += parseInt(value.split(':')[3])/100;
    try {
      time += JSON.parse(sec);
      time += JSON.parse(mins)*60;
      time += JSON.parse(hours)*60*60;
      if (time > video.duration || time < 0) console.log(abc);
    }
    catch (e) {
      if (id == 'loopEnding') time = video.duration;
      else time = 0;
    }
  return time;
}
// draw changes in the video on the canvas and changes the current position in the video
function updateVideo(){
    videoPosition.value = video.currentTime;
    timeText.innerHTML = getTimeString(video.currentTime) + ' / ' + getTimeString(video.duration);
    canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
    if (aufgebenId.style.display == "inline") {
      for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
        var i = i1;
        if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
        if (shuffleStyle.value == "listTiles" && tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], false, i, tileSelectionBar.canvas);
        else drawPictureSegment(positions.wrong[i], positions.right[i], false, i);
      }
    }
    else  if (state.removeTile) {
      for (let i = 0; i < anzahlX.value; i++) {
        for (let i1 = 0; i1 < anzahlY.value; i1++) {
          canvas.drawImage(video, positions.wrong[i1*anzahlX.value + i].original.x, positions.wrong[i1*anzahlX.value + i].original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, i*lengthPerTeil.edit.x + 3*i, i1*lengthPerTeil.edit.y + 3*i1, lengthPerTeil.edit.x, lengthPerTeil.edit.y);
        }
      }
    }
    else {
      canvas.drawImage(video,0,0, größeAnpassenX.value, größeAnpassenY.value);
    }
    videoPreview.getContext('2d').drawImage(video, 0, 0, größeAnpassenX.value, größeAnpassenY.value);
    showSelected();
    showClippingOptions();
    if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')  && loop.checked) {
      video.currentTime = convertTime(loopBeginning.value);
      if (loopEnding.value > loopBeginning.value || loopEnding.value == "" || loopBeginning.value == "") video.play();
    }
    else if (video.currentTime >= convertTime(loopEnding.value, 'loopEnding')) {
      if (stopAtEnd.checked) playPauseVideo('pause');
      else if(video.currentTime >= video.duration) playVideo.innerHTML = 'play';
    }
    if (sourceIsVideo.checked) requestAnimationFrame(updateVideo); // wait for the browser to be ready to present another animation fram.
    else video.pause();
}
// section 3.1: live camera
// Prefer camera resolution nearest to 1280x720.
var constraints = { /*audio: true, */video: { width: 1280, height: 720 } };
var pMediaStream;
// stop live feed, so another one can start
function stopLiveFeed() {
  if (pMediaStream) {
    pMediaStream.getTracks().forEach(track => {
      track.stop();
    });
    video.srcObject = undefined;
  }
  // pMediaStream = undefined;
}
// changes camera source
async function changeCamera(index) {
  for (const puzzle of Object.keys(puzzles)) {
    if (!state.restorePuzzle && index == puzzles[puzzle].liveCam && confirm('Sie haben bereits ein Puzzle mit dieser Kamera im Modus "' + puzzles[puzzle].mode + '" begonnen! Sie haben es unter dem Namen "' + puzzle + '" gespeichert. Wollen Sie dieses laden?')) {
      restorePuzzleSource(puzzle, true);
      break;
    }
  }
  sourceCheckboxes.style.display = 'none';
  sourceIsVideo.checked = true;
  stopLiveFeed();
  var Test = await navigator.mediaDevices.enumerateDevices();
  constraints.video.deviceId = Test[index].deviceId;
  navigator.mediaDevices.getUserMedia(constraints)
  .then(function(mediaStream) {
    video.srcObject = mediaStream;
    pMediaStream = mediaStream;
  })
}

// gets available cameras
navigator.mediaDevices.enumerateDevices()
.then(function(devices) {
  var option = 0;
  devices.forEach( (device, i) => {
    console.log(device.kind + ": " + device.label + " id = " + device.deviceId);
    if (device.kind == "videoinput") {
      option++;
      opt = document.createElement("option");
      opt.text = device.label;
      if (opt.text == "") opt.text = "option " + option;
      opt.value = i;
      document.getElementById("cameraSelection").options.add(opt);
    }
  });
  if (cameraSelection.options.length < 2) cameraSelection.style.display = 'none';
  if (!cameraSelection.options.length) useLiveCam.style.display = 'none';
})
// end section 3
var puzzles = {};
  getPuzzles();
  function getPuzzles() {
    while (puzzleSelection.getElementsByTagName('li').length) {
      puzzleSelection.getElementsByTagName('li')[0].remove();
    }
    puzzles = JSON.parse(localStorage.getItem('puzzleCreatorPuzzles'));
    if (!puzzles) puzzles = {};
    for (const puzzle of Object.keys(puzzles)) {
      var option = document.createElement('li');
      option.innerHTML = puzzle;
      option.value = puzzle;
      option.id = 'select ' + puzzle;
      option.onclick = () => {
        selected.puzzle = puzzle;
        if (editPuzzleManager.style.display == "none") editPuzzleManager.style.display = "inline";
        else editPuzzleManager.style.display = "none";
        editPuzzleManager.style.top = document.getElementById('select ' + puzzle).getBoundingClientRect().bottom;
      };
      puzzleSelection.appendChild(option);
    }
  }
  function restorePuzzleSource(name, sourceLoaded) {
    var puzzle = puzzles[name];
    state.restorePuzzle = true;
    anzahlX.value = puzzle.tileAmount.x;
    anzahlY.value = puzzle.tileAmount.y;
    modeSelected(puzzle.mode);
    if (!sourceLoaded) {
      if (puzzle.fileName) {
        fileB.click();
        alert('Bitte wählen Sie die von Ihnen genutzte Datei mit dem Namen "' + puzzle.fileName + '" aus.');
      }
      if (puzzle.URL) {
        sourceURL.value = puzzle.URL;
        useURL();
      }
      if (puzzle.liveCam) {
        cameraSelection.value = puzzle.liveCam;
        changeCamera(puzzle.liveCam);
      }
    }
    state.restorePuzzle = puzzle;
    puzzleName.value = name;
    doStorePuzzle.checked = true;
  }
  function restorePuzzle(puzzle) {
    setTimeout(() => {
        positions = puzzle.positions;
        stats = puzzle.stats;
        if (sourceIsVideo.checked) {
          loopBeginning.value = puzzle.loopBeginning;
          loopEnding.value = puzzle.loopEnding;
          video.currentTime = convertTime(loopBeginning.value);
        } 
        if (puzzle.mode == "schieben") {
          movement = puzzle.movement;
          missing = puzzle.missing;
          getShortestPCMovement(true);
          movement.playerPosition = positions.wrong;
          userMovement = puzzle.userMovement;
          userMovement.index++;
          playerMovementSlider.max = userMovement.moves.length;
          playerMovementSlider.value = userMovement.index + 1;
          playMovementPos(puzzle.movementPlayerPosition, null, null, userMovement.moves);
        }
        if (puzzle.mode == "traditional") {
          rotateTiles.checked = puzzle.settings.rotateTiles;
          if (puzzle.tileBarTiles) tileSelectionBar.tiles = puzzle.tileBarTiles;
          mirrorInput.checked = puzzle.settings.mirrorInput;
          mirrorCanvas(mirrorInput.checked);
          restoreClipped();
        while (positions.wrong.filter(x => x.edit.x < -lengthPerTeil.edit.x/2).length) {
          expandSide('left');
        }
        while (positions.wrong.filter(x => x.edit.x > textur.width + lengthPerTeil.edit.x/2).length) {
          expandSide('right');
        }
        while (positions.wrong.filter(x => x.edit.y < -lengthPerTeil.edit.y/2).length) {
          expandSide('top');
        }
        while (positions.wrong.filter(x => x.edit.y > textur.height + lengthPerTeil.edit.y/2).length) {
          expandSide('bottom');
        }
      }
      layout(true, true);
    }, 500);
    stopClock.completionTime.time = puzzle.completionTime;
    stopClock.viewOriginal.time = puzzle.viewOriginalTime;
  }
  function restoreClipped() {
    for (let i = 0; i < positions.wrong.length; i++) {
      getConnectedTiles(i, true, null, true);
    }
  }
  // scroll TileSelectionBar (translate)
  function scrollTileSelection(direc, calledBy) {
    if (tutorial.state == "scrollArrowTileBarTutorial" && calledBy == "elm") goTutorialSteps(1);
    if (tutorial.state == "ScrollkeyTileBarTutorial" && calledBy == "arrowKey") goTutorialSteps(1);
    var screenScrollX = window.visualViewport.width/lengthPerTeil.sizeAdapted.x*lengthPerTeil.edit.x;
    if (screenScrollX/lengthPerTeil.edit.x > positions.wrong.length) screenScrollX = positions.wrong.length*lengthPerTeil.edit.x;
    tileSelectionBar.leftOffScreenTiles += direc;
    var scrollXBefore = tileSelectionBar.scrollX;
    tileSelectionBar.scrollX += (lengthPerTeil.edit.x + 5)*(direc*(-1));
    if (tileSelectionBar.scrollX >= lengthPerTeil.edit.x + 5) {
      tileSelectionBar.offset = 0;
      tileSelectionBar.scrollX = lengthPerTeil.edit.x + 5;
      tileSelectionBar.leftOffScreenTiles = -1;
    }
    if (tileSelectionBar.scrollX >= 0) scrollTileSelectionLeft.style.display = 'none';
    else scrollTileSelectionLeft.style.display = 'inline';
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX) {
      if (!tileSelectionBar.offset) {
        tileSelectionBar.offset = - (scrollXBefore - (-((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX));
        tileSelectionBar.elmleftBefore = document.getElementsByClassName('backToTileB')[0].style.left;
      }
      tileSelectionBar.scrollX = -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length + 1)) + screenScrollX + 1;
      tileSelectionBar.leftOffScreenTiles = tileSelectionBar.tiles.length - Math.ceil(screenScrollX/lengthPerTeil.sizeAdapted.x) + 1;
    }
    if (tileSelectionBar.scrollX <= -((lengthPerTeil.edit.x + 5)*(tileSelectionBar.tiles.length)) + screenScrollX) scrollTileSelectionRight.style.display = 'none';
    else scrollTileSelectionRight.style.display = 'inline';
    layout(true, true);
    positionBackToTileBarButtons();
  }
  var tileSelectionBar = {canvas: tileSelectionCanvas.getContext('2d'), tiles: [], scrollX: 0, height: 0, leftOffScreenTiles: 0, offset: 0};
  tileSelectionBar.collidesMouse = () => {
    var obj = tileSelectionCanvas.getBoundingClientRect();
    return collides({x: mausx, y: mausy - scrollY + texturTop, width: 1, height: 1}, obj).boolean;
  }
  tileSelectionBar.getTilePosition = (generalPosition) => {
    for (const tile of tileSelectionBar.tiles) {
      if (tile == generalPosition) return tile;
    }
  }
  // get amount of tiles on x and y-axis to equal width and height
  function getSizeTileAmoutAdaption() {
    for (let i = 0; i < 1000; i++) {
      for (let i1 = 0; i1 < 1000; i1++) {
        if (i > 1 && i1 > 1 && !Math.abs(Math.abs(Math.round(größeAnpassenX.value/i)) - Math.abs(Math.round(größeAnpassenY.value/i1))) && i*i1 > minTileAmount.value) {
          return {x: i, y: i1};
        }
      }
    }
  }
  // adapt amount of tiles on x and y-axis to equal width and height
  function adaptTileAmount(adaptionStyleChanged) {
    if (modeSelection.value == 'traditional' && rotateTiles.checked) {
      var data = getSizeTileAmoutAdaption();
      if (data) {
        anzahlX.value = data.x;
        anzahlY.value = data.y;
      }
    }
  }
  function addElement(attr, elm, childOf, asElement) {
      var newElement = document.createElement(/*'span'*/elm);
      if (childOf && !asElement) document.getElementById(childOf).appendChild(newElement);
      else if (childOf) childOf.appendChild(newElement);
      else tests.appendChild(newElement);
      for (attrNow of Object.keys(attr)) {
        if (attrNow == 'innerText') newElement.innerText = attr[attrNow];
        else newElement.setAttribute(attrNow/*'style'*/, /*'color:' + word[i].colour*/attr[attrNow]);
      }
    }
  var lengthPerTeil = {};
  var positions = {right: [], wrong: []};
  var finished = false;
  var missing = [];
  var distinctMoves = [];
  function convertDirection(direc, degr) {
    var directions = ['top', 'right', 'bottom', 'left'];
    var direcObj = {top: 0, right: 1, bottom: 2, left: 3};
    while (degr > 0) {
      direc = directions[direcObj[direc] - 1];
      if (!direc) direc = directions[0];
      degr -= 90;
    }
    return direc;
  }
  // section 4: layout
  function showSelectedTile(tile, color) {
    canvas.fillStyle = color;
    canvas.save();
    if (state.removeTile/* && modeSelection.value != "schieben"*/) canvas.translate(positions.wrong[tile].edit.x + lengthPerTeil.edit.x/2, positions.wrong[tile].edit.y + lengthPerTeil.edit.y/2);
    else canvas.translate(positions.wrong[tile].edit.x, positions.wrong[tile].edit.y);
    canvas.rotate(positions.wrong[tile].original.degree*Math.PI/180);
    canvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    canvas.restore();
  }
  function showSelected() {
    for (var tile of selected.tiles) {
      showSelectedTile(tile, "rgba(255, 0, 0, 0.3)");
    }
    for (var tile of doNotChange) {
      showSelectedTile(tile, "rgba(0, 76, 255, 0.3)");
    }
  }
  function showClippingOptions() {
    for (var clip of selected.clip) {
      pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
      if ([90, 270].includes(positions.wrong[clip.sI].original.degree)) {
        pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
        pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
      }
      canvas.fillStyle = "rgba(6, 143, 255, 0.82)";
      if (markWrong.checked && (JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) canvas.fillStyle = 'rgba(255, 0, 0, 0.83)';
      canvas.save();
      canvas.translate(clip.x, clip.y);
      // canvas.rotate((positions.wrong[clip.sI].original.degree + 180)*Math.PI/180);
      if (!tileSelectionBar.tiles.includes(clip.i)) canvas.fillRect(-((pLengthPerTeil.edit.x)/2), -((pLengthPerTeil.edit.y)/2), clip.width, clip.height);
      canvas.restore();
    }
  }
  function layout(withoutAlert, clear, pReturn, removeTilesScreen) {
    if (state.removeTile) removeTilesScreen = true;
    if (clear && (aufgebenId.style.display == 'inline' || state.removeTile)) canvas.clearRect(-window.innerWidth, -window.innerHeight, textur.width + window.innerWidth*2, textur.height + window.innerHeight*2);
    if (lengthPerTeil.sizeAdapted) tileSelectionCanvas.width = positions.wrong.length*(lengthPerTeil.edit.x*(lengthPerTeil.edit.x/lengthPerTeil.sizeAdapted.x));
    else if (positions.wrong.length) tileSelectionCanvas.width = positions.wrong.length*lengthPerTeil.edit.x;
    if (lengthPerTeil.sizeAdapted && (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*tileSelectionBar.tiles.length < window.innerWidth) tileSelectionBar.scrollX = 0;
    richtige = 0;
    for (var i1 = 0; i1 < positions.wrong?.length; i1++) {
      var i = i1;
      if (modeSelection.value == "traditional" && !state.removeTile) i = positions.layoutOrder[i1];
      if (!tileSelectionBar.tiles.includes(i)) drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i);
    }
    for (var i1 = 0; i1 < tileSelectionBar.tiles.length; i1++) {
      var i = tileSelectionBar.tiles[i1];
      drawPictureSegment(positions.wrong[i], positions.right[i], removeTilesScreen, i, tileSelectionBar.canvas, i1);
    }
    showClippingOptions();
    showSelected();
    if (stats.highestRight.right < richtige && !withoutAlert) {
      stats.highestRight = {right: richtige, turns: stats.turns};
    }
    if (stats.preOrdered == "pending") stats.preOrdered = richtige;
    if (richtige == positions.wrong?.length && !removeTilesScreen && !finished && !state.restorePuzzle) {
      if (doStorePuzzle.checked && settings.style.display != "inline") {
        delete puzzles[puzzleName.value];
        localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
      }
      stopClock.completionTime.running = 0;
      richtige = 0;
      if(!withoutAlert) {
        if (tutorial.state == "completePuzzleTutorial") goTutorialSteps(1);
        selected.tiles = [];
        finished = true;
        if (pReturn) return "noChange!";
        if (modeSelection.value == "schieben") alert("Sie haben es in " + stats.turns + " Zügen (man hätte es in " + distinctMoves.length + " Zügen oder weniger schaffen können) und insgesamt " + stats.completionTime + " Minuten geschafft! Zum Umschieben vom Originalbild hat der Computer " + movement.move.length + " Züge benötigt, um es zu zerwuseln. Ob Sie darauf jetzt stolz sein können, müssen Sie selber entscheiden ;)");
        if (modeSelection.value == "exchange") alert(`Sie haben es in ${stats.turns} Zügen und insgesamt ${stats.completionTime} Minuten geschafft! (Sie hätten es in ${positions.wrong.length - stats.preOrdered} Zügen schaffen können.) Dabei haben Sie von Anfang an von den insgesamt ${positions.wrong.length} Teilen ${stats.preOrdered} Teile an der richtigen Position gehabt.`);
        if (modeSelection.value == "traditional") alert(`Super! Sie haben das Puzzle in ${stats.completionTime} Minuten geschafft! Sie haben ${stats.turns} Mal Teile verbunden (man schafft es mit mindestens ${anzahlX.value*anzahlY.value - 1} Malen) und ${stats.unclipped} Mal welche wieder auseinandergezogen. Dabei haben Sie ${stats.wrongClipped} Mal Teile falsch verbunden. Außerdem haben Sie insgesamt ${stats.rotated} Mal ein Teil gedreht. Man hätte es mit mindestens ${stats.minimumRotations} Mal drehen schaffen können. `);
        alert(`Zudem haben Sie ${stats.viewOriginal.times} Mal für insgesamt ${stats.viewOriginal.time} Minuten auf das Originalbild geguckt.`.replace('undefined', '0'));
        if (reloadWhenFinished.checked) {
          setTimeout(function () {
            window.location.reload(false);
          }, 3000);
        }
        else alert("Bitte laden Sie die Seite neu, wenn Sie ein weiteres Puzzle erstellen wollen!");
        layout(true);
    }
  }
}
  var richtige = 0;
  function drawPictureSegment(position, segmentPosition, removeTilesScreen, i, pCanvas, i1) {
    if (i1 == undefined) i1 = tileSelectionBar.getTilePosition(i);
    if (!pCanvas) pCanvas = canvas;
    else if (!state.modelEmptybar) {
      position.edit = {x: 5 + (lengthPerTeil.edit.x + 5)*i1 + lengthPerTeil.edit.x/2,y: 5 + lengthPerTeil.edit.y/2, degree: 0};
    }
    pCanvas.save();
    if (modeSelection.value == "traditional" && !removeTilesScreen) pCanvas.translate(position.edit.x, position.edit.y);
    else pCanvas.translate(position.edit.x + lengthPerTeil.edit.x/2, position.edit.y + lengthPerTeil.edit.y/2);
    if (pCanvas.canvas.id == "tileSelectionCanvas") {
      pCanvas.translate(tileSelectionBar.scrollX, 0);
      tileSelectionBar.canvas.fillStyle = "red";
      if (tileSelectionBar.selectedTile?.tileI == i) tileSelectionBar.canvas.fillRect(-(lengthPerTeil.edit.x/2) - 5, -(lengthPerTeil.edit.y/2) - 5, lengthPerTeil.edit.x + 10, lengthPerTeil.edit.y + 10);
    }
    pCanvas.rotate(position.original.degree*Math.PI/180);
    if (sourceIsPicture.checked) pCanvas.drawImage(document.getElementById('preview'), /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    else pCanvas.drawImage(video, /*xFromPixture*/segmentPosition.original.x, /*yFromPicture*/segmentPosition.original.y, lengthPerTeil.original.x, lengthPerTeil.original.y, /*xFromPlacement*/-(lengthPerTeil.edit.x/2), /*yFromPlacement*/-(lengthPerTeil.edit.y/2), lengthPerTeil.edit.x, lengthPerTeil.edit.y);
    // pCanvas.restore();
    if ((((modeSelection.value != "traditional" && position.edit.x == segmentPosition.edit.x && position.edit.y == segmentPosition.edit.y) || (modeSelection.value == "traditional" && angular.equals(position.original, segmentPosition.original) && connectedTilesRotationRight(position.original))) && !removeTilesScreen && !state.removeTile && !finished)) {
      pCanvas.fillStyle = "rgba(0, 255, 0, " + rightMarkerTransparence.value + ")";
      if (richtigPlazierte.checked) {
        pCanvas.fillRect(-(lengthPerTeil.edit.x*rightMarkerRadius.value)/2, -(lengthPerTeil.edit.y*rightMarkerRadius.value)/2, lengthPerTeil.edit.x*rightMarkerRadius.value, lengthPerTeil.edit.y*rightMarkerRadius.value);
      }
      richtige++;
    }
    pCanvas.restore();
    pCanvas.fillStyle = "rgba(0, 0, 255, 0.35)";
    if (raender.checked) {
      pCanvas.save();
      if (modeSelection.value == "traditional" && !state.removeTile) pCanvas.translate(position.edit.x, position.edit.y);
      else pCanvas.translate(position.edit.x + (lengthPerTeil.edit.x)/2, position.edit.y + (lengthPerTeil.edit.y)/2);
      pCanvas.rotate((position.original.degree)*Math.PI/180);
      if (position.border.includes("right")) pCanvas.fillRect((lengthPerTeil.edit.x)/2 - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("left")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2) + JSON.parse(randPosition.value), -((lengthPerTeil.edit.y)/2), JSON.parse(breiteRand.value), lengthPerTeil.edit.y);
      if (position.border.includes("top")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), -((lengthPerTeil.edit.y)/2) + JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      if (position.border.includes("bottom")) pCanvas.fillRect(-((lengthPerTeil.edit.x)/2), ((lengthPerTeil.edit.y)/2) - JSON.parse(breiteRand.value) - JSON.parse(randPosition.value), lengthPerTeil.edit.x, JSON.parse(breiteRand.value));
      pCanvas.restore();
    }
  }
  // end section 4
  function connectedTilesRotationRight(positionOriginal) {
    for (const direc of ['right', 'bottom', 'left', 'top']) {
      if (positionOriginal[direc]) {
        var connectedTile = getTile(positionOriginal[direc]);
        if (connectedTile != undefined && positions.wrong[connectedTile].original.degree) return false;
      }
    }
    return true;
  }
  var selected = {boolean: false, position: {x: 0, y: 0}, tiles: [], objTiles: [], clip: []};
  var lastCoord;
  function moveTile(i, i1) {
    console.log("schiebe...");
    possibleMissing = [];
    pMissing = missing[i1];
    stats.turns++;
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i]));
    if (userMovement.index < userMovement.moves.length - 1) {
      userMovement.moves.splice(userMovement.index, userMovement.moves.length - userMovement.index);
    }
    userMovement.moves.push({x: -(JSON.parse(pMissing.split(' - ')[0]) - positions.wrong[i].edit.x), y: -(JSON.parse(pMissing.split(' - ')[1]) - positions.wrong[i].edit.y), tile: i, i1: i1});
    userMovement.index++;
    playerMovementSlider.max = userMovement.moves.length;
    playerMovementSlider.value = userMovement.index + 1;
    positions.wrong[i].edit = {x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0};//.splice(side, 1);
    missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
    selected.boolean = false;
    movement.playerPosition = positions.wrong;
    userMovement.startPosition = JSON.parse(JSON.stringify(positions.wrong));
    if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
  }
  var doNotChange = [];
  var possibleMissing = [];
  // select tiles to be removed or ignored
  function removeTile(first, calledBy) {
    if (!first && (!state.tileRemoved || calledBy == "touchmove" || calledBy == "mousemove")) {
      state.tileRemoved = true;
      setTimeout(function () {
        state.tileRemoved = false;
      }, 133);
    positions.wrong.forEach((position, i) => {
      if (position.x == checkSelected(true).x && position.y == checkSelected(true).y/*position.edit.x/lengthPerTeil.edit.x == checkSelected().x && position.edit.y/lengthPerTeil.edit.y == checkSelected().y*/) {
        if (pRemoveTile.checked && !selected.tiles.includes(i)) {
          selected.tiles.push(i);
          doNotChange = doNotChange.filter(x => x != i);
          selected.objTiles.push(JSON.stringify({x: position.edit.x - 3*position.x, y: position.edit.y - 3*position.y, degree: 0}));
        }
        else if (doNotMoveTile.checked && !doNotChange.includes(i)) {
          doNotChange.push(i);
          selected.tiles = selected.tiles.filter(x => x != i);
        }
        else if (pRemoveTile.checked && selected.tiles.includes(i)) {
          for (var i1 = 0; i1 < selected.tiles.length; i1++) {
            if (selected.tiles[i1] == i) {
              selected.tiles.splice(i1, 1);
              selected.objTiles.splice(i1, 1);
              }
            }
          }
          else if (doNotMoveTile.checked && doNotChange.includes(i)) {
            for (var i1 = 0; i1 < doNotChange.length; i1++) {
            if (doNotChange[i1] == i) {
              doNotChange.splice(i1, 1);
              }
            }
          }
        }
    });
  }
  if (first && modeSelection.value != "schieben" && !state.restorePuzzle && tutorial.state == "") alert("Hier können Sie nun auf die Teile klicken, die Sie nicht im Puzzle haben wollen! Sie können gedrückt halten, um mehrere gleichzeitig anzuwählen!");
    layout(true, true, undefined, true);
    state.removeTile = true;
  }
  // lists coordinates of all entered tiles
  function listCoordinates(tiles) {
    var list = [];
    for (const tile of tiles) {
      list.push(positions.wrong[tile].edit.x + ' - ' + positions.wrong[tile].edit.y);
    }
    return list;
  }
  // PC moving the tiles in schieben mode
  function verschiebenPC() {
    var missingArray = [];
    var workingNumbers = [];
    var maleZurrück = {number: 0, normalSlide: 0};
    for (var i = 0; i < positions.wrong.length; i++) {
      if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i);
    }
    var counter = 0;
    for (var i = 0; (i < /*positions.wrong.length + */JSON.parse(anzahlVerschieben.value) || (richtigeCheck.checked && richtige > anzahlRichtige.value)) && (!zurrückVermeiden.checked || counter < 100000 || counter < anzahlVerschieben.value); i++) {
      var side = workingNumbers[Math.round(Math.random()*(workingNumbers.length - 1))];
      if (!workingNumbers.length) break;
      missing.forEach((pMissing, i1) => {
      try {
      if (!listCoordinates(doNotChange).includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y) && (((zurrückVermeiden.checked && ((missingArray.length < 1 || workingNumbers.length == 0/*positions.wrong[side].edit.x != missingBefore.data.edit.x && positions.wrong[side].edit.y != missingBefore.data.edit.y*/) || ((maleZurrück.number < anzahlVerboten.value && !((maleZurrück.normalSlide/5 + "").includes("."))) || !(missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y)/*missingBefore.data.edit.x != missing.data.edit.x && missingBefore.data.edit.y != missing.data.edit.y*/)))) || !zurrückVermeiden.checked) && ((pMissing == (positions.wrong[side].edit.x + lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y) /*right*/ || (pMissing ==
      (positions.wrong[side].edit.x - lengthPerTeil.edit.x) + ' - ' + positions.wrong[side].edit.y)/*left*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y + lengthPerTeil.edit.y))/*down*/ || (pMissing == positions.wrong[side].edit.x + ' - ' + (positions.wrong[side].edit.y - lengthPerTeil.edit.y))/*up*/))) {
      if (zurrückVermeiden.checked && (missingArray.includes(positions.wrong[side].edit.x + " - " + positions.wrong[side].edit.y))) {
        maleZurrück.number++;
      }
      else maleZurrück.normalSlide++;
      missingArray.push(pMissing);
      //console.log(missingArray);
      // movement.positions.unshift(JSON.parse(JSON.stringify(positions)));
      var ablage = JSON.parse(JSON.stringify(positions.wrong[side]));
      movement.move.unshift({x: (pMissing.split(' - ')[0] - ablage.edit.x), y: (pMissing.split(' - ')[1] - ablage.edit.y), tile: side});
      // movement.missing.unshift(JSON.parse(JSON.stringify(missingArray)));
      positions.wrong[side].edit = JSON.parse(JSON.stringify({x: JSON.parse(pMissing.split(' - ')[0]), y: JSON.parse(pMissing.split(' - ')[1]), degree: 0}));//.splice(side, 1);
      textur.width = textur.width;
      layout(true);
      // for (var i1 = 0; difficultSchieben.checked && i1 < movement.positions.length; i1++) {
        //   if (angular.equals(positions, movement.positions[i1])/* && angular.equals(missing, movement.missing[i1])*/) {
          //     positions = JSON.parse(JSON.stringify(movement.positions[1]));
          //     missing = JSON.parse(JSON.stringify(movement.missing[1]));
          //     movement.positions.splice(0, 1);
          //     movement.missing.splice(0, 1);
          //     maleZurrück.number++;
          //     i1 = movement.positions.length;
          //     i--;
          //     for (var i2 = 0; i2 < workingNumbers.length; i2++) {
            //       if (workingNumbers[i2] == side) workingNumbers.splice(i2, 1);
            //     }
            //   }
            // }
            // if (i1 != movement.positions.length + 1) {
      missing[i1] = ablage.edit.x + ' - ' + ablage.edit.y;
      workingNumbers = [];
      for (var i1 = 0; i1 < positions.wrong.length; i1++) {
        if (!listCoordinates(doNotChange).includes(i)) workingNumbers.push(i1);
      }
      // }
    }
      else {
        i--;
        for (var i1 = 0; i1 < workingNumbers.length; i1++) {
          if (workingNumbers[i1] == side) workingNumbers.splice(i1, 1);
        }
      }
    } catch (e) {
      //console.log("ein Error bei der if Abfrage!!! + (" + e + ")");
      i = positions.wrong.length;
    }
  });
    counter++;
    }
    if (layout(undefined, true, true) != undefined) verschiebenPC();
  }
  var movement = {move: [], startPosition: []};
  var mausx;
  var mausy;
  var stats = {turns: 0, highestRight: {turns: 0, right: 0}, rotated: 0, unclipped: 0, wrongClipped: 0, viewOriginal: {times: 0}, minimumRotations: 0};
  document.onmousemove = readMouseMove
  var originalMausX;
  // section 5: most user inputs
  var pcScrolls = false;
  window.addEventListener('scroll',()=>{
    if (pcScrolls) pcScrolls = false;
    else {
      selected.position = {x: selected.position.x + (state.scrollX - scrollX), y: selected.position.y + (state.scrollY - scrollY), manualScrolling: true};
      if (tutorial.state == "manuallyScrollingTutorial") goTutorialSteps(1);
    } 
    if (scrollY > 10 && scrollY < texturTop - (showSettings.getBoundingClientRect().bottom + scrollY) && settings.style.display == "inline") selectBackToBarB.style.display = 'none';
    else if (aufgebenId.style.display == "inline" && shuffleStyle == "list") selectBackToBarB.style.display = 'inline';
    adaptMobileControlsPosition();
    if (keepScrolling.checked) folgenMouseMove();
    state.scrollX = scrollX;
    state.scrollY = scrollY;
  });
  window.visualViewport.addEventListener("resize", resized);
  function resized (event) {
    if (state.rightScroll < 0 && (positions.wrong.reduce((acc, val) => val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 < acc ? val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 : acc, textur.width)) > visualViewport.pageLeft) {
      var distance = (positions.wrong.reduce((acc, val) => val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 < acc ? val.edit.x - state.rightScroll - lengthPerTeil.edit.x/2 : acc, textur.width)) - visualViewport.pageLeft;
      state.rightScroll += distance;
      canvas.translate(-distance, 0);
    }
    if (state.rightScroll > 0 && (visualViewport.pageLeft + visualViewport.width - texturLeft) > positions.wrong.reduce((acc, val) => val.edit.x + lengthPerTeil.edit.x - state.rightScroll > acc ? val.edit.x + lengthPerTeil.edit.x - state.rightScroll : acc, 0)) {
      var distance = (visualViewport.pageLeft + visualViewport.width - texturLeft) - positions.wrong.reduce((acc, val) => val.edit.x + lengthPerTeil.edit.x - state.rightScroll > acc ? val.edit.x + lengthPerTeil.edit.x - state.rightScroll : acc, 0)
      state.rightScroll -= distance;
      canvas.translate(distance, 0);
    }
    if (state.upScroll < 0 && (positions.wrong.reduce((acc, val) => val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 < acc ? val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 : acc, textur.height)) > visualViewport.pageTop) {
      var distance = (positions.wrong.reduce((acc, val) => val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 < acc ? val.edit.y - state.upScroll - lengthPerTeil.edit.y/2 : acc, textur.height)) - visualViewport.pageTop;
      state.upScroll += distance;
      canvas.translate(0, -distance);
    }
    if (state.upScroll > 0 && (visualViewport.pageTop + visualViewport.height - texturTop) > positions.wrong.reduce((acc, val) => val.edit.y + lengthPerTeil.edit.y - state.upScroll > acc ? val.edit.y + lengthPerTeil.edit.y - state.upScroll : acc, 0)) {
      var distance = (visualViewport.pageTop + visualViewport.height - texturTop) - positions.wrong.reduce((acc, val) => val.edit.y + lengthPerTeil.edit.y - state.upScroll > acc ? val.edit.y + lengthPerTeil.edit.y - state.upScroll : acc, 0)
      state.upScroll -= distance;
      canvas.translate(0, distance);
    }
    layout(true, true);
  }
  function adaptTitlesPosition() {
    var vis = {rotateLeft: rotateLeftTitle.style.display, rotateRight: rotateRightTitle.style.display, selectMultiple: selectMultipleTitle.style.display, swipe: swipeTitle.style.display};
    rotateLeftTitle.style.display = "inline";
    rotateRightTitle.style.display = "inline";
    selectMultipleTitle.style.display = "inline";
    rotateLeftTitle.style.top = rotateLeftSymbol.getBoundingClientRect().bottom + 20;
    rotateRightTitle.style.top = rotateRightSymbol.getBoundingClientRect().bottom + 20;
    selectMultipleTitle.style.top = selectMultipleSymbol.getBoundingClientRect().bottom + 20;
    rotateLeftTitle.style.left = rotateLeftSymbol.getBoundingClientRect().left + rotateLeftSymbol.getBoundingClientRect().width/2 - rotateLeftTitle.getBoundingClientRect().width/2;
    rotateRightTitle.style.left = rotateRightSymbol.getBoundingClientRect().left + rotateRightSymbol.getBoundingClientRect().width/2 - rotateRightTitle.getBoundingClientRect().width/2;
    selectMultipleTitle.style.left = selectMultipleSymbol.getBoundingClientRect().left + selectMultipleSymbol.getBoundingClientRect().width/2 - selectMultipleTitle.getBoundingClientRect().width/2;
    swipeTitle.style.display = "inline";
    swipeTitle.style.top = swipeSymbol.getBoundingClientRect().bottom + 20;
    swipeTitle.style.left = swipeSymbol.getBoundingClientRect().left + swipeSymbol.getBoundingClientRect().width/2 - swipeTitle.getBoundingClientRect().width/2;
    rotateLeftTitle.style.display = vis.rotateLeft;
    rotateRightTitle.style.display = vis.rotateRight;
    selectMultipleTitle.style.display = vis.selectMultiple;
    swipeTitle.style.display = vis.swipe;
  }
  function adaptMobileControlsPosition() {
    mobileControls.style.top = (visualViewport.offsetTop/* - 7*/ + 2) + 'px';
    mobileControls.style.left = (visualViewport.offsetLeft + 300/visualViewport.scale) + 'px';
    mobileControls.style.fontSize =  (5/visualViewport.scale) + 'vh';
    for (const elm of document.getElementsByClassName('mobileControlsElm')) {
      elm.style.width = 44/(visualViewport.scale); 
      elm.style.height = 44/(visualViewport.scale); 
    }
    var pos = {x: visualViewport.offsetLeft, y: visualViewport.offsetTop};
    setTimeout(() => {
      if (pos.x != visualViewport.offsetLeft || pos.y != visualViewport.offsetTop) adaptMobileControlsPosition();
      else {
        for (const elm of document.getElementsByClassName('speech')) {
          elm.style.fontSize = 25/visualViewport.scale + 'px';
          elm.style.maxWidth = visualViewport.width/4 + 'px';
          elm.style.padding = 20/visualViewport.scale + 'px';
        }
        adaptTitlesPosition();
      }
    }, 40);
  }
  // #importantUserInputs
  function readMouseMove(e) {
    mausx = e.clientX + scrollX - texturLeft + state.rightScroll;
    mausy = e.clientY + scrollY - texturTop + state.upScroll;
    if (selected.position.manualScrolling) {
      selected.position = {x: mausx, y: mausy};
      selected.position.manualScrolling = false;
    }
    originalMausX = e.clientX;
    if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width) - mausx; // - scrollX;
    // /*96*/32// - 43;
    // if (scrollY > 32) mausy += 32;
    if (gerät == "PC") folgenMouseMove("mousemove");
  }
  window.scroll(0, 0);
  var texturTop = textur.getBoundingClientRect().top + scrollY;
  var state = {mouse: "up", shift: false, newTileSelected: false, buttons: {}, coord: {x: 0, y: 0}, backToBar: false, rightScroll: 0, upScroll: 0, userSource: 'Picture', scrollX: 0, scrollY: 0};
  var texturLeft = textur.getBoundingClientRect().left;
  // #importantUserInputs
  // if (gerät == "Handy") {
    textur.addEventListener('touchmove', touch, {passive:false});
    textur.addEventListener('touchstart', touch);
    textur.addEventListener('touchend', touch);
    tileSelectionCanvas.addEventListener('touchmove', touch, {passive:false});
    tileSelectionCanvas.addEventListener('touchstart', touch);
    tileSelectionCanvas.addEventListener('touchend', touch);
    function touch(ev) {
      if (!scrollable.checked && ev.type == "touchmove" && settings.style.display != "inline" && (aufgebenId.style.display == "inline" || state.removeTile)) {
        ev.preventDefault();
      }
      if ((aufgebenId.style.display == "inline" || removeTilesFinishedB.style.display == "inline") && (!ev.touches[0] || (ev.touches[0] && !collides({x: ev.touches[0]["pageX"] - scrollX, y: ev.touches[0]["pageY"] - scrollY, width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean))) {
    if (ev.touches[2] && !scrollable.checked) {
    }
    else if (ev.type == "touchmove" && !scrollable.checked && (!scrollOnBlanc.checked || selected.tiles.length)) {
    }
    if (ev.touches[1] && aufgebenId.style.display == "inline") {
      state.shift = true;
      state.shiftBySwipe = true;
      selected.tiles = [];
      mouseDown();
    }
    if (ev.type == "touchend") {
      console.log('touchEnd');
    }
    // #potentialErrorCause
    if ((state.removeTile || ((swipeSteuerung.checked || modeSelection.value != "exchange"))) && ev.touches[0]) {
      var pTexturLeft = textur.getBoundingClientRect().left;
      if (pTexturLeft < 0) pTexturLeft = 0;
      mausx = ev.touches[0]["pageX"] - pTexturLeft + state.rightScroll;
      mausy = ev.touches[0]["pageY"] - texturTop + state.upScroll;// - 32;
      if (mirrorInput.checked && (shuffleStyle.value != "listTiles" || !tileSelectionBar.collidesMouse())) mausx = (textur.width + scrollX) - mausx;
      // TODO: if statement needed?
      if (tileSelectionBar.collidesMouse()) originalMausX = ev.touches[0]["pageX"];
    }
    if (!scrollable.checked) {
    if (ev.type == "touchstart" && !ev.touches[2] && !collides({x: mausx, y: mausy + texturTop, width: 1, height: 1}, selectBackToBarB.getBoundingClientRect()).boolean) {
      mouseDown(null, ev.touches[0] == undefined && collides({x: ev.touches[0]["pageX"], y: ev.touches[0]["pageY"], width: 1, height: 1}, mobileControls.getBoundingClientRect()).boolean);
    }
    if (ev.type == "touchend") {
      // #potentialErrorCause
      // setTimeout(function () {
        mouseUp();
        layout(true, true);
      // }, 100);
    }
    if (ev.type == "touchmove" && (modeSelection.value == "traditional" || state.removeTile)) {
      folgenMouseMove("touchmove");
    }
  }
    }
    adaptMobileControlsPosition();
  }
  // }
  function tileSelected() {
    for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
      var i = positions.layoutOrder[i1];
      var coord = positions.wrong[i].edit;
      var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
      if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
      if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && !selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
        return true;
      }
    }
  }
  var tutorial = {state: "", index: 0};
  function mouseDown(elmCalled, touchStart) {
    if (swipeSteuerung.checked && modeSelection.value != "schieben" && checkSelected() && !selected.boolean.click && !scrollable.checked) {
      selected.coord = {x: checkSelected().x, y: checkSelected().y};
      selected.boolean.swipe = true;
    }
    selected.tile = checkSelected();
    delete state.rorated;
    tileSelectionBar.swipePosition = originalMausX;
    if (modeSelection.value == "traditional") {
    if (state.mouse == "up" && !automaticTileSelectionReset.checked && state.removeTile) state.mouse = "downNow";
    if (state.mouse != "downNow") state.mouse = "down";
    if (selected.tiles.length && !state.shift && !automaticTileSelectionReset.checked && state.mouse != "downNow") {
      mouseUp(true);
      if ((tutorial.state == "clickUnselectMoveTutorial" && !state.removeTile && selected.tiles.length) || ["unselectUnclippStandardTutorial", "unselecTileAfterTileBarTilePlacementTutorial"].includes(tutorial.state)) {
        goTutorialSteps(1);
        if (tutorial.state != "SecondPlaceTileTutorial") automaticTileSelectionReset.checked = true;
      }
      if (["getClippingOptionConnectTileTutorial", "manuallyScrollingTutorial", "automaticScrollingTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
      if (!state.removeTile) selected.tiles = [];
      else state.mouse = "up";
      state.shiftBefore = false;
    }
    else {
      if (state.mouse = "downNow") state.mouse = "down";
      if (gerät == "Handy" && selectMultiple.checked) state.shift = true;
      state.coord = checkSelected(true);
      if (modeSelection.value == "traditional") {
        if (tileSelectionBar.selectedTile?.tileI != undefined && (tileSelectionBar.selectedTile.byUser || !tileSelected()) && !tileSelectionBar.collidesMouse() && state.backToBar === false) {
          if (["placeTileOnFiledTutorial", "SecondPlaceTileTutorial"].includes(tutorial.state)) goTutorialSteps(1);
          var i = tileSelectionBar.selectedTile;
          selected.tiles.push(i.tileI);
          positions.layoutOrder = positions.layoutOrder.filter(x => x != i.tileI);
          positions.layoutOrder.push(i.tileI);
          tileSelectionBar.tiles.splice(i.i, 1);
          // tileSelectionBar.tiles = tileSelectionBar.tiles.filter(x => x != undefined);
          if (!autoSelectTileBar.checked) tileSelectionBar.selectedTile = undefined;
            else {
            if (!tileSelectionBar.tiles.length) tileSelectionBar.selectedTile = undefined;
            else {
              setTimeout(function () {
                tileSelectionBar.selectedTile.byUser = false;
                tileSelectionBar.selectedTile.tileI++;
                if (!positions.wrong[tileSelectionBar.selectedTile.tileI] || positions.wrong[tileSelectionBar.selectedTile.tileI].edit.y != 5 + lengthPerTeil.edit.y/2) tileSelectionBar.selectedTile.i--;
                while (tileSelectionBar.selectedTile.tileI >= 0 && tileSelectionBar.tiles.length > 0 && (!positions.wrong[tileSelectionBar.selectedTile.tileI] || positions.wrong[tileSelectionBar.selectedTile.tileI].edit.y != 5 + lengthPerTeil.edit.y/2)) {
                  tileSelectionBar.selectedTile.tileI--;
                }
                layout();
              }, 10);
            }
          }
            positions.wrong[i.tileI].edit = {x: mausx, y: mausy, degree: 0};
          state.placeTile = true;
          scrollTileSelection(0);
        }
        // selected.tiles = [];
        selected.position = {x: mausx, y: mausy};
        for (var i1 = positions.layoutOrder.length - 1; !state.removeTile && i1 >= 0; i1--) {
          var i = positions.layoutOrder[i1];
          var coord = positions.wrong[i].edit;
          var rotated = {x: coord.x - ((lengthPerTeil.edit.x)/2), y: coord.y - ((lengthPerTeil.edit.y)/2), width: lengthPerTeil.edit.x, height: lengthPerTeil.edit.y};
          if ([270, 90].includes(positions.wrong[i].original.degree)) rotated = {width: rotated.height, height: rotated.width + 1, x: coord.x - ((lengthPerTeil.edit.y)/2), y: coord.y - ((lengthPerTeil.edit.x)/2)};
          if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && selected.tiles.includes(i) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height) {
            state.oldTileSelected = true;
          }
          if (!tileSelectionBar.tiles.includes(i) && !tileSelectionBar.collidesMouse() && !state.newTileSelected && (!selected.tiles.includes(i) || (gerät == "Handy" && (rotatesLeft.checked || rotatesRight.checked))) && mausx >= rotated.x && mausx <= rotated.x + rotated.width && mausy >= rotated.y && mausy <= rotated.y + rotated.height/* && selectedCollides(i) == undefined*/) {
            if (!state.placeTile) {
              if (!selected.tiles.includes(i)) selected.tiles.push(i);
              positions.layoutOrder = positions.layoutOrder.filter(x => x != i);
              positions.layoutOrder.push(i);
              if (["tileClickMoveTutorial", "holdMouseMoveTutorial", "moveMouseMoveTutorialAlternative", "selectTileConnectTileTutorial", "selectTileStandardUnclippTutorial", "selectTileAlternativeUnclippTutorial", "selectTileScrollingTutorial", "selectTileAutomaticScrollingTutorial"].includes(tutorial.state)) {
                goTutorialSteps(1);
              }
              if (!elmCalled && !touchStart && rotateTiles.checked) {
                if (rotatesRight.checked) rotateSelected(90);
                if (rotatesLeft.checked) rotateSelected(-90);
              }
            }
            if (state.backToBar !== false) {
              if (["backToTileBarPlusBTutorial", "selectBackToBarTileZurückInLeisteTutorial"].includes(tutorial.state)) goTutorialSteps(1);
              // tileSelectionBar.tiles.push(i);
              tileSelectionBar.tiles.splice(state.backToBar, 0, i);
              if (autoSelectTileBar.checked && tileSelectionBar.tiles.length == 1) {
                state.setSelected = {i: state.backToBar, tileI: i};
                setTimeout(function() {
                  tileSelectionBar.selectedTile = state.setSelected;
                }, 10);
              }
              document.getElementsByClassName('backToTileB')[state.backToBar].style.backgroundColor = '';
              selectBackToBarB.style.backgroundColor = '';
              state.backToBar = false;
              unclipp(i);
              mouseDown();
            }
            layout(true);
            state.newTileSelected = true;
          }
        }
        if (!state.newTileSelected && !state.oldTileSelected && !automaticTileSelectionReset.checked && !state.removeTile) selected.tiles = [];
        state.placeTile = false;
        tileSelectionBar.tiles.forEach((tileI, i) => {
          var tile = positions.wrong[tileI];
          if (mausx > (5 + lengthPerTeil.sizeAdapted.x)*i + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && mausx < (5 + lengthPerTeil.sizeAdapted.x)*(i + 1) + 5 - tileSelectionBar.leftOffScreenTiles*(lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x)) + tileSelectionBar.offset && tileSelectionBar.collidesMouse()) {
            tileSelectionBar.selectedTile = {i: i, tileI: tileI, byUser: true};
            if (["MouseDownScrollTileBarTutorial", "selectTileBarTileTutorial", "selectTileTileBarZurückInLeisteTutorial"].includes(tutorial.state)) goTutorialSteps(1);
            layout();
          }
        });
        folgenMouseMove("mouseDown");
      }
      else if (state.removeTile) folgenMouseMove("mouseDown");
    }
  }
  else state.mouse = "down";
  }
  // #importantUserInput
  function folgenMouseMove(calledBy) {
    if ((["moveMouseMoveTutorialAlternative", "moveMouseMoveTutorial"].includes(tutorial.state) || (tileSelectionBar.collidesMouse() && tutorial.state == "moveMouseScrollTileSelectionBarTutorial")) && calledBy == "mousemove") {
      goTutorialSteps(1);
    }
    if (state.mouse == "down" && tileSelectionBar.collidesMouse() && tutorial.state == "MouseDownScrollTileBarTutorial" && calledBy != "mousedown") goTutorialSteps(1);
    if (tileSelectionBar.collidesMouse()) mausx = originalMausX;
    selected.clip = [];
    if (state.mouse == "down" && state.removeTile) canvasClicked(calledBy);
    positionBackToTileBarButtons(true);
    if (state.mouse == "down" && !state.removeTile && modeSelection.value == "traditional") {
      if (calledBy != "mouseDown") selectMultiple.checked = false;
      // select clipped
      for (var tile of selected.tiles) {
        var objTile = positions.wrong[tile];
        if (gerät == "PC") {
        if (mirrorInput.checked && originalMausX - lengthPerTeil.edit.x/2 < 0) expandSide('right');// textur.width += 15;
        if (!mirrorInput.checked && objTile.edit.x + lengthPerTeil.edit.x > textur.width) expandSide('right'); // textur.width += lengthPerTeil.edit.x;
        if (objTile.edit.y + lengthPerTeil.edit.y > textur.height) expandSide('bottom'); // textur.height += lengthPerTeil.edit.y;
      }
        for (var clipp of clipped) {
          var newTile = clipp.split(' - ').filter(x => !selected.tiles.includes(JSON.parse(x)))[0];
          if (!state.shift && !state.shiftBefore && clipp.split(' - ').includes(tile + "") && newTile) {
            selected.tiles.push(JSON.parse(newTile));
            positions.layoutOrder = positions.layoutOrder.filter(x => x != JSON.parse(newTile));
            positions.layoutOrder.push(JSON.parse(newTile));
          }
        }
        // unclipp
        if (((state.shift && automaticTileSelectionReset.checked) || (!automaticTileSelectionReset.checked && !state.shift && state.shiftBefore)) && calledBy != "mouseDown") {
          unclipp(tile);
          state.shiftBySwipe = false;
        }
        // positions.wrong.forEach((position, i) => {
        //   if (((objTile.original?.left?.x == position.original?.x && objTile.original?.left?.x != undefined && objTile.original?.left?.y == position.original?.y) || (objTile.original?.top?.x == position.original?.x && objTile.original?.top?.x != undefined && objTile.original?.top?.y == position.original?.y) || (objTile.original?.wrong?.x == position.original?.x && objTile.original?.wrong?.x != undefined && objTile.original?.wrong?.y == position.original?.y) || (objTile.original?.bottom?.x == position.original?.x && objTile.original?.bottom?.x != undefined && objTile.original?.bottom?.y == position.original?.y)) && !selected.tiles.includes(i)) {
        //     selected.tiles.push(i);
        //   }
        // });
        if ((automaticTileSelectionReset.checked || !state.shift)) {
          positions.wrong[tile].edit.x += mausx - selected.position.x;
          positions.wrong[tile].edit.y += mausy - selected.position.y;
          // check clicking
          checkPossibleClipping(tile);
       }
      }
      if ((automaticTileSelectionReset.checked || !state.shift)) {
        deleteFurtherClipOptions();
        playClippingSound();
        selected.position = {x: mausx, y: mausy, manualScrolling: selected.position.manualScrolling};
        layout(false, true);
      }
    }
  }
  // deletes clip options that apply to the same tile but are further away
  function deleteFurtherClipOptions() {
    nearestTile = {};
    selected.clip.forEach((clip, i1) => {
      if (!getConnectedTiles(clip.sI, true).includes(nearestTile[clip.i]?.clip.sI)) {
        if (!nearestTile[clip.i] || clip.distance < nearestTile[clip.i].clip.distance) {
          if (nearestTile[clip.i]) selected.clip.splice(nearestTile[clip.i].i, 1);
          nearestTile[clip.i] = {clip: clip, i: i1};
        }
        else if (clip.distance >= nearestTile[clip.i].clip.distance) {
          selected.clip.splice(i1, 1);
        }
      }
      // sI
      if (!getConnectedTiles(clip.i, true).includes(nearestTile[clip.sI]?.clip.i)) {
      if (!nearestTile[clip.sI] || (clip.distance < nearestTile[clip.sI].clip.distance)) {
        if (nearestTile[clip.sI]) selected.clip.splice(nearestTile[clip.sI].i, 1);
        nearestTile[clip.sI] = {clip: clip, i: i1};
      }
      else if (clip.distance > nearestTile[clip.sI].clip.distance) {
        selected.clip.splice(i1, 1);
      }
    }
    });
    for (let i1 = 0; i1 < selected.clip.length; i1++) {
      if (selected.clip[i1 + 1] && !getConnectedTiles(selected.clip[i1].i, true).includes(selected.clip[i1 + 1].i)) {
        if (selected.clip[i1].distance <= selected.clip[i1 + 1].distance) selected.clip.splice(i1 + 1, 1);
        else selected.clip.splice(i1, 1);
      }
    }
  }
  var nearestTile = {};
  // #importantUserImput
  function mouseUp(byUnselection) {
    if (["moveMouseMoveTutorialAlternative", "moveMouseScrollTileSelectionBarTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
    if (tutorial.state == "rotateTileTutorialAlternative") goTutorialSteps(-2);
    if (tutorial.state == "releaseMoveTutorial") {
      goTutorialSteps(1);
      if (moveStyleSettingChosen.checked) goTutorialSteps(1);
    }
    if (["getClippingOptionConnectTileTutorial", "manuallyScrollingTutorial", "automaticScrollingTutorial"].includes(tutorial.state) && automaticTileSelectionReset.checked) goTutorialSteps(-1);
    if (tutorial.state == "unselectAlternativeUnclippTutorial") {
      automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
    }
    if (["unselectAlternativeUnclippTutorial", "unselectTileScrollingTutorial", "stopScrollingAutomaticScrollingTutorial", "stopScrollingTileBarTutorial"].includes(tutorial.state) || (automaticTileSelectionReset.checked && tutorial.state == "unselecTileAfterTileBarTilePlacementTutorial")) {
      goTutorialSteps(1);
    }
    if (swipeSteuerung.checked && modeSelection.value == "exchange" && checkSelected()) {
      canvasClicked();
    }
    if (automaticTileSelectionReset.checked || !selected.tiles.length || (state.removeTile && automaticTileSelectionReset.checked)) {
      state.mouse = "up";
      if (tutorial.state == "releaseShiftAlternativeUnclippTutorial") {
        unselectAlternativeUnclippTutorial.checked = true;
        automaticTileSelectionReset.checked = JSON.parse(localStorage.getItem("automaticTileSelectionResetPuzzleCreator"));
      }
    }
    if (gerät == "Handy" && !selectMultiple.checked && !state.shiftBySwipe) state.shift = false;
    if (automaticTileSelectionReset.checked) state.shiftBefore = false;
    if (modeSelection.value == "traditional" && (!state.rotated || gerät == "PC")) {
      state.newTileSelected = false;
      state.oldTileSelected = false;
      if (automaticTileSelectionReset.checked || byUnselection) {
      var bClipped = false;
      for (var clip of selected.clip) {
        if (!tileSelectionBar.tiles.includes(clip.i)) {
        if ((JSON.stringify(positions.right[clip.i].original[convertDirection(clip.direction, positions.wrong[clip.sI].original.degree)]) != JSON.stringify({x: positions.wrong[clip.sI].original.x, y: positions.wrong[clip.sI].original.y}) || positions.wrong[clip.sI].original.degree != positions.wrong[clip.i].original.degree)) stats.wrongClipped++;
        var directionOpposite = {left: 'right', top: 'bottom', right: 'left', bottom: 'top'};
        positions.wrong[clip.i].original[clip.direction] = {x: positions.right[clip.sI].original.x, y: positions.right[clip.sI].original.y};
        positions.wrong[clip.sI].original[directionOpposite[clip.direction]] = {x: positions.right[clip.i].original.x, y: positions.right[clip.i].original.y};
        var differ = {x: (clip.selected.x - positions.wrong[clip.sI].edit.x), y: (clip.selected.y - positions.wrong[clip.sI].edit.y)};
        for (var tile of selected.tiles) {
          positions.wrong[tile].edit.x += differ.x;
          positions.wrong[tile].edit.y += differ.y;
        }
        clipped.push(clip.i + ' - ' + clip.sI);
        bClipped = true;
        for (var tile of selected.tiles) {
        // do more clipping if needed
        checkPossibleClipping(tile, true);
      }
      deleteFurtherClipOptions();
      }
    }
    if (selected.clip.length && bClipped) {
      new Audio('https://adi.nicolaiweitkemper.de/Sounds/helpTheTrain/weiche.mp3').play();
      console.log("clipping...");
      if (["clipTileTutorial", "clippSecondTutorial"].includes(tutorial.state)) {
        goTutorialSteps(1);
        automaticTileSelectionReset.checked = false;
      }
      stats.turns++;
      // selectMultiple.checked = false;
      state.shift = false;
      selected.tiles = [];
    }
  }
  selected.clip = [];
}
if (selected.tiles.length && !state.shift && !state.removeTile && automaticTileSelectionReset.checked) selected.tiles = [];
delete state.rotated;
layout(false, true);
  if (aufgebenId.style.display == "inline" && doStorePuzzle.checked && !finished) storePuzzle(); 
  if (tutorial.state == "unclippTileAlternativeUnclippTutorial" && state.mouse == "up") {
    goTutorialSteps(-1);
    selected.tiles = [];
  }
}
  function rotateTile(tile, direction) {
    if (mirrorInput.checked) direction *= -1;
    positions.wrong[tile].original.degree = getDegreeAfterRotation(positions.wrong[tile].original.degree, direction);
    stats.rotated++;
  }
  function getDegreeAfterRotation(degree, direction) {
    degree += direction;
    if (degree < 0) degree = 270;
    if (degree > 270) degree = 0;
    return degree;
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  document.onkeyup = function(event) {
    if (event.key == "Shift" && state.shift) {
      state.shift = false;
      if (automaticTileSelectionReset.checked) selected.tiles = [];
      if (["selectTileStandardUnclippTutorial", "selectTileAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(-1);
      if (tutorial.state == "releaseShiftStandardUnclippTutorial") goTutorialSteps(1);
      if (tutorial.state == "unclippTileAlternativeUnclippTutorial") goTutorialSteps(-2);
      if (tutorial.state == "releaseShiftAlternativeUnclippTutorial") {
        goTutorialSteps(1);
        if (unselectAlternativeUnclippTutorial.checked) {
          goTutorialSteps(1);
        }
      }
    }
    if (event.key == "Escape") {
      selected.tiles = [];
    }
    // if (aufgebenId.style.display == "none") layout();
  }
  // end section 5
  // section 6: rotate tile(s)
    // #importantUserInputs
    document.onkeydown = function(event) {
    if (event.key == "Shift") {
      state.shift = true;
      state.shiftBefore = true;
      selected.tiles = [];
      if (["pressShiftStandardUnclippTutorial", "pressShiftAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
    var collidesTilesBar = tileSelectionBar.collidesMouse();
    if (rotateTiles.checked) {
      if (event.key == "ArrowRight") {
        if (collidesTilesBar) {
          scrollTileSelection(1, "arrowKey");
        }
        else rotateSelected(90);
      }
      if (event.key == "ArrowLeft") {
        if (collidesTilesBar) scrollTileSelection(-1, "arrowKey");
        else rotateSelected(-90);
      }
    }
    if (event.key?.includes("Arrow")) layout(true);
    if ((event.key == "ArrowRight" || event.key == "ArrowLeft") && modeSelection.value == "traditional" && ((selected.tiles.length && rotateTiles.checked) || collidesTilesBar)) return false;
  }
  function rotateSelected(direction) {
    if (["rotateTileTutorial", "rotateTileTutorialAlternative"].includes(tutorial.state)) goTutorialSteps(1);
    if (!state.removeTile) {
      state.rotated = [];
      if (!state.shift) {
        rotateAround(selected.tiles[0], direction);
        if (lengthPerTeil.edit.x != lengthPerTeil.edit.y && getConnectedTiles(selected.tiles[0], true).length > 1) {
          state.rotated = [];
          rotateAround(selected.tiles[0], direction);
        }
      }
      else {
        for (const tile of selected.tiles) {
          rotateTile(tile, direction);
        }
      }
      // layout(true, true);
      folgenMouseMove();
    }
  }
  function rotateAround(tile, direction, connectionSide, connectionObj) {
    state.rotated.push(tile);
    var tileObj = positions.wrong[tile];
    if (tileObj) { 
      if (connectionSide) {
        if (connectionSide == 'left') {
          tileObj.edit.x = connectionObj.edit.x - lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'top') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y - lengthPerTeil.edit.y;
        }
        if (connectionSide == 'right') {
          tileObj.edit.x = connectionObj.edit.x + lengthPerTeil.edit.x;
          tileObj.edit.y = connectionObj.edit.y;
        }
        if (connectionSide == 'bottom') {
          tileObj.edit.x = connectionObj.edit.x;
          tileObj.edit.y = connectionObj.edit.y + lengthPerTeil.edit.y;
        }
      }
      rotateTile(tile, direction);
      var directionConverter = {90: {left: 'top', top: 'right', right: 'bottom', bottom: 'left'}, '-90': {left: 'bottom', bottom: 'right', right: 'top', top: 'left'}};
      for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original[side]) {
          tileObj.original['new' + directionConverter[direction][side]] = tileObj.original[side];
          delete tileObj.original[side];
        }
      };
        for (const side of ['left', 'top', 'right', 'bottom']) {
        if (tileObj.original['new' + directionConverter[direction][side]]) {
          tileObj.original[directionConverter[direction][side]] = tileObj.original['new' + directionConverter[direction][side]];
          delete tileObj.original['new' + directionConverter[direction][side]];
          if (!state.rotated.includes(getTile(tileObj.original[directionConverter[direction][side]]))) rotateAround(getTile(tileObj.original[directionConverter[direction][side]]), direction, directionConverter[direction][side], tileObj);
        }
      };
    }
  }
  // end section 6
  function storePuzzle() {
    getPuzzles();
    var puzzle = puzzles[puzzleName.value];
    if (!puzzle) puzzle = {};
    puzzle.settings = {};
    puzzle.tileAmount = {x: anzahlX.value, y: anzahlY.value};
    puzzle.positions = positions;
    puzzle.stats = stats;
    puzzle.mode = modeSelection.value;
    if (modeSelection.value == "schieben") {
      puzzle.movement = JSON.parse(JSON.stringify(movement));
      delete puzzle.movement.playerPosition;
      puzzle.missing = missing;
      puzzle.userMovement = userMovement;
      puzzle.movementPlayerPosition = playerMovementSlider.value;
    }
    if (modeSelection.value == "traditional") {
      puzzle.settings.rotateTiles = rotateTiles.checked;
      if (shuffleStyle.value == "listTiles") puzzle.tileBarTiles = tileSelectionBar.tiles;
    }
    puzzle.settings.mirrorInput = mirrorInput.checked;
    if (sourceIsFile.checked) {
      puzzle.fileName = fileName;
    }
    if (useURLCheck.checked) {
      puzzle.URL = sourceURL.value;
    }
    if (useLiveCam.checked) {
      puzzle.liveCam = cameraSelection.options[cameraSelection.value - 1].value;
    }
    puzzle.width = größeAnpassenX.value;
    puzzle.height = größeAnpassenY.value;
    puzzle.completionTime = stopClock.completionTime.time;
    puzzle.viewOriginalTime = stopClock.viewOriginal.time;
    puzzles[puzzleName.value] = puzzle;
    if (sourceIsVideo.checked) {
      puzzle.loopBeginning = loopBeginning.value;
      puzzle.loopEnding = loopEnding.value;
    } 
    localStorage.setItem('puzzleCreatorPuzzles', JSON.stringify(puzzles));
  }
  // returns pixel as a number
  function convertStyle(value) {
    return JSON.parse(value.replace('px', ''));
  }
  // adapts the position of the backToTileBarButtons
  function positionBackToTileBarButtons(calledByMouseDown) {
    if (!calledByMouseDown || (aufgebenId.style.display == "inline" && shuffleStyle.value == "listTiles" && state.mouse == "down" && tileSelectionBar.collidesMouse() && !selected.tiles.length)) {
      if (calledByMouseDown) tileSelectionBar.scrollX += (mausx - tileSelectionBar.swipePosition);
      tileSelectionBar.leftOffScreenTiles = - (Math.floor(tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5)));
      if (((tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5)) tileSelectionBar.offset = - (JSON.parse("0." + (tileSelectionBar.scrollX/(lengthPerTeil.edit.x + 5) + "").split('.')[1])*(lengthPerTeil.sizeAdapted.x + 5));
      else tileSelectionBar.offset = 0;
      if (tileSelectionBar.scrollX >= 0) tileSelectionBar.offset = -(tileSelectionBar.offset);
      else tileSelectionBar.leftOffScreenTiles--;
      for (var i = 0; i < document.getElementsByClassName('backToTileB').length; i++) {
      var elm = document.getElementsByClassName('backToTileB')[i];
        elm.style.left = tileSelectionCanvas.getBoundingClientRect().left + (lengthPerTeil.sizeAdapted.x + 5*(lengthPerTeil.sizeAdapted.x/lengthPerTeil.edit.x))*(i - tileSelectionBar.leftOffScreenTiles) + tileSelectionBar.offset - convertStyle(elm.style.width)/2 + 'px';
      }
      tileSelectionBar.swipePosition = mausx;
      if (calledByMouseDown) scrollTileSelection(0);
    }
  }
  function unclipp(tile) {
    var directionConverter = {top: 'bottom', left: 'right', bottom: 'top', right: 'left'};
    var objTile = positions.wrong[tile];
    for (const direc of ['left', 'top', 'right', 'bottom']) {
      if (objTile.original[direc] && !selected.tiles.includes(getTile(objTile.original[direc]))) {
        delete positions.wrong[getTile(objTile.original[direc])].original[directionConverter[direc]];
        delete objTile.original[direc];
      }
    }
    var unclipped = false;
    for (let i = 0; i < clipped.length; i++) {
      if (clipped[i].split(' - ').includes(tile + "") && (!selected.tiles.includes(parseInt(clipped[i].split(' - ')[0])) || !selected.tiles.includes(parseInt(clipped[i].split(' - ')[1])))) {
        clipped.splice(i, 1);
        unclipped = true;
        i--;
      }
    }
    if (unclipped) {
      stats.unclipped++;
      if (["unclippStandardTutorial", "unclippTileAlternativeUnclippTutorial"].includes(tutorial.state)) goTutorialSteps(1);
    }
  }
  function checkPossibleClipping(tile, afterClipping) {
    pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
    pCollider = {width: parseInt(hitboxWidth.value), height: parseInt(hitboxHeight.value)};
    if ([90, 270].includes(positions.wrong[tile].original.degree) && lengthPerTeil.edit.x != lengthPerTeil.edit.y) {
      pCollider = {width: parseInt(hitboxHeight.value), height: parseInt(hitboxWidth.value)};
      pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
      pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
    }
    var nearest = {left: {area: 1000}, top: {area: 1000}, right: {area: 1000}, bottom: {area: 1000}, overAll: {area: 1000, i: -1}};
    for (let i = 0; i < positions.wrong.length; i++) {
      positions.wrong[i].tempI = i;
    }
    var possiblePositions = positions.wrong.filter(x => Math.abs(x.edit.x - positions.wrong[tile].edit.x) < lengthPerTeil.edit.x + 11 && Math.abs(x.edit.y - positions.wrong[tile].edit.y) < lengthPerTeil.edit.y + 11);
    for (const pos of possiblePositions) {
      var obj = {all: pos.edit, slc: positions.wrong[tile].edit};
      var selectedObj = {
        right: {x: obj.slc.x - 10, y: obj.slc.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2},
        left: {x: obj.slc.x + pLengthPerTeil.edit.x, y: obj.slc.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2},
        bottom: {x: obj.slc.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.slc.y - 10, width: pCollider.width - 2, height: 10},
        top: {x: obj.slc.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.slc.y + pLengthPerTeil.edit.y, width: pCollider.width - 2, height: 10}
      };
      if (!clipped.includes(pos.tempI + ' - ' + tile) && !clipped.includes(tile + ' - ' + pos.tempI)) {
        var nearTile = {
          right: collides(selectedObj.right, {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2}),
          left: collides(selectedObj.left, {x: obj.all.x - 10, y: obj.all.y + 1 + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height - 2}),
          bottom: collides(selectedObj.bottom, {x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y + pLengthPerTeil.edit.y, width: pCollider.width - 2, height: 10}),
          top: collides(selectedObj.top, {x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y - 10, width: pCollider.width - 2, height: 10})
        };
        for (var side of Object.keys(nearTile)) {
          if (nearTile[side].boolean && nearTile[side].area < nearest[side].area) {
            nearest[side] = {area: nearTile[side].area, i: pos.tempI};
          }
        }
      }
    }
    if (nearest) {
      // console.log("new check");
      for (const near of Object.values(nearest)) {
        // console.log(near.area);
        if (near.area < nearest.overAll.area) {
          nearest.overAll = {area: near.area, i: near.i};
        }
      }
    }
    var acceptedI = getConnectedTiles(nearest.overAll.i, true);
    var screenObj = {x: visualViewport.pageLeft, y: visualViewport.pageTop, width: window.visualViewport.width - 22, height: window.visualViewport.height};
    if (mirrorInput.checked) screenObj = {x: textur.width - scrollX - window.innerWidth, y: scrollY, width: window.innerWidth - 22, height: window.innerHeight};
    canvas.fillStyle = "blue";
    // canvas.fillRect(textur.width - scrollX - window.innerWidth, scrollY, window.innerWidth, window.innerHeight);
    var clipLength = selected.clip.length;
    var filteredClip = JSON.stringify(filter(selected.clip, false, true));
    var obj = {all: positions.wrong[nearest?.right.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.left && !filteredClip.includes(JSON.stringify({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y, width: 10, height: pLengthPerTeil.edit.y, selected: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y}}))) {
      selected.clip.push({i: nearest.right.i, sI: tile, direction: 'right', x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height, selected: {x: obj.all.x + pLengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.right.area});
    }
    obj = {all: positions.wrong[nearest?.left.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.right && !filteredClip.includes(JSON.stringify({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y, width: 10, height: pLengthPerTeil.edit.y, selected: {x: obj.all.x - pLengthPerTeil.edit.x, y: obj.all.y}}))) {
      selected.clip.push({i: nearest.left.i, sI: tile, direction: 'left', x: obj.all.x - 10, y: obj.all.y + pLengthPerTeil.edit.y/2 - pCollider.height/2, width: 10, height: pCollider.height, selected: {x: obj.all.x - pLengthPerTeil.edit.x, y: obj.all.y}, distance: nearest.left.area});
    }
    obj = {all: positions.wrong[nearest?.bottom.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.top && !filteredClip.includes(JSON.stringify({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y, width: pLengthPerTeil.edit.x, height: 10, selected: { x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y}}))) {
      selected.clip.push({i: nearest.bottom.i, sI: tile, direction: 'bottom', x: obj.all.x + 1 + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y + pLengthPerTeil.edit.y, width: pCollider.width, height: 10, selected: { x: obj.all.x, y: obj.all.y + pLengthPerTeil.edit.y}, distance: nearest.bottom.area});
    }
    obj = {all: positions.wrong[nearest?.top.i]?.edit, slc: positions.wrong[tile].edit};
    if (obj.all && !positions.wrong[tile].original.bottom && !filteredClip.includes(JSON.stringify({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x, y: obj.all.y - 10, width: pLengthPerTeil.edit.x, height: 10, selected: {x: obj.all.x, y: obj.all.y - pLengthPerTeil.edit.y}}))) {
      selected.clip.push({i: nearest.top.i, sI: tile, direction: 'top', x: obj.all.x + pLengthPerTeil.edit.x/2 - pCollider.width/2, y: obj.all.y - 10, width: pCollider.width, height: 10, selected: {x: obj.all.x, y: obj.all.y - pLengthPerTeil.edit.y}, distance: nearest.top.area});
    }
    checkedTiles = [];
    for (var i = 0; i < selected.clip.length - clipLength; i++) {
      var clip = selected.clip[selected.clip.length - 1 - i];
      var clipCollider = JSON.parse(JSON.stringify(clip));
      clipCollider.x -= state.rightScroll;
      clipCollider.y -= state.upScroll;
      if (selected.clip.length > clipLength && ((selected.clip[selected.clip.length - 1 - i - 1] && angular.equals(clip, selected.clip[selected.clip.length - 1 - i - 1])) ||  (state.rotated && gerät == "Handy") || (positions.wrong[clip.i].original.degree != positions.wrong[clip.sI].original.degree && getDegreeAfterRotation(getDegreeAfterRotation(positions.wrong[clip.i].original.degree, 90), 90) /*total: 180°*/ != positions.wrong[clip.sI].original.degree && pLengthPerTeil.edit.x != pLengthPerTeil.edit.y) || tileSelectionBar.tiles.includes(clip.i) || ((/*selectedCollidesOthers(clip, tile) || */!collides(addTolerance(clipCollider, 3), screenObj).boolean || selectedCollideOther(clip.i) || clipCollidesLowerTile(clip) || !acceptedI.includes(clip.i)) && !afterClipping))) {
        selected.clip.pop();
        i--;
      }
    }
  }
  // returns a list with the indizes (plural index) of all tiles the entered tile ('tile') is connected to
  function getConnectedTiles(tile, firstCall, connectedTiles, restoreClipped) {
    if (!connectedTiles) connectedTiles = [];
    connectedTiles.push(tile);
    var tileObj = positions.wrong[tile];
    for (const side of ['left', 'top', 'right', 'bottom']) {
      if (tileObj && tileObj.original[side] && !connectedTiles.includes(getTile(tileObj.original[side]))) {
        if (restoreClipped && !clipped.includes(tile + ' - ' + getTile(tileObj.original[side])) && !clipped.includes(getTile(tileObj.original[side]) + ' - ' + tile)) {
          clipped.push(tile + ' - ' + getTile(tileObj.original[side]));
        }
        getConnectedTiles(getTile(tileObj.original[side]), false, connectedTiles, restoreClipped);
      }
    };
    if (firstCall) return connectedTiles;
  }
  function playClippingSound() {
    for (const option of selected.clip) {
      // new option
      if (!clipOptionsBefore || !JSON.stringify(clipOptionsBefore).includes(JSON.stringify(filter([option], true, true)[0]))) {
        if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseDown%20(click)_V3.mp3').play();
        clipOptionsBefore = (filter(selected.clip, true, true));
        if (vibrate.checked) window.navigator.vibrate(33);
        if (tutorial.state == "getClippingOptionConnectTileTutorial") goTutorialSteps(1);
      }
    }
    if (clipOptionsBefore) {
      for (const option of clipOptionsBefore) {
        if (!JSON.stringify(filter(selected.clip, true, true)).includes(JSON.stringify(option))) {
          if (clipOptionsSound.checked) new Audio('https://adi.nicolaiweitkemper.de/Sounds/mouseUp%20(click).mp3').play();
          clipOptionsBefore = (filter(selected.clip, true, true));
          if (vibrate.checked) {
            setTimeout(function () {
              window.navigator.vibrate(27);
            }, 100);
          }
          if (tutorial.state == "clipTileTutorial") goTutorialSteps(-1);
        }
      }
    }
  }
  // remove sI out of the entered obj
  function filter(clipOptions, sI, distance) {
    var stored = JSON.parse(JSON.stringify(clipOptions));
    for (const elm of stored) {
      if (sI) delete elm.sI;
      if (distance) delete elm.distance;
    }
    return stored;
  }
  var clipOptionsBefore;
  // checks collision of tiles with the clip options marker
  function selectedCollidesOthers(pClip,  tile) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (collides(transformToObj(i), addTolerance(pClip, 3)).boolean && !tileSelectionBar.tiles.includes(i) && !selected.tiles.includes(i) && tile != i) {
        return true;
      }
    }
  }
  var checkedTiles = [];
  // checks if selected tiles collide tiles which are (connected to) tiles you want to clip to
  function selectedCollideOther(pClipIndex) {
    var connected = getConnectedTiles(pClipIndex, true);
    for (const clipIndex of connected) {
      for (const tile of selected.tiles) {
        if (collides(transformToObj(clipIndex, 3), transformToObj(tile, 3)).boolean) {
          return true;
        }
      }
    }
  }
  // checks collision between clip marker and tiles on top of c.clipI (tile you want to clip to)
  function clipCollidesLowerTile(clip) {
    var clipIReached = false;
    for (const position of positions.layoutOrder.filter(x => !selected.tiles.includes(x))) {
      if (position == clip.i) clipIReached = true;
      else if (clipIReached && collides(clip, transformToObj(position, 3)).boolean && collideClip.checked) {
        return true;
      }
    }
  }
  var clipped = [];
  function collides(a, b) {
    try {
      return {boolean: !(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        ), area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)};

    } catch (e) {
      console.log('err: ' + e);
    }
  }
  // checks if potentiallySelected collides with any other tile (not used anymore due to more advanced collision detection (TODO: optional?))
  function selectedCollides(potentiallySelected) {
    for (var tile of selected.tiles) {
      if (collides(transformToObj(tile), transformToObj(potentiallySelected)).boolean) return tile;
    }
  }
  // transforms index of tile into an obj that can be used for collision checks (tolerance can be added)
  function transformToObj(i, tolerance) {
    pLengthPerTeil = JSON.parse(JSON.stringify(lengthPerTeil));
    if ([90, 270].includes(positions.wrong[i].original.degree)) {
      pLengthPerTeil.edit.x = lengthPerTeil.edit.y;
      pLengthPerTeil.edit.y = lengthPerTeil.edit.x;
    }
    var obj =  positions.wrong[i].edit;
    if (!tolerance) tolerance = 0;
    return {x: obj.x + tolerance, y: obj.y + tolerance, width: pLengthPerTeil.edit.x - tolerance*2, height: pLengthPerTeil.edit.y - tolerance*2};
  }
  // adds tolerance by decreacing the size of the entered hitbox (obj)
  function addTolerance(obj, tolerance) {
    return {...obj, x: obj.x + tolerance, y: obj.y + tolerance, width: obj.width - tolerance*2, height: obj.height - tolerance*2};
  }
  // returns the index of the tile which has the entered original coordinates
  function getTile(originalCoord) {
    for (var i = 0; i < positions.wrong.length; i++) {
      if (positions.wrong[i].original.x == originalCoord.x && positions.wrong[i].original.y == originalCoord.y) return i;
    };
  }
  // exchanges two tiles (positions)
  function vertauscheZwei(i, i1) {
    var ablage = JSON.parse(JSON.stringify(positions.wrong[i].edit));
    positions.wrong[i].edit = JSON.parse(JSON.stringify(positions.wrong[i1].edit));
    positions.wrong[i1].edit = JSON.parse(JSON.stringify(ablage));
    if (positions.wrong[i1].edit == undefined) positions.wrong.splice(i1, 1);
  }
  // returns the coordinates of a selected tile (schieben and exchange mode)
  function checkSelected(removeTile) {
    // try {
        for (var i = 0; i < anzahlX.value; i++) {
          for (var i1 = 0; i1 < anzahlY.value; i1++) {
            if ((removeTile && mausx > lengthPerTeil.edit.x*i + 3*i && mausx < lengthPerTeil.edit.x*(i + 1) + 3*(i + 1) && mausy > lengthPerTeil.edit.y*i1 + 3*(i1) && mausy < lengthPerTeil.edit.y*(i1 + 1) + 3*(i1 + 1)) || (lengthPerTeil.edit && !removeTile && mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1))) {
              return {x: i, y: i1};
            }
            // if (!removeTile && mausx > lengthPerTeil.edit.x*i && mausx < lengthPerTeil.edit.x*(i + 1) && mausy > lengthPerTeil.edit.y*i1 && mausy < lengthPerTeil.edit.y*(i1 + 1)) return {x: i, y: i1};
          }
        }
  // } catch (e) {
  //   console.log("pleaseDebug :)");
  // }
  }

// section 7: stop clock:
var stopClock = {viewOriginal: {time: 0, running: 0}, completionTime: {time: 0, running: 0}};
var time = 0;
var running = 0;

function startPause(type) {
if (stopClock[type].running == 0) {
  stopClock[type].running = 1;
  // time = 0;
  increment(type);
}
else {
  stopClock[type].running = 0;
}
}
function reset(type) {
running = 0;
timer = 0;
}
function increment(type) {
if (stopClock[type].running == 1) {
setTimeout(function () {
  stopClock[type].time++;
  var time = stopClock[type].time;
  var mins = Math.floor(time/10/60);
  var secs = Math.floor(time/10);
      secs -= 60*mins;
  var tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  if (type == "viewOriginal") stats[type].time = mins + ":" + secs + ":" + "0" + tenths;
  else stats[type] = mins + ":" + secs + ":" + "0" + tenths;
  increment(type);
}, 100);
}
}
// end section 7
function getSectionElm(elm) {
  while (elm.className != "tutorialCard tutorialGeneral section") {
    elm = elm.parentElement;
  }
  return elm;
}
function startTutorial(mode) {
  document.getElementById('tutorial').style.display = "inline";
  document.getElementById(mode + 'Tutorial').style.display = "inline";
  goTutorialSteps(0);
  if (mode == "traditional") {
    shuffleStyle.value = "listTiles";
    emptyTileBar.checked = true;
  }
  sourceURL.value = "https://adi.nicolaiweitkemper.de/Bilder/puzzleCreatorLogo.png";
  useURL();
  setTimeout(() => {
    create();
    shufflePuzzle();
    if (mode == "traditional") {
      for (const elm of document.getElementsByClassName('backToTileB')) {
        elm.style.display = "none";
      }
      tileSelectionCanvas.style.display = "none";
    }
  }, 500);
}
function goTutorialSteps(steps) {
  if (tutorial.state != "") document.getElementById(tutorial.state + 'Div').className = "";
  try {
    if (steps > 0)  {
      for (let i = 0; i < steps; i++) {
       document.getElementById(document.getElementById(modeSelection.value + 'Tutorial').querySelectorAll('input[type="checkbox"]')[tutorial.index + i].id).checked = true;
     }
     if (!angular.equals(getSectionElm(document.getElementById(tutorial.state + 'Div')), getSectionElm(document.getElementById(modeSelection.value + 'Tutorial').querySelectorAll('input[type="checkbox"]')[tutorial.index + steps]))) {
      getSectionElm(document.getElementById(tutorial.state + 'Div')).style.display = "none";
     }
  }
  if (steps < 0) {
      for (let i = tutorial.index - 1; i > tutorial.index + steps - 1; i--) {
       document.getElementById(document.getElementById(modeSelection.value + 'Tutorial').querySelectorAll('input[type="checkbox"]')[i].id).checked = false;
      }
    }
    tutorial.index += steps;
    tutorial.state = document.getElementById(modeSelection.value + 'Tutorial').querySelectorAll('input[type="checkbox"]')[tutorial.index].id;
    document.getElementById(tutorial.state + 'Div').className = "currentTutorialStep tutorialGeneral";
    if (tutorial.state == "scrollArrowTileBarTutorial") window.scroll(0, 0);
    if (tutorial.state == "scrollArrowTileBarTutorial") {
      for (const elm of document.getElementsByClassName('backToTileB')) {
        elm.style.display = "inline";
      }
      tileSelectionCanvas.style.display = "inline";
      for (var i = 0; i < 16; i++) {
        tileSelectionBar.tiles.splice(0, 0, i);
        unclipp(i);
        mouseDown();
      }
      scrollTileSelection(1);
    }
  }
  catch (err) {
    console.log('tutorial finished!');
    tutorial.state = "finished";
  }
}
</script>
