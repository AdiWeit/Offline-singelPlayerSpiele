<meta charset="utf-8">
<script src="https://adi.nicolaiweitkemper.de/Database2/js.js"></script>
<div id="settings">
<ul id="settingsL" font-size:30px></ul>
Breite<input type="text" onchange="verteilung.innerHTML = 'sie müssen noch ' + (JSON.parse(breite.value)*JSON.parse(hoehe.value) - JSON.parse(anzahlGeraden.value) - JSON.parse(anzahlPuffer.value) - JSON.parse(anzahlWeichen.value) - JSON.parse(anzahlKurven.value)) + ' Segment(e) verteilen, damit so viele Segmente wie die Höhe und Breite hergeben vorhanden sind.'" id="breite" value="7">
<br>
Höhe<input type="text" onchange="verteilung.innerHTML = 'sie müssen noch ' + (JSON.parse(breite.value)*JSON.parse(hoehe.value) - JSON.parse(anzahlGeraden.value) - JSON.parse(anzahlPuffer.value) - JSON.parse(anzahlWeichen.value) - JSON.parse(anzahlKurven.value)) + ' Segment(e) verteilen, damit so viele Segmente wie die Höhe und Breite hergeben vorhanden sind.'" id="hoehe" value="7">
<br>
anzahl Geraden<input id="anzahlGeraden" onchange="verteilung.innerHTML = 'sie müssen noch ' + (JSON.parse(breite.value)*JSON.parse(hoehe.value) - JSON.parse(anzahlGeraden.value) - JSON.parse(anzahlPuffer.value) - JSON.parse(anzahlWeichen.value) - JSON.parse(anzahlKurven.value)) + ' Segment(e) verteilen, damit so viele Segmente wie die Höhe und Breite hergeben vorhanden sind.'" type="text" value="16">
<br>
anzahl Puffer<input id="anzahlPuffer" onchange="verteilung.innerHTML = 'sie müssen noch ' + (JSON.parse(breite.value)*JSON.parse(hoehe.value) - JSON.parse(anzahlGeraden.value) - JSON.parse(anzahlPuffer.value) - JSON.parse(anzahlWeichen.value) - JSON.parse(anzahlKurven.value)) + ' Segment(e) verteilen, damit so viele Segmente wie die Höhe und Breite hergeben vorhanden sind.'" type="text" value="2">
<br>
anzahl Bahnhöfe<input id="anzahlBahnhoefe" type="text" value="1">
<br>
anzahl Kurven<input id="anzahlKurven" onchange="verteilung.innerHTML = 'sie müssen noch ' + (JSON.parse(breite.value)*JSON.parse(hoehe.value) - JSON.parse(anzahlGeraden.value) - JSON.parse(anzahlPuffer.value) - JSON.parse(anzahlWeichen.value) - JSON.parse(anzahlKurven.value)) + ' Segment(e) verteilen, damit so viele Segmente wie die Höhe und Breite hergeben vorhanden sind.'" type="text" value="24">
<br>
anzahl Weichen<input id="anzahlWeichen" onchange="verteilung.innerHTML = 'sie müssen noch ' + (JSON.parse(breite.value)*JSON.parse(hoehe.value) - JSON.parse(anzahlGeraden.value) - JSON.parse(anzahlPuffer.value) - JSON.parse(anzahlWeichen.value) - JSON.parse(anzahlKurven.value)) + ' Segment(e) verteilen, damit so viele Segmente wie die Höhe und Breite hergeben vorhanden sind.'" type="text" value="7">
<h2 id="verteilung"></h2>
<br>
auch beim Test rotieren<input id="rotateInRound" type="checkbox">
<br>
<button type="button" onclick="createField();" name="button">create field</button>
</div>
<canvas id="textur" onclick="canvasClicked();" width="1800" height="700"></canvas>
<br>
<h1 id="nameEingeloggt" onclick='name = prompt ("Mit welchem Namen wollen sie sich eingloggen?"); nameEingeloggt.innerHTML = "als " + name + " eingeloggt"; getDatabase(undefined, true);'></h1>
<br>
<button type="button" id="test" onclick="inRound = true; if (innerHTML == 'test') {innerHTML = 'beende test'; moveTrain();} else {resetTrain();} " name="button">test</button>
<script>
  var canvas = textur.getContext('2d');
  var fields = [
      { // gerade
        wallStructure: [
          {
            type: "wall",
            number: 3
          },
          {
            type: "way",
            number: 3,
          },
          {
            type: "wall",
            number: 3
          }
        ],
        number: 16
      },
      /*{ // Bahnhof
        wallStructure: [
          {
            type: "bahnsteig",
            number: 3,
            done: false
          },
          {
            type: "wall",
            number: 6,
          }
        ],
        number: 2
      },*/
      { // Puffer
        wallStructure: [
          {
            type: "wall",
            number: 3
          },
          {
            type: "way",
            number: 2,
          },
          {
            type: "wall",
            number: 4
          }
        ],
        number: 2
      },
      {
        wallStructure: [
          { // Kurve
            type: "wall",
            number: 4
          },
          {
            type: "way",
            number: 2,
          },
          {
            type: "wall",
            number: 1
          },
          {
            type: "way",
            number: 1,
          },
          {
            type: "wall",
            number: 1
          }
        ],
        number: 24
      },
      {
        wallStructure: [
          { // Weiche
            type: "wall",
            number: 1
          },
          {
            type: "way",
            number: 1,
            active: true
          },
          {
            type: "wall",
            number: 1
          },
          {
            type: "way",
            number: 2,
            active: true
          },
          {
            type: "way",
            number: 1,
            active: false
          },
          {
            type: "wall",
            number: 3
          }
        ],
        number: 7
      }

  ]
  if (!localStorage.getItem("storedName")) var name = prompt("Bitte geben sie ihren (spitz) Namen ein, um ihre Highscores speichern zu können");
  else var name = localStorage.getItem("storedName");
  localStorage.setItem("storedName", name);
  nameEingeloggt.innerHTML = "als " + name + " eingeloggt"
  getDatabase();
  function getDatabase(pReturn) {
    dbGet("helpTheTrain", "highscores").then(result => {
      highscores = result;
      for (var i = 0; i < Object.keys(highscores).length; i++) {
        var li = document.createElement("li");
        li.appendChild(document.createTextNode(Object.keys(highscores)[i]));
         li.setAttribute("onclick", "changeSetings(innerHTML)");
        document.getElementById("settingsL").appendChild(li);
      }
      if (pReturn) saveHighscore();
    }).catch(function(e) {
      if (pReturn) saveHighscore();
    });
  }
  function changeSetings(innerHTML) {
    rotateInRound.checked = JSON.parse(innerHTML.toString().split("bei Test rotieren: ")[1]);
    createField(true, innerHTML);
  }
  var field = [];
  var bahnhoefe = {verbleibend: 1, collected: 0, all: 1};
  var highscores = {};
  function createField(restore, selected) {
    selectedSettings = "breite: " + breite.value + ", höhe: " + hoehe.value + ", Anzahl Kurven: " + anzahlKurven.value + ", Anzahl Weichen: " + anzahlWeichen.value + ", Anzahl Geraden: " + anzahlGeraden.value + ", Anzahl Puffer: " + anzahlPuffer.value + ", Anzahl Bahnhoefe: " + anzahlBahnhoefe.value + ", bei Test rotieren: " + rotateInRound.checked;
    if (restore) field = highscores[selected].data.field
    if (!restore && Object.keys(highscores).includes(selectedSettings) && confirm("Diese Einstelungen wurden bereits von jemandem getroffen! Sie können das Level mit den Einstellungen spielen. Wollen sie dennoch ein neues Level mit den selben Einstellungen erstellen?")) {
      for (var i = 0; i < Object.keys(highscores).includes(selectedSettings); i++) {
        selectedSettings += "|";
      }
    }
    else if (!restore && Object.keys(highscores).includes(selectedSettings)) {
      return "cancel";
    }
    fields[0].number = JSON.parse(anzahlGeraden.value);
    fields[1].number = JSON.parse(anzahlPuffer.value);
    fields[2].number = JSON.parse(anzahlKurven.value);
    fields[3].number = JSON.parse(anzahlWeichen.value);
    for (var i = 0; !restore && i < JSON.parse(breite.value); i++) {
    field[i] = [];
    for (var i1 = 0; i1 < JSON.parse(hoehe.value); i1++) {
      field[i][i1] = newField(i);
    }
  }
  selectedField = JSON.parse(JSON.stringify(field));
  settings.style.display = "none";
  Layout();
  zuege = 0;
  }
var train = {spawnPoint: {x: 0, y: 0, i2: 1, i3: 1}, position: {x: 0, y: 0, i2: 1, i3: 1}, direction: "right"};
function newField(pI) {
  var newField = {};
  var possibleStructure = [];
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].number > 0) possibleStructure.push(i);
  }
  var selectedStructure = possibleStructure[Math.round(Math.random() *(possibleStructure.length - 1))];
  var i2 = 0;
  var i3 = 0;
  // try {
  //   console.log(fields[selectedStructure].wallStructure);
  // } catch (e) {
  //   console.log("please debug ;) ");
  // }
  for (var i = 0; i < fields[selectedStructure].wallStructure.length; i++) {
    for (var i1 = 0; i1 < fields[selectedStructure].wallStructure[i].number; i1++) {
      if (!newField[i2]) newField[i2] = [];
      newField[i2][i3] = {type: fields[selectedStructure].wallStructure[i].type};
      if (fields[selectedStructure].wallStructure[i].active != undefined) newField[i2][i3].active = fields[selectedStructure].wallStructure[i].active;
      i2++;
      if (i2 == 3) {i2 = 0; i3++;}
    }
  }
  for (var i2 = 0; i2 < 3; i2++) {
    for (var i3 = 0; i3 < 3; i3++) {
      if (pI > 0 && newField[i2][i3].type == "wall" && bahnhoefe.verbleibend > 0 && Math.round(Math.random() *(100)) < 10 && ((newField[i2 - 1] && newField[i2 - 1][i3].type == "way") || (newField[i2 + 1] && newField[i2 + 1][i3].type == "way") || (newField[i2][i3 - 1] && newField[i2][i3 - 1].type == "way") || (newField[i2][i3 + 1] && newField[i2][i3 + 1].type == "way"))) {
        newField[i2][i3].collected = false;
        bahnhoefe.verbleibend--;
      }
    }
  }
  fields[selectedStructure].number--;
  for (var i = 0; (i < Math.round(Math.random() * 11)); i++) {
    if ((Math.round(Math.random() *1) == 0)) newField = turn("right", newField);
    else newField = turn("left", newField);
  }
  return newField
}
function turn(direction, officialCard) {
zuege++;
var newField = {0: [], 1: [], 2: []};
newField[1][1] = officialCard[1][1];
if (direction == "right") {
  for (var i = 0; i < 3; i++) { // rechts --> unten works!
    newField[i][2] = officialCard[2][i];
  }
  for (var i = 0; i < 3; i++) { // unten --> links  works!
    newField[0][i] = officialCard[1 - 1 + i][1 + 1];
  }
  for (var i = 0; i < 3; i++) { // oben --> rechts works!
    newField[2][i] = officialCard[i][0];
  }
  var i1 = 0;
  for (var i = 2; i > -1; i--) { // links --> oben works!
    newField[i1][0] = officialCard[0][i];
    i1++;
  }
}
else {
  for (var i = 2; i > -1; i--) { // rechts --> oben
    newField[i][0] = officialCard[2][i];
  }
  var i1 = 0;
  for (var i = 3; i > 0; i--) { // unten --> rechts
    newField[2][i - 1] = officialCard[i1][2];
    i1++;
  }
  var i1 = 0;
  for (var i = 3; i > 0; i--) { // oben --> links
    newField[0][i1] = officialCard[i - 1][0];
    i1++;
  }
  for (var i = 0; i < 3; i++) { // links --> unten
    newField[i][2] = officialCard[0][i];
  }
}

return newField;
}
function Layout(times) {
  textur.height = JSON.parse(hoehe.value)*3*50 + 10 + 50;
  textur.width = JSON.parse(breite.value)*3*50 + 10 + 50;
  if (!times) times = 0;
  for (var i = 0; i < JSON.parse(breite.value); i++) {
    for (var i1 = 0; i1 < JSON.parse(hoehe.value); i1++) {
      displayCard(field, i, i1, 10 + 50*3*i, 10 + 50*3*i1, times);
    }
  }
  /*if (times < 5) {
    setTimeout(function () {
      Layout(times + 1);
    }, 70);
  }*/
  canvas.fillStyle = "red";
  canvas.fillRect((JSON.parse(breite.value)*3*50)/ 2 + 10, JSON.parse(hoehe.value)*3*50 + 10, 40, 40);
  canvas.fillRect(10 + train.position.x*50*3 + train.position.i2*50 + 5, 10 + 50*3*train.position.y + train.position.i3*50 + 5, 40, 40);
}

function displayCard(field, i, i1, startx, starty, times) {
  canvas.globalAlpha = 1;//0.5
  if (isNaN(times)) canvas.globalAlpha = 0.5;
  for (var i2 = 0; i2 < 3; i2++) {
    for (var i3 = 0; i3 < 3; i3++) {
      if (field[i][i1][i2][i3].type == "wall") canvas.fillStyle = "brown";
      else if (field[i][i1][i2][i3].type == "way") canvas.fillStyle = "gray";
      if (field[i][i1][i2][i3].type == "wall" && field[i][i1][i2][i3].collected === false) canvas.fillStyle = "red";
      if (field[i][i1][i2][i3].type == "wall" && field[i][i1][i2][i3].collected === true) canvas.fillStyle = "#40FF00";
      fillField(i2, i3, startx, starty);
      if (field[i][i1][i2][i3].active) {
         canvas.globalAlpha = 0.4;
        canvas.fillStyle = "green";
        fillField(i2, i3, startx, starty);
         canvas.globalAlpha = 1;
      }
    }
  }
}
function fillField(i2, i3, startx, starty) {
  if ((i2 == 2 && i3 == 2)) canvas.fillRect(startx + 50*i2, starty + 50*i3, 45, 45);
  else if (i2 == 2) canvas.fillRect(startx + 50*i2, starty + 50*i3, 45, 50);
  else if (i3 == 2) canvas.fillRect(startx + 50*i2, starty + 50*i3, 50, 45);
  else/* (i2 != 2 && i3 != 2)*/ canvas.fillRect(startx + 50*i2, starty + 50*i3, 50, 50);
}
var xMaus;
var yMaus;
document.onmousemove = readMouseMove
function readMouseMove(e) {
  xMaus = e.clientX + scrollX //- 10;
  yMaus = e.clientY + scrollY //+ 23//- 33;
  //    console.log(xMaus + " - " + yMaus);
  canvas.fillStyle = "red";
  if (selected.type == "train") {Layout(5); canvas.fillRect(xMaus, yMaus, 40, 40);}
}
function canvasClicked() {
  for (var i = 0; i < JSON.parse(breite.value); i++) {
  for (var i1 = 0; i1 < JSON.parse(hoehe.value); i1++) {
    // 10 + 50*3*i, 10 + 50*3*i1
    for (var i2 = 0; i2 < 3; i2++) {
      for (var i3 = 0; i3 < 3; i3++) {
        // if (xMaus > 10 + 50*i2*i && xMaus < 10 + 50*i2*i  + 130 && yMaus > 10 + 50*i3*i1  && yMaus < 10 + 50*i3*i1  + 130 && player.movement == "movingPlayer" && checkMovementPossibe(player.movingPlayer.x, player.movingPlayer.y, player.movingPlayer.i2, player.movingPlayer.i3)) {
        //       field[i][i1][i2][i3].player = player.myNumber
        //       field[player.movingPlayer.x][player.movingPlayer.y][i2][i3].player = false;
        //     }
        if ((/*gerät == "PC" && */xMaus > 10 + 50*3*i + 50*i2 && xMaus < 10 + 50*3*i + 50*i2 + 50 && yMaus > 10 + 50*3*i1 + 50*i3 && yMaus < 10 + 50*3*i1 + 50*i3 + 50) /*|| (gerät == "Handy" && xMaus > 10 + 50*3*i + 50*i2 && xMaus < 10 + 50*3*i + 50*i2 + 50 && yMaus - scrollY > 10 + 50*3*i1 + 50*i3 && yMaus - scrollY < 10 + 50*3*i1 + 50*i3 + 50)*/) {
          console.log(i + "- " + i1 + " - " + i2 + " - " + i3);
          if (i == train.spawnPoint.x && i1 == train.spawnPoint.y && i2 == train.spawnPoint.i2 && i3 == train.spawnPoint.i3) selected.type = "train";
          else if (selected.type != "train") {
          if (field[i][i1][i2][i3].active) { // weiche stellen
            // weiche noch nicht gestellt (Ausgangszustand)
            if (!field[i][i1].straight) {
            if ((!field[i][i1][0][1].active && field[i][i1][0][1].type == "way")/*Weiche nach unten -*/) {field[i][i1][0][1].active = true; field[i][i1][1][2].active = false;}
            else if ((!field[i][i1][2][1].active && field[i][i1][2][1].type == "way")/*Weiche nach oben -*/) {field[i][i1][2][1].active = true; field[i][i1][1][0].active = false;}
            else if ((!field[i][i1][1][2].active && field[i][i1][1][2].type == "way")/*Weiche nach rechts -*/) {field[i][i1][1][2].active = true; field[i][i1][2][1].active = false;}
            else if ((!field[i][i1][1][0].active && field[i][i1][1][1].type == "way")/*Weiche nach links*/) {field[i][i1][1][0].active = true; field[i][i1][0][1].active = false;}
            field[i][i1].straight = true;
          }
          else {
            if ((!field[i][i1][1][2].active && field[i][i1][1][2].type == "way")/*Weiche nach unten -*/) {field[i][i1][0][1].active = false; field[i][i1][1][2].active = true;}
            else if ((!field[i][i1][1][0].active && field[i][i1][1][0].type == "way")/*Weiche nach oben -*/) {field[i][i1][2][1].active = false; field[i][i1][1][0].active = true;}
            else if ((!field[i][i1][2][1].active && field[i][i1][2][1].type == "way")/*Weiche nach rechts -*/) {field[i][i1][1][2].active = false; field[i][i1][2][1].active = true;}
            else if ((!field[i][i1][0][1].active && field[i][i1][0][1].type == "way")/*Weiche nach links*/) {field[i][i1][1][0].active = false; field[i][i1][0][1].active = true;}
            field[i][i1].straight = false;
          }
        }
          else if (!inRound || rotateInRound.checked) field[i][i1] = turn("right", field[i][i1]);
          Layout();
        }
        else if (field[i][i1][i2][i3].type == "way" && i == 0) {
          train.spawnPoint = {x: 0, y: i1, i2: i2, i3: i3};
          train.position = JSON.parse(JSON.stringify(train.spawnPoint));
          selected.type = "";
        }
      }
      }
    }
  }
}
// (7*3*50)/ 2 + 10, 7*3*50 + 10, 40, 40
if (xMaus > (JSON.parse(breite.value)*3*50)/ 2 + 10 && xMaus < (JSON.parse(breite.value)*3*50)/ 2 + 10 + 40 && yMaus > JSON.parse(hoehe.value)*3*50 + 10 && yMaus < JSON.parse(hoehe.value)*3*50 + 10 + 40) selected.type = "train";
}
var selected = {type: ""};
var inRound = false;
function moveTrain() {
  var possibleDirections = [];
  var downIncluded = false;
  if (train.direction != "left" && isTrack(train.position.x, train.position.y, train.position.i2 + 1, train.position.i3).boolean) {possibleDirections.push({track: isTrack(train.position.x, train.position.y, train.position.i2 + 1, train.position.i3).position, direction: "right"});}
  if (train.direction != "right" && isTrack(train.position.x, train.position.y, train.position.i2 - 1, train.position.i3).boolean) {possibleDirections.push({track: isTrack(train.position.x, train.position.y, train.position.i2 - 1, train.position.i3).position, direction: "left"});}
  if (train.direction != "up" && isTrack(train.position.x, train.position.y, train.position.i2, train.position.i3 + 1).boolean) {possibleDirections.push({track: isTrack(train.position.x, train.position.y, train.position.i2, train.position.i3 + 1).position, direction: "down"}); downIncluded = true;}
  if (train.direction != "down" && isTrack(train.position.x, train.position.y, train.position.i2, train.position.i3 - 1).boolean) {possibleDirections.push({track: isTrack(train.position.x, train.position.y, train.position.i2, train.position.i3 - 1).position, direction: "up"});}
  if (downIncluded) {train.direction = "down"; train.position = JSON.parse(JSON.stringify(isTrack(train.position.x, train.position.y, train.position.i2, train.position.i3 + 1).position));}
  else if (possibleDirections.length == 0) {console.log("Puffer or wall reached!"); changeDirection();}
  else {train.position = JSON.parse(JSON.stringify(possibleDirections[0].track)); train.direction = possibleDirections[0].direction}
  Layout();
  setTimeout(function () {
    if (inRound) moveTrain();
  }, 90);
}
var zuege = 0;
function isTrack(i, i1, i2, i3) {
  var transform = false;
  if (i2 == 3) {i2 = 0; i++; transform = true;}
  if (i3 == 3) {i3 = 0; i1++; transform = true;}
  if (i2 == -1) {i2 = 2; i--; transform = true;}
  if (i3 == -1) {i3 = 2; i1--; transform = true;}
  try {
  if (field[i][i1][i2][i3].collected === false) {
    field[i][i1][i2][i3].collected = true;

    bahnhoefe.collected++;
  }
    return {boolean: (field[i][i1][i2][i3].type == "way" && (field[i][i1][i2][i3].active == undefined || field[i][i1][i2][i3].active == true || transform)), position: {x: i, y: i1, i2: i2, i3: i3}};
  } catch (e) {
    console.log("turning, because edge reached");
    if (bahnhoefe.collected == bahnhoefe.all && i == JSON.parse(breite.value)) {
      console.log("finished!");
      alert("Sie haben es in " + zuege + " Zügen geschafft!");
      getDatabase(true);
    }
    return {boolean: false};
    changeDirection();
  }
}
var selectedSettings;
function saveHighscore() {
  if (!highscores[selectedSettings]) highscores[selectedSettings] = {data: {field: selectedField}, highscores: {}};
  if (!highscores[selectedSettings].highscores[name] || highscores[selectedSettings][name] > zuege) {
    if (highscores[selectedSettings].highscores[name] > zuege) alert("So wenig Züge haben sie noch nie gebraucht!");
    highscores[selectedSettings].highscores[name] = zuege;
    dbSetWarteschlange.push({tag: "highscores", data: highscores});
  }
  resetTrain();
}
var selectedField = [];
var dbSetWarteschlange = [];
setInterval(function () {
  if (dbSetWarteschlange.length > 0) {
    dbSet("helpTheTrain", dbSetWarteschlange[0].tag, dbSetWarteschlange[0].data);
    dbSetWarteschlange.shift();
  }
}, 2222);
function changeDirection() {
  var oppositeDirection = {right: "left", left: "right", down: "up", up: "down"};
  train.direction = oppositeDirection[train.direction];
}
function resetTrain() {
  inRound = false;
  train.position = JSON.parse(JSON.stringify(train.spawnPoint));
  zuege = 0;
  bahnhoefe = {verbleibend: bahnhoefe.collected, collected: 0, all: bahnhoefe.collected};
  test.innerHTML = 'test';
  for (var i = 0; i < field.length; i++) {
    for (var i1 = 0; i1 < field[0].length; i1++) {
      for (var i2 = 0; i2 < 3; i2++) {
        for (var i3 = 0; i3 < 3; i3++) {
          if (field[i][i1][i2][i3].collected === true) field[i][i1][i2][i3].collected = false;
        }
      }
    }
  }
  field = JSON.parse(JSON.stringify(selectedField))
  Layout();
}
</script>
