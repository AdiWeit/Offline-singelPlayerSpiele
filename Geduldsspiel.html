<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://adi.nicolaiweitkemper.de/Database2/js.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<html>

<head>
  <div id="deviceMotionControlRequestDiv" style="width: 200%; height: 200%; position: absolute; background-color: rgba(128, 128, 128, 0.389);  display: none;">
    <button onclick="requestMotionControlPermission()" style="font-size: 10em; width: 100%; height: 100%; position: fixed; z-index: 2;" >allow device motion controls</button>
  </div>
  <title>game of patience (Chinese puzzle)</title>
  <div>
    <h1 id="stopClockText" style="color: green; background-color: rgba(205, 218, 199, 0.27); border-radius: 5px; position: absolute; left: 13px; top: 13px;"></h1>
  </div>
  <canvas id="textur" style="border-width: 3px; border-style: solid; border-color: orange;" onclick="canvasClicked();"></canvas>
  <meta name="viewport" id="scaleControler">
  <div id="ball">
    <style>
      .shape {
   position: absolute;
   width: 50px;
   height: 50px;
   -webkit-radius: 50px;
   margin:0;
   padding:0;
  }
  #sphere1{
   border-radius: 50px;
   background-color: blue;
  }
  </style>
  </div>
</head>

<body>
  <div id="content">
    <div class="shape" id="sphere1"></div>
  </div>
  <br>
  <head>
    <style>
      table, td {
        border: 1px solid black;
      }
      .card {
      box-shadow: 2px 2px 10px #855d5d;
      padding-top: 5px;
      padding-bottom: 5px;
      margin-top: 7px;
      margin-bottom: 7px;
      /* display: none; */

      border-radius: 10px;
      padding-left: 10px;
      padding-right: 10px;
    }
</style>
  </head>
  <div id="randomMapCreator" class="card" style="display: none;">
    <div class="card">
    <b>add/delete elements</b>
    <br>
    <button onclick="createRandomMap();">create/extend</button>
    <button onclick="deleteAllElements();">delete all objects</button>
    <button onclick="removeElement();">delete selected element</button>
    <br>
    <button id="addRectangle" onclick="exchange = {'rgb(0, 251, 255)': '', '': 'rgb(0, 251, 255)'}; style.backgroundColor = exchange[style.backgroundColor]; addCircle.style.backgroundColor = ''; addTriangle.style.backgroundColor = '';">add rectangles</button>
    <button id="addTriangle" onclick="exchange = {'rgb(0, 251, 255)': '', '': 'rgb(0, 251, 255)'}; style.backgroundColor = exchange[style.backgroundColor]; addCircle.style.backgroundColor = ''; addRectangle.style.backgroundColor = ''">add triangles</button>
    <button id="addCircle" onclick="exchange = {'rgb(0, 251, 255)': '', '': 'rgb(0, 251, 255)'}; style.backgroundColor = exchange[style.backgroundColor]; addRectangle.style.backgroundColor = ''; addTriangle.style.backgroundColor = ''">add circles</button>
  </div>
  <div class="card">
    <b>edit elements</b>
    <br>
    <div id="rotateElement">
      <button id="rotateLeft" onclick="rotateObj(-1);">↶</button>
      <button id="rotateRight" onclick="rotateObj(1);">↷</button>
    </div>
    <div style="display: none;" id="objSizeSetting">
      <!-- TODO: ausgewählte slider (oninput beachtet Klicken nicht) sticky, sodass er unten im Screen bleibt -->
      width <input type="range" id="elmWidth" class="custom_small_slider" oninput="changeObjSize('width', value);" min="5"> 
      <!-- <div class="form">
        <input type="number" placeholder=" " style="width: 94px;" class="form_input" value="747" oninput="selected.obj.width = Number(value); selected.obj.hitbox = calculateHitbox('rectangle', selected.obj); selected.obj.middle = calculateMiddle('rectangle', selected.obj); selected.obj.path = calculatePath('rectangle', selected.obj); " id="elmWidth" min="0">
        <label for="input" class="form_label" onclick="selectTextBox(this);">width</label>
      </div> -->
      height <input type="range" id="elmHeight" class="custom_small_slider" oninput="changeObjSize('height', value)" min="5">
      <!-- <div class="form">
        <input type="number" placeholder=" " style="width: 94px;" class="form_input" value="747" oninput="selected.obj.height = Number(value); selected.obj.hitbox = calculateHitbox('rectangle', selected.obj); selected.obj.middle = calculateMiddle('rectangle', selected.obj); selected.obj.path = calculatePath('rectangle', selected.obj);" id="elmHeight" min="0">
        <label for="input" class="form_label" onclick="selectTextBox(this);">height</label>
      </div> -->
    </div>
      <br>
      <div id="elmRadius" class="form" style="display: none;">
        radius <input type="range" id="inputRadius" class="custom_small_slider" oninput="selected.obj.radius = Number(value); selected.obj.hitbox = calculateHitbox('circle', selected.obj);" min="5">
        <!-- <input type="number" placeholder=" " id="inputRadius" oninput="selected.obj.radius = Number(value); selected.obj.hitbox = calculateHitbox('circle', selected.obj);" style="width: 94px;" class="form_input" value="747" onchange="handleMaxSizeSlider();" min="0">
        <label for="input" class="form_label" onclick="selectTextBox(this);">radius</label> -->
      </div>
    <a id="rotateTileA" style="display: none;"><input id="rotateTile" onchange="if (selected.type != 'circles') changeIfRotates(checked);" type="checkbox"> rotate tile</a>
    <div id="rotateSettings" class="card" style="display: none;">
      <b>rotation settings</b>
      <br>
      rotation speed 
      <br>
      <input min="1000" max="60000" id="miliSecPerRotationNumber" oninput="changeRotateParam('miliSecsPerRotation', parseInt(value));" value="10000" type="range" class="custom_small_slider">
      <!-- <br> -->
      <!-- TODO: reaktivieren bei Objekten bestehend aus Punkten -->
      <a style="display: none;">scale in relation to the original object (1 = 100%): <input oninput="changeRotateParam('sizeRelationToOriginal', parseFloat(value));" value="1" step="0.01" id="rotatingRandomObjScale" type="number"></a>
      <!-- <br> -->
      starting angle: 
      <br>
      <!-- TODO: reset and pause level for a short time -->
      <input oninput="changeRotateParam('angle', parseInt(value));" class="custom_small_slider" min="0" max="360" value="0" id="rotatingRandomObjStartingAngle" type="range">
    </div>
  </div>
  <div class="card">
    <b>import/export</b>
    <br>
    <button onclick="exportLevel();"><b>export</b></button>
    <input type="file" id="fileSelector" accept=".json" style="display: none;" onchange="importLevel(this);"></input>
    <button onclick="fileSelector.click();"><b>import</b></button>
  </div>
  <div id="generalLevelSettings" class="card">
    <b>general level settings</b>
    <br>
    <div class="card">
      <b>set spawnpoint (click to set the position after clicking the button)</b>
      <br>
      <button id="setSchieberSpawnPoint" onclick="style.backgroundColor = '#00fbff';" style="border-radius: 2px; border-style: solid; border-color: blue;">set blue ball spawnpoint</button>
    </div>
    <!-- <input type="number" style="width: 44px;" id="squareAmount" min="0"> Anzahl Quadrate
  <br> -->
  <div class="card">
    <div class="form">
      <input type="number" style="width: 90px;" autocomplete="off" placeholder=" " class="form_input" value="1520" onchange="handleMaxSizeSlider();" id="canvasWidth" min="0">
      <label for="input" class="form_label" onclick="selectTextBox(this);">level width</label>
    </div>
    <br>
    <div class="form">
      <input type="number" placeholder=" " style="width: 94px;" class="form_input" value="747" onchange="handleMaxSizeSlider();" id="canvasHeight" min="0">
      <label for="input" class="form_label" onclick="selectTextBox(this);">level height</label>
    </div>
    <br>
    <div class="form">
      <input type="number" placeholder=" " style="width: 219px;" class="form_input" value="66" onchange="handleMaxSizeSlider();" id="minimalDistance" min="0">
      <label for="input" class="form_label" onclick="selectTextBox(this);">minimal distance between objects</label>
    </div>
  </div>
  <div class="card">
    <b>goal side</b>
    <br>
    <input id="goalTop" onchange="goalSideChanged();" name="goalSide" type="radio">top
    <br>
    <input id="goalLeft" onchange="goalSideChanged();" name="goalSide" type="radio">left
    <input id="goalRight" onchange="goalSideChanged();" checked="true" name="goalSide" type="radio">right
    <br>
    <input id="goalBottom" onchange="goalSideChanged();" name="goalSide" type="radio">bottom
  </div>
  <div id="ballSettings" class="card">
    <b>ball size:</b> 
    <br>
    <div id="ballSizeSettings" class="card">
      <b>blue ball:</b> 
      <br>
      width: 
      <input id="ballWidthSlider" oninput="sphere1.style.width = value + 'px'; y1 = ballSizeSettings.getBoundingClientRect().top + scrollY;" type="range" min="1" max="100">
      <br>
      height: 
      <input id="ballHeightSlider" oninput="sphere1.style.height = value + 'px'; y1 = ballSizeSettings.getBoundingClientRect().top + scrollY;" type="range" min="1" max="100">
    </div>
  </div>
  <div class="card">
    create new level when goal reached: <input id="newRandomLevelAfterGoal" onchange="if (checked) newRandomLevelOnGoalSettings.style.display = 'block'; else newRandomLevelOnGoalSettings.style.display = 'none';" checked="true" type="checkbox">
    <div id="newRandomLevelOnGoalSettings">
      fill screen (many objects)<input id="fillScreenAutoNewLevel" type="checkbox">
    </div>
  </div>
  </div>
  <div id="objSettings" class="card"> 
      <b>set amount and maximum size of objects</b>
      <div id="circleSettings" class="card">
        <input type="number" style="width: 44px;" value="5" id="circleAmount" min="0"> <b>circles</b>
        <br>
        maximum radius: 
        <input id="maxCircleSize" type="range">
      </div>
      <!-- <br> -->
      <div id="triangleSettings" class="card">
        <input type="number" style="width: 44px;" value="5" id="triangleAmount" min="0"> <b>triangles</b>
        <br>
        maximum width: 
        <input id="maxTriangleWidth" type="range">
        <br>
        maximum height: 
        <input id="maxTriangleHeight" type="range">
        <!-- <br> -->
      </div>
      <div id="rectangleSettings" class="card">
        <input type="number" style="width: 44px;" value="5" id="rectangleAmount" min="0"> <b>rectangle</b>
        <br>
        maximum width: 
        <input id="maxRectangleWidth" type="range">
        <br>
        maximum height: 
        <input id="maxRectangleHeight" type="range">
      </div>
    </div>
  <br>
  </div>
  <button style="font-size: 50px;" onclick="showGameInstructions();">how to play</button>
  <br>
  <input style="width: 50px; height: 50px" id="easyMaps" checked="true" onchange="if (!randomMapCreatorVisable.checked) difficultyChanged(checked);" type="checkbox"> <a style="font-size: 50px;">easy level versions</a>
  <br>
  <button style="font-size: 50px;" onclick="restartLevel();">kill (respawn at last checkpoint or start)</button>
  <h2 style="font-size: 50px;">sensitivity: </h2>
  <style>
    input[class='custom_slider'] {
    /* Override the default appearance */
    -webkit-appearance: none;
    appearance: none;
    width: 100%; /* Full-width */
    height: 150px; /* Specified height */
    }
    input[class='custom_small_slider'] {
    /* Override the default appearance */
    -webkit-appearance: none;
    appearance: none;
    width: 100%; /* Full-width */
    height: 50px; /* Specified height */
    }

input[class='custom_slider']::-webkit-slider-runnable-track {
    width: 90%;
    height: 150px;
    cursor: pointer;
    background: #d3d3d3;
    border-radius: 1.3px;
    border: 0.2px solid #010101;
}

input[class='custom_slider']::-webkit-slider-thumb {
    height: 150px;
    width: 100px;
    /* border-radius: 50%; */
    background: #0000FF;
    cursor: pointer;
    -webkit-appearance: none;
    margin-top: 0px; /* You need to specify a margin for Chrome, but we want to set it to 0 */
  }
  input[class='custom_small_slider']::-webkit-slider-runnable-track {
    height: 50px;
    cursor: pointer;
    background: #d3d3d3;
    border-radius: 1.3px;
    border: 0.2px solid #010101;
}

input[class='custom_small_slider']::-webkit-slider-thumb {
    height: 50px;
    width: 100px;
    /* border-radius: 50%; */
    background: #0000FF;
    cursor: pointer;
    -webkit-appearance: none;
    margin-top: 0px; /* You need to specify a margin for Chrome, but we want to set it to 0 */
  }
  
  </style>
  <input style="height: 50px;" type="range" min="1" onchange="sensitivity(document.getElementById('sensitivity').value)" max="25" value="5" class="custom_slider" id="sensitivity">
  <br>
  <br>
  <br>
  <br>
  <a style="font-size: 40px; position: absolute; right: 0;" id="sensitivityTitleRight">low (slow)</a>
  <a style="font-size: 40px;" id="sensitivityTitleLeft">high (fast)</a>
  <br>
  <a style="font-size: 40px;"> <input id="automaticResetsensitivity" style="width: 50px; height: 50px" type="checkbox"> reset to level standard after each level</a>
  <br>
  <button type="button" id="normalsensitivity" onclick="sensitivity(level.currentsensitivity, true)" style="font-size: 50px;" name="button">back to normal</button>
  <table id="scores">
    <!-- <tr>
    <td>Row1 cell1</td>
    <td>Row1 cell2</td>
  </tr>
  <tr>
    <td>Row2 cell1</td>
    <td>Row2 cell2</td>
  </tr>
  <tr>
    <td>Row3 cell1</td>
    <td>Row3 cell2</td>
  </tr> -->
  </table>
  <br>
  <br>
  <div id="app">
    <li v-for="title in db" id="levelNames">
      {{ title }}
    </li>
  </div>
  <select name="course" id="courceSelection" style="font-size: 50px;" onchange="courceSelected()">
  </select>
  <div id="checkpointManagement">
    <select style="font-size: 50px;" id="checkpointSelection" onchange="checkpointSelected(value);"></select>
    <button onclick="deleteCheckpoint();" style="font-size: 50px;">delete latest checkpoint</button>
    <br>
  </div>
  <div id="oldMapCreatorPosition"></div>
  <div id="randomMapCreatorVisableA"><input type="checkbox" style="width: 50px; height: 50px" id="randomMapCreatorVisable" onchange="mapCreatorVisChanged(checked);"> 
    <a style="font-size: 50px;">show random level creator</a>
  </div>
  <br>
  <input type="checkbox" onchange="inOrAgainstDirection *= -1;" style="width: 50px; height: 50px" id="oppositeCheck"> <a style="font-size: 50px;">opposite movement direction</a>
  <p style="font-size: 50px;" id="joyStickPlayP"> <input style="width: 50px; height: 50px" type="checkbox" onchange="if (checked) {textur.style.touchAction = 'none'; level.currentsensitivity = currentLevel.joySticksensitivity} else level.currentsensitivity = currentLevel.sensitivity;" id="joyStickPlay"> joystick control </p>
  <select name="course" id="modeSelection" style="display:none" value="move" onchange="modeSelected(value);">
    <option value="normal">normal</option>
    <option value="growing">growing</option>
    <option value="survive">survive</option>
  </select>
  <br>
  <button style="font-size: 50px;" id="manuelCalibrate" onclick="calibrate();">calibrate (tilting direction)</button>
  <br>
  <select id="tabletPositionModeSelection">
    <option>flat (most natural)</option>
    <option>almost on end (slopes away from you a bit, best? for your posture)</option>
    <option>on end (better for your posture)</option>
  </select>
  <style>
      .form_input {
    position: relative;
    top: 0;
    left: 0;
    height: 30px;
    /* width: 100%;
    height: 100%; */
  }
  /* .form_input:hover {
    border-color: hsl(181, 100%, 50%);
  }
  .form_input:focus {
    border-color: hsl(177, 100%, 50%);
  } */
  .form_input:focus ~ .form_label,
  .form_input:not(:placeholder-shown) ~ .form_label {
   /* top: -0.5rem;
    font-size: 0.8rem; */
    /* top: 7px; 10 was good */
    top: 0.17rem;
    font-size: 15px;
    /* left: -1px; */
    /* left: 0.8rem; */
  } 
  .form_label {
    position: absolute;
    /* left: 1rem; */
    /* top: 0.8rem; */
    top: calc(0.3rem + 15px);
    /* everything in one line */
    width: max-content;
    padding: 0 1px;
    left: 10px;
    background-color: white;
    cursor: text;
    transition: top 200ms ease-in,
      left 200ms ease-in,
      font-size 200ms ease-in;
  }
  .form {
    position: relative;
    /* top: 10px; */
    padding-top: 15px;
    display: inline-block;
    padding-bottom: 3px;
  }
  </style>
  <script type="text/javascript">
  // in full screen mode black by default
  document.body.style.backgroundColor = "white";
if ((typeof DeviceOrientationEvent.requestPermission === 'function' || typeof DeviceMotionEvent.requestPermission === 'function') && localStorage.getItem('motionControlGeduldspiel') == undefined) deviceMotionControlRequestDiv.style.display = "inline";
function requestMotionControlPermission() {
  alert("Please give the following permission to be able to play with motion control.");
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceMotionEvent.requestPermission().then(function(response) {
      localStorage.setItem('motionControlGeduldspiel', response);
      if (response != "granted") {
        alert("You have to give permission to the motion control in order to be able to play with motion control!");
      }
      deviceMotionControlRequestDiv.style.display = "none";
    });
  }
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().then(function(response) {
      localStorage.setItem('motionControlGeduldspiel', response);
      if (response != "granted") {
        alert("You have to give permission to the motion control in order to be able to play with motion control!");
      }
      deviceMotionControlRequestDiv.style.display = "none";
    });
  }
}
  function selectTextBox(pThis) {
    setTimeout(() => {
      pThis.parentElement.querySelector('input').select();
    }, 1);
  }
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
    sensitivityTitleLeft.innerHTML = "low (slow)";
    sensitivityTitleRight.innerHTML = "high (fast)";
  } else {
    var gerät = "PC"
    joyStickPlayP.style.display = "none";
    tabletPositionModeSelection.style.display = "none";
    joyStickPlay.checked = true;
    console.log("PC");
    // calibrating on PC not needed, because you can only play with JoyStick (no motion control)
    manuelCalibrate.style.display = "none";
  }
  var inOrAgainstDirection = 1;
  window.onbeforeunload = function(){
  console.log("Leave Website");
    return;
  };
  var sphere1 = document.getElementById("sphere1");
  var growing;
  function modeSelected(value) {
    clearInterval(growing);
    level.mode = value;
    startPause();
    // if (value == "growing") {
    //   sphere1.style.width =  level.growing[level.growing.levelType][level.growing.number].beginningSize.x//(window.innerWidth / 40 + 66) / 2 + "px";
    //   sphere1.style.height = level.growing[level.growing.levelType][level.growing.number].beginningSize.y//(window.innerHeight / 40 + 66) / 2 + "px";
    //   growing = setInterval(function () {
    //     sphere1.style.width = (JSON.parse(sphere1.style.width.toString().split('px')[0]) + level.growing[level.growing.levelType][level.growing.number].miliSecForGrowning) + "px";
    //     sphere1.style.height = (JSON.parse(sphere1.style.height.toString().split('px')[0]) + level.growing[level.growing.levelType][level.growing.number].miliSecForGrowning) + "px";
    //     level.growing[level.growing.levelType][level.growing.number].spawnPoint.x = window.innerWidth/2 - JSON.parse(sphere1.style.width.toString().split('px')[0]) + 77;
    //     level.growing[level.growing.levelType][level.growing.number].spawnPointy = window.innerHeight/2 - JSON.parse(sphere1.style.height.toString().split('px')[0]);
    //   }, 7);
    // }
    // else {
      sphere1.style.width = 50 + "px";
      sphere1.style.height = 50 + "px";
    // }
  }
  function checkpointSelected(value) {
    if (value == "start") {
      checkpoint = levelCheckpoints[0];
      level.checkpoint = 0;
    }
    else {
      checkpoint = levelCheckpoints[parseInt(value.split('. ')[0])];
      level.checkpoint = parseInt(value.split('. ')[0]);
    }
  }
  function deleteCheckpoint() {
    if (levelCheckpoints.length > 1 && confirm('Are you sure you want to delete the latest checkpoint (' + (levelCheckpoints.length - 1) + '.) ?')) {
      levelCheckpoints.pop();
      document.getElementById('checkpointSelection').options[levelCheckpoints.length] = undefined;
      document.getElementById('checkpointSelection').value = (levelCheckpoints.length - 1) + ". checkpoint"
      if (levelCheckpoints.length == 1) {
        checkpointManagement.style.display = "none";
      }
      else {
        level.checkpoint--;
      }
      checkpoint = levelCheckpoints[level.checkpoint];
      localStorage.setItem('checkpointsGeduldspiel', JSON.stringify(checkpoints));
      if (level.checkpoint) checkpointSelection.value = level.checkpoint + '. checkpoint';
      else checkpointSelection.value = "start";
      restartLevel();
   }
  }
  var sensitivityAcc = {x: 5, y: 5};
  function sensitivity(value, backToNormal) {
    document.getElementById('sensitivity').value = value;
    sensitivityAcc = {x: value, y: value};
  }
    visible([
      ['app', "none"],
    ])
  function rotateObj(direction) {
    selected.obj.direction += direction; 
    if (selected.obj.direction < 0) selected.obj.direction = 3; 
    if (selected.obj.direction > 3) selected.obj.direction = 0;
    var oldWidth = selected.obj.width;
    selected.obj.width = selected.obj.height;
    selected.obj.height = oldWidth;
    selected.obj.path = calculatePath('triangle', selected.obj);
    elmWidth.value = selected.obj.width;
    elmHeight.value = selected.obj.height;
  }
    var canvas = textur.getContext('2d'); //Dimension
    console.log(window.innerWidth + " - " + window.innerHeight);
    var RotatingWall;
    var RotatingDreieck;
    var BlinkWall;
    var mins = 0;
    var secs = 0;
    var tenths = 0;
    var time = 0;
    var x1 = 10,
      y1 = 177; //window.innerHeight - 150 + 3,
    x2 = 0, y2 = 0,
      vx1 = 0, vy1 = 0,
      vx2 = 0, vy2 = 0,
      ax1 = 0, ay1 = 0;
    var mausx = 0;
    var mausy = 0;
    var zählerListe = [window.innerHeight];
    var offline = false;
    var Bild = new Image();
    if (offline == false) Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gelduldspiel/normal/GeduldsspielMap1.png"
    canvas.drawImage(Bild, 0, 0, window.innerWidth, window.innerHeight)
    setTimeout(function() {
      Layout();
    }, 500);
    var level = {
      currentsensitivity: 5,
      checkpoint: 0,
      normal: {
      number: 1,
      easyMaps: {
        2: {
          spawnPoint: {
            x: 300,
            y: 755
          }
        },
        4: {
          spawnPoint: {
            x: 175,
            y: 133
          },
        },
        5: {
          spawnPoint: {
            x: 175,
            y: 133
          },
          blinkWall: [{
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 349,
            y: 388,
            width: 17,
            height: 320
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 649,
            y: 388,
            width: 17,
            height: 320
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 949,
            y: 388,
            width: 17,
            height: 320
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 1249,
            y: 388,
            width: 17,
            height: 320
          }]
        },
        6: {
          spawnPoint: {
            x: 250,
            y: 155
          }
        },
        7: {
          spawnPoint: {
            x: 150,
            y: 155
          }
        },
        9: {
          rotatingWall: [{
            x: 700,
            y: 400,
            width: 1480,
            height: 17,
            angle: 90,
            timeFor360GradRotation: 10000
          }],
        },
        10: {
          rotatingDreieck: [{
            x: 700,
            y: 370,
            size: 50,
            timeFor360GradRotation: 14000,
            angle: 0
          }]
        },
        14: {
          rotatingWall: [{
            x: 677,
            y: 334,
            width: 1366,
            height: 17,
            angle: 0,
          }, {
            x: 677,
            y: 334,
            width: 1366,
            height: 17,
            angle: 90
          }],
          spawnPoint: {
            x: 50, 
            y: 399
          }
        },
        15: {
          rotatingDreieck: [{
            x: 204,
            y: 107,
            size: 20,
            timeFor360GradRotation: 10000,
            angle: 50
          }, {
            x: 341,
            y: 308,
            size: 21,
            timeFor360GradRotation: 10000,
            angle: 10
          }, {
            x: 500,
            y: 409,
            size: 20,
            timeFor360GradRotation: 10000,
            angle: 0
          }, {
            x: 900,
            y: 262,
            size: 68,
            timeFor360GradRotation: 10077,
            angle: 0
          }]
        },
        16: {
          rotatingWall: [{
            x: 760,
            y: 334,
            width: 1180,
            height: 17,
            angle: -90,
            timeFor360GradRotation: 13000
          }],
        },
        23: {
          cannons: [
            {x: 1520 + 100, y: 45, width: 100, height: 100, speed: 14000, bulletSpeed: 7, timeGone: 0, direction: {x: -1, y: 0}}
          ],
        },
        24: {
          cannons: [
            {x: 1520 + 100, y: -17, width: 100, height: 50, speed: 7000, bulletSpeed: 3, timeGone: 0, direction: {x: -1, y: 0}},
            {x: 1520 + 100, y: 145, width: 100, height: 50, speed: 7000, bulletSpeed: 3, timeGone: 0, direction: {x: -1, y: 0}}
          ],
        },
      },
      vorgefertigt: {
        1: {
          spawnPoint: {
            x: 700,
            y: 555
          },
          levelNr: 1
        },
        2: {
          spawnPoint: {
            x: 300,
            y: 577
          },
          levelNr: 2
        },
        3: {
          spawnPoint: {
            x: 50,
            y: 255
          },
          levelNr: 3
        },
        4: {
          spawnPoint: {
            x: 75,
            y: 75
          },
          levelNr: 4
        },
        5: {
          spawnPoint: {
            x: 75,
            y: 75
          },
          blinkWall: [{
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 349,
            y: 475,
            width: 17,
            height: 225
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 475,
            y: 475,
            width: 17,
            height: 225
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 600,
            y: 475,
            width: 17,
            height: 225
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 725,
            y: 475,
            width: 17,
            height: 225
          }, {
            timeInvisible: 2000,
            timeVisible: 2000,
            x: 922,
            y: 475,
            width: 17,
            height: 225
          }, {
            timeInvisible: 1000,
            timeVisible: 1000,
            x: 1050,
            y: 475,
            width: 17,
          }, {
            timeInvisible: 1000,
            timeVisible: 1000,
            x: 1250,
            y: 475,
            width: 17,
            height: 225
          }],
          levelNr: 5
        },
        6: {
          spawnPoint: {
            x: 150,
            y: 155
          },
          levelNr: 6
        },
        7: {
          levelNr: 7
        },
        8: {
          spawnPoint: {
            x: 50,
            y: 455
          },
          levelNr: 8
        },
        9: {
          rotatingWall: [{
            x: 700,
            y: 400,
            width: 1480,
            height: 17,
            angle: 90,
            timeFor360GradRotation: 4000,
          }],
          levelNr: 9
        },
        10: {
          rotatingDreieck: [{
            x: 700,
            y: 370,
            size: 50,
            timeFor360GradRotation: 6000,
            angle: 0
          }],
          levelNr: 10
        },
        11: {
          spawnPoint: {
            x: 50,
            y: 155
          },
          levelNr: 11
        },
        12: {
          levelNr: 12,
        },
        13: {
          blinkWall: [{
            timeInvisible: 3000,
            timeVisible: 3000,
            x: 210,
            y: 177,
            width: 115,
            height: 17
          }, {
            timeInvisible: 3000,
            timeVisible: 3000,
            x: 210,
            y: 388,
            width: 115,
            height: 17
          }],
          levelNr: 13
        },
        14: {
          rotatingWall: [{
            x: 644,
            y: 334,
            width: 1366,
            height: 17,
            angle: 0
          }, {
            x: 644,
            y: 334,
            width: 1366,
            height: 17,
            angle: 45
          }, {
            x: 644,
            y: 334,
            width: 1366,
            height: 17,
            angle: 90
          }, {
            x: 644,
            y: 334,
            width: 1366,
            height: 17,
            angle: 135
          }],
          spawnPoint: {
            x: 50, 
            y: 399
          },
          levelNr: 14
        },
        16: {
          rotatingWall: [{
            x: 760,
            y: 334,
            width: 1180,
            height: 17,
            angle: 0,
          }],
          levelNr: 16
        },
        15: {
          sensitivity: 9,
          joySticksensitivity: 4,
          rotatingDreieck: [{
            x: 204,
            y: 107,
            size: 33,
            timeFor360GradRotation: 7000,
            angle: 77
          }, {
            x: 341,
            y: 308,
            size: 20,
            timeFor360GradRotation: 7000,
            angle: 10
          }, {
            x: 500,
            y: 409,
            size: 20,
            timeFor360GradRotation: 7000,
            angle: 0
          }, {
            x: 900,
            y: 262,
            size: 68,
            timeFor360GradRotation: 4077,
            angle: 0
          }],
          levelNr: 15
        },
        17: {
          levelNr: 17
        },
        18: {
          rotatingWall: [{
            x: 355,
            y: 130,
            width: 370,
            height: 17,
            angle: 0
          }, {
            x: 1080,
            y: 450,
            width: 400,
            height: 17,
            angle: 0
          }, {
            x: 657,
            y: 370,
            width: 355,
            height: 17,
            angle: 0
          }, {
            x: 1350,
            y: 370,
            width: 311,
            height: 17,
            angle: 0
          }, {
            x: 911,
            y: 70,
            width: 311,
            height: 17,
            angle: 0
          }, {
            x: 733,
            y: 630,
            width: 311,
            height: 17,
            angle: 0
          }],
          levelNr: 18
        },
        19: {
          levelNr: 19
        },
        20: {
          levelNr: 20
        },
        21: {
          levelNr: 21
        },
        22: {
          levelNr: 22,
        },
        23: {
          cannons: [
            {x: 1520 + 100, y: 45, width: 100, height: 100, speed: 9999, bulletSpeed: 7, timeGone: 0, direction: {x: -1, y: 0}}
          ],
          levelNr: 23
        },
        24: {
          sensitivity: 7,
          joySticksensitivity: 4,
          cannons: [
            {x: 1520 + 100, y: 10, width: 100, height: 50, speed: 7000, bulletSpeed: 10, timeGone: 0, direction: {x: -1, y: 0}},
            {x: 1520 + 100, y: 137, width: 100, height: 50, speed: 7000, bulletSpeed: 10, timeGone: 0, direction: {x: -1, y: 0}}
          ],
          levelNr: 24
        },
      },
      editLevel: {
        selectedLevel: 1
      },
      levelType: "easyMaps"
    },
    growing: {
      number: 1,
      editLevel: {
        selectedLevel: 1
      },
      levelType: "vorgefertigt",
      vorgefertigt: {
        1: {
          miliSecForGrowning: 0.07,
          beginningSize: {
            x: (window.innerWidth / 40 + 333) / 2 + "px",
            y: (window.innerHeight / 40 + 333) / 2 + "px"
          },
          spawnPoint: {
            x: window.innerWidth/2 - sphere1.style.width,
            y: window.innerHeight/2 - sphere1.style.height
          }
        }
      }
    },
    survive: {
      number: 1,
      editLevel: {
        selectedLevel: 1
      },
      levelType: "vorgefertigt",
      vorgefertigt: {
        1: {
          sensitivity: 25,
          spawnPoint: {
            x: window.innerWidth/2 - sphere1.style.width,
            y: window.innerHeight/2 - sphere1.style.height
          },
          bullet: [
            {
              startPointInSec: 0,
              pxPerMiliSec: 33,
              startPosition: {
                x: -90,
                y: window.innerHeight/2 - 50
              },
              // endPosition:
              repeatIntervalIn_Secs: 7,
              repetitions: {need: 3, beginningtimes: [7, 7, 7]},
              direction: "right",
              radius: 50
            },
            {
              startPointInSec: 0,
              pxPerMiliSec: 33,
              startPosition: {
                x: -90,
                y: window.innerHeight/2 + 133
              },
              // endPosition:
              repeatIntervalIn_Secs: 7,
              repetitions: {need: 3, beginningtimes: [7, 7, 7]},
              direction: "right",
              radius: 50
            },
            {
              startPointInSec: 27,
              pxPerMiliSec: 15,
              startPosition: {
                x: window.innerWidth/2 + 100,
                y: -90
              },
              // endPosition:
              repeatIntervalIn_Secs: 7,
              repetitions: {need: 2, beginningtimes: [0, 0]},
              direction: "down",
              radius: 77
            },
            {
              startPointInSec: 34,
              pxPerMiliSec: 20,
              startPosition: {
                x: window.innerWidth/2 -150,
                y: -90
              },
              // endPosition:
              repeatIntervalIn_Secs: 7, // not needed (?)
              repetitions: {need: 0, beginningtimes: []},
              direction: "down",
              radius: 77
            }
          ]
        }
      }
    },
      mode: "normal"
    }
    for (const key of Object.keys(level.normal.vorgefertigt)) {
      var pLevel = level.normal.vorgefertigt[key];
      if (!pLevel.spawnPoint) {
        pLevel.spawnPoint = {
          x: 50,
          y: 255
        };
      }
      if (!pLevel.sensitivity) pLevel.sensitivity = 5;
      if (!pLevel.joySticksensitivity) pLevel.joySticksensitivity = pLevel.sensitivity;
      for (const attr of Object.keys(pLevel)) {
        if (attr == "rotatingWall") {
          for (const wall of pLevel.rotatingWall) {
            if (!wall.timeFor360GradRotation) wall.timeFor360GradRotation = 10000;
          }
        }
        if (!level.normal.easyMaps[key]) level.normal.easyMaps[key] = {};
        if (!Object.keys(level.normal.easyMaps[key]).includes(attr)) level.normal.easyMaps[key][attr] = pLevel[attr];
        if (level.normal.easyMaps[key].rotatingWall) {
          for (const wall of level.normal.easyMaps[key].rotatingWall) {
            if (!wall.timeFor360GradRotation) wall.timeFor360GradRotation = 10000;
          }
        }
      }
      if (pLevel.blinkWall) initializeBlinkWall(pLevel.blinkWall);
      if (level.normal.easyMaps[key].blinkWall) initializeBlinkWall(level.normal.easyMaps[key].blinkWall);
    }
    // random map creator stuff: 
    function mapCreatorVisChanged(checked) {
    if (checked) {
      handleMaxSizeSlider(true);
      randomMapCreator.style.display = 'block';
      // currentLevel = {sizes: {schieber: {width: 50, height: 50}, ball: {width: 50, height: 50}}};
      sensitivityAcc = {x: 5, y: 5};
      checkpointManagement.style.display = 'none';
      randomMapCreator.prepend(randomMapCreatorVisableA);
      // refreshBallSize();
      courceSelection.style.display = "none";
      if (!Object.keys(objects).reduce((acc, val) => acc + objects[val].length, 0).length) createRandomMap();
      } 
      else {
        randomMapCreator.style.display = 'none';
        oldMapCreatorPosition.prepend(randomMapCreatorVisableA);
        courceSelected();
        courceSelection.style.display = "inline";
      }
  }
  function changeObjSize(sizeType, value) {
    selected.obj[sizeType] = Number(value); 
    selected.obj.hitbox = calculateHitbox(selected.type, selected.obj); 
    selected.obj.middle = calculateMiddle(selected.type, selected.obj); 
    selected.obj.path = calculatePath(selected.type, selected.obj);
    if (rotateTile.checked) {
      changeIfRotates(false);
      changeIfRotates(true);
    }
  }
  function changeIfRotates(checked) {
    if (checked) {
      if (!selected.obj.rotated) showPresetRotationSettings();
      selected.obj.rotated = true;
      rotateSettings.style.display = 'block';
      rotatingObj[selected.type].push(selected.obj);
      if (!currentLevel.rotating) currentLevel.rotating = [];
        var newRotating = {shape: "randomMapCreator", path: selected.obj.path, position: selected.obj.middle, miliSecsPerRotation: parseInt(miliSecPerRotationNumber.value), sizeRelationToOriginal: parseFloat(rotatingRandomObjScale.value), angle: parseInt(rotatingRandomObjStartingAngle.value), objType: selected.type, objNumber: selected.obj.number};
        currentLevel.rotating.push(newRotating);
        if (currentLevel.rotating.length == 1) requestAnimationFrame(renderLoop);
      objects[selected.type] = objects[selected.type].filter(x => JSON.stringify(x) != JSON.stringify(selected.obj));
      layoutObjs();
    }
    else {
      rotateSettings.style.display = 'none';
      currentLevel.rotating = currentLevel.rotating.filter(x => x.objNumber != selected.obj.number);
      objects[selected.type].push(selected.obj);
      rotatingObj[selected.type] = rotatingObj[selected.type].filter(x => x.number != selected.obj.number);
    }
  }
  function changeRotateParam(param, value) {
    for (const obj of currentLevel.rotating) {
      if (obj.objNumber == selected.obj.number) obj[param] = value;
    }
  }
  function goalSideChanged() {
    if (goalTop.checked) goalHitbox = {x: 0, y: 0, width: textur.width, height: 33};
    if (goalLeft.checked)  goalHitbox = {x: 0, y: 0, width: 33, height: textur.height};
    if (goalBottom.checked)  goalHitbox = {x: 0, y: textur.height - 33, width: textur.width, height: 33};
    if (goalRight.checked)  goalHitbox = {x: textur.width - 33, y: 0, width: 33, height: textur.height};
    layoutObjs();
  }
  function showPresetRotationSettings() {
    miliSecPerRotationNumber.value = 10000;
    rotatingRandomObjScale.value = 1;
    rotatingRandomObjStartingAngle.value = 0;

  }
  var objects = {circles: [], triangles: [], rectangles: []/*, squares: []*/};
  var rotatingObj = {circles: [], triangles: [], rectangles: []/*, squares: []*/};
  function handleMaxSizeSlider(changeValue) {
    if (parseInt(canvasHeight.value) > parseInt(canvasWidth.value)) maxCircleSize.max = canvasWidth.value/2 - minimalDistance.value;
    else maxCircleSize.max = canvasHeight.value/2 - minimalDistance.value;
    maxTriangleWidth.max = canvasWidth.value - minimalDistance.value;
    maxTriangleHeight.max = canvasHeight.value - minimalDistance.value;
    maxRectangleWidth.max = canvasWidth.value - minimalDistance.value;
    maxRectangleHeight.max = canvasHeight.value - minimalDistance.value;
    if (changeValue) {
      if (parseInt(canvasHeight.value) > parseInt(canvasWidth.value)) maxCircleSize.value = canvasWidth.value/2 - minimalDistance.value;
      else maxCircleSize.value = canvasHeight.value/2 - minimalDistance.value;
      maxTriangleWidth.value = canvasWidth.value;
      maxTriangleHeight.value = canvasHeight.value;
      maxRectangleWidth.value = canvasWidth.value;
      maxRectangleHeight.value = canvasHeight.value;
    }
  }
  function exportLevel() {
    var level = {objects: objects, rotatingObj: rotatingObj, goalHitbox: goalHitbox, spawnPoint: checkpoint.position, width: textur.width, height: textur.height, ballWidth: sphere1.style.width, ballHeight: sphere1.style.height};
    download(prompt("Please enter a name for the file") + '.json', JSON.stringify(level));
  }
  function importLevel(files) {
    var file = files.files[0]
    var reader = new FileReader();
    reader.addEventListener('load', function() {
      level = JSON.parse(reader.result);
      objects = level.objects;
      rotatingObj = level.rotatingObj;
      for (const objType of Object.keys(objects)) {
        for (const obj of objects[objType]) {
          if (obj.path) obj.path = createPath(obj.path.data.points, true, obj.path.data.middle);
        }
      }
      goalHitbox = level.goalHitbox;
      checkpoint.position = level.spawnPoint;
      textur.width = level.width;
      textur.height = level.height;
      canvasWidth.value = level.width;
      canvasHeight.value = level.height;
      sphere1.style.width = level.ballWidth;
      sphere1.style.height = level.ballHeight;
      ballWidthSlider.value = level.ballWidth.replace('px', '');
      ballHeightSlider.value = level.ballHeight.replace('px', '');
    }, false)
    reader.readAsText(file);
  }
function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}
var objBefore;
var recursionCounter = 0;
  function createRandomMap(noNewSpawnpoint) {
    objBefore = {circles: Object.keys(objects.circles).length, triangles: Object.keys(objects.triangles).length, rectangles: Object.keys(objects.rectangles).length};
    textur.width = canvasWidth.value;
    textur.height = canvasHeight.value;
    goalSideChanged();
    collideCount = 0;
    recursionCounter = 0;
    createCircles();
    createTriangles();
    createRectangles();
    layoutObjs();
    if (!noNewSpawnpoint) setSpawnPoints();
  }
  var objNumber = 0;
  function createCircles(
    radius = Math.round(Math.random()*(maxCircleSize.value - 5)) + 5, 
    x = Math.round(Math.random()*(textur.width - radius)),
    y = Math.round(Math.random()*(textur.height - radius)),
    manual,
    ) {
    if (circleAmount.value == 0) return;
    var newObj = {x, y, radius: radius, number: objNumber};
    newObj.hitbox = calculateHitbox("circle", newObj);
    objNumber++;
    if (manual) {
      objects.circles.push(newObj);
      selected.obj = newObj;
    }
    else if (collideCount < 9999) {
      if (!newCollidesOthers(newObj)) {
        objects.circles.push(newObj);
      }
      if (Object.keys(objects.circles).length < Number(circleAmount.value) + objBefore.circles) {
        recursionCounter++;
        if (recursionCounter % 1000 == 0) setTimeout(createCircles, 0);
        else createCircles();
      }
    }
  }
  function createTriangles(
      width = Math.round(Math.random()*maxTriangleWidth.value), 
      height = Math.round(Math.random()*maxTriangleHeight.value),
      x = Math.round(Math.random()*(textur.width - width)), 
      y = Math.round(Math.random()*(textur.height - height)), 
      direction = Math.round(Math.random()*3),
      manual
    ) {
      if (triangleAmount.value == 0) return;
    // for (let i = 0; i < triangleAmount.value; i++) {
      var newObj = {x, y, width, height, direction, number: objNumber};
      newObj.hitbox = calculateHitbox("triangle", newObj);
      newObj.middle = calculateMiddle("triangle", newObj);
      newObj.path = calculatePath("triangle", newObj);
      objNumber++;
      if (manual) {
        objects.triangles.push(newObj);
        selected.obj = newObj;
      }
      else if (collideCount < 9999) {
        if (!newCollidesOthers(newObj)) {
          objects.triangles.push(newObj);
        }
        if (Object.keys(objects.triangles).length < Number(triangleAmount.value) + objBefore.triangles) {
          recursionCounter++;
          if (recursionCounter % 1000 == 0) setTimeout(createTriangles, 0);
          else createTriangles();
        }
      }
    // }
  }
  function createRectangles(
      width = Math.round(Math.random()*maxTriangleWidth.value), 
      height = Math.round(Math.random()*maxTriangleHeight.value),
      x = Math.round(Math.random()*maxTriangleWidth.value), 
      y = Math.round(Math.random()*(textur.height - height)), 
      manual
    ) {
    if (rectangleAmount.value == 0) return;
    var newObj = {x, y, width: width, height: height, number: objNumber};
    newObj.hitbox = calculateHitbox("rectangle", newObj)
    newObj.middle = calculateMiddle("rectangle", newObj);
    newObj.path = calculatePath("rectangle", newObj);
    objNumber++;
    if (manual) {
      objects.rectangles.push(newObj);
      selected.obj = newObj;
    }
    else if (collideCount < 9999) {
      if (!newCollidesOthers(newObj)) {
        objects.rectangles.push(newObj);
      }
      if (Object.keys(objects.rectangles).length < Number(rectangleAmount.value) + objBefore.rectangles) {
        recursionCounter++;
        if (recursionCounter % 1000 == 0) setTimeout(createRectangles, 0);
        else createRectangles();
      }
    }
  }
  function calculateHitbox(type, obj) {
    // cover "circles"...
    if (type.includes("circle")) return {x: obj.x - obj.radius, y: obj.y - obj.radius, width: obj.radius*2, height: obj.radius*2};
    if (type.includes("triangle")) return {x: obj.x, y: obj.y, width: obj.width, height: obj.height};
    if (type.includes("rectangle")) return {x: obj.x, y: obj.y, width: obj.width, height: obj.height};
  }
  function calculateMiddle(type, obj) {
    if (type.includes("triangle")) return {x: obj.hitbox.x + obj.hitbox.width/2, y: obj.hitbox.y + obj.hitbox.height/2};
    if (type.includes("rectangle")) return {x: obj.x + obj.width/2, y: obj.y + obj.height/2};
  }
  function calculatePath(type, obj) {
    if (type.includes("triangle")) {
      // pointing down (?)
      if (!obj.direction) return createPath([point(obj.x, obj.y), point(obj.x + obj.width, obj.y), point(obj.x + obj.width/2, obj.y + obj.height)], true, obj.middle);
      // pointing left
      if (obj.direction == 1) return createPath([point(obj.x + obj.width, obj.y), point(obj.x + obj.width, obj.y + obj.height), point(obj.x, obj.y + obj.height/2)], true, obj.middle);
      // pointing up
      if (obj.direction == 2) return createPath([point(obj.x, obj.y + obj.height), point(obj.x + obj.width, obj.y + obj.height), point(obj.x + obj.width/2, obj.y)], true, obj.middle);
      // pointing right
      if (obj.direction == 3) return createPath([point(obj.x, obj.y), point(obj.x, obj.y + obj.height), point(obj.x + obj.width, obj.y + obj.height/2)], true, obj.middle);
    }
    if (type.includes("rectangle")) return createPath([point(obj.x, obj.y), point(obj.x + obj.width, obj.y), point(obj.x + obj.width, obj.y + obj.height), point(obj.x, obj.y + obj.height)], true, obj.middle);
  }
  // function createSquares() {
    
  // }
  function setSpawnPoints(time, startDistance) {
    if (!time) time = 0;
    if (!startDistance) startDistance = 50;
    if (goalLeft.checked) checkpoint = {position: {x: textur.width - Math.round(Math.random()*(startDistance)), y: Math.round(Math.random()*textur.height)}, timeNeededToReach: 0};
    if (goalTop.checked) checkpoint = {position: {x: Math.round(Math.random()*textur.width), y: textur.height - Math.round(Math.random()*(startDistance))}, timeNeededToReach: 0};
    if (goalRight.checked) checkpoint = {position: {x: Math.round(Math.random()*startDistance), y: Math.round(Math.random()*textur.height)}, timeNeededToReach: 0};
    if (goalBottom.checked) checkpoint = {position: {x: Math.round(Math.random()*textur.width), y: Math.round(Math.random()*startDistance)}, timeNeededToReach: 0};
    // checkpoint = {position: {x: Math.round(Math.random()*textur.width), y: Math.round(Math.random()*textur.height)}, timeNeededToReach: 0};
    currentLevel.spawnPoint = checkpoint.position;
    sphere1.style.left = checkpoint.position.x + "px";
    sphere1.style.top = checkpoint.position.y + "px";
    if (!(time/50 + "").includes('.')) startDistance += 50;
    if (time < 500) {
    if (collides({x: checkpoint.position.x, y: checkpoint.position.y, width: cssToNumber(sphere1.style.width), height: cssToNumber((sphere1.style.height))}, goalHitbox)) setSpawnPoints(time + 1, startDistance);
    // setTimeout(() => {
      var minimalDistanceStored = minimalDistance.value;
      minimalDistance.value = 0;
      if (newCollidesOthers({hitbox: {x: checkpoint.position.x, y: checkpoint.position.y, width: cssToNumber(sphere1.style.width), height: cssToNumber((sphere1.style.height))}})) {
        setSpawnPoints(time + 1, startDistance);
      }
      else restartLevel();
        minimalDistance.value = minimalDistanceStored;
      // }, 1);
    }
  }
  function newCollidesOthers(newObj) {
    for (const objType of Object.keys(objects)) {
      for (const obj of objects[objType]) {
        if (JSON.stringify(newObj) != JSON.stringify(obj) && (collides(obj.hitbox, newObj.hitbox) || ((!(newObj.hitbox.y > obj.hitbox.y + obj.hitbox.height + parseInt(minimalDistance.value) || newObj.hitbox.y + newObj.hitbox.height + parseInt(minimalDistance.value) < obj.hitbox.y) && (Math.abs(obj.hitbox.x + obj.hitbox.width - newObj.hitbox.x) < minimalDistance.value || Math.abs(newObj.hitbox.x + newObj.hitbox.width - obj.hitbox.x) < minimalDistance.value))  || (!(newObj.hitbox.x > obj.hitbox.x + obj.hitbox.width + parseInt(minimalDistance.value) || newObj.hitbox.x + newObj.hitbox.width + parseInt(minimalDistance.value) < obj.hitbox.x) && (Math.abs(obj.hitbox.y + obj.hitbox.height - newObj.hitbox.y) < minimalDistance.value || Math.abs(newObj.hitbox.y + newObj.hitbox.height - obj.hitbox.y) < minimalDistance.value))))) {
          collideCount++;
          return true;
        }
      }
    }
  }
  if (gerät == "PC") alert("please click to place a joy-stick!"); joyStick = "place";
  function canvasClicked() {
    var newSpawnpoint = false;
    if (setSchieberSpawnPoint.style.backgroundColor != "") {
      checkpoint = {position: {x: mausx, y: mausy - (textur.getBoundingClientRect().top + scrollY)}, timeNeededToReach: 0};
      setSchieberSpawnPoint.style.backgroundColor = "";
      level.checkpoint = 0;
      restartLevel();
      newSpawnpoint = true;
    }
    var newSelection = false;
    if (randomMapCreatorVisable.checked) {
      for (const objType of Object.keys(objects)) {
        for (const obj of objects[objType]) {
          if ((!selected.obj || JSON.stringify(selected.obj) != JSON.stringify(obj)) && mausx > obj.hitbox.x && mausx < obj.hitbox.x +  obj.hitbox.width && mausy > obj.hitbox.y && mausy < obj.hitbox.y +  obj.hitbox.height)  {
            selected.obj = obj;
            selected.type = objType;
            newSelection = true;
            layoutObjs();
            rotateTile.checked = false;
            if (objType == "circles") {
              elmRadius.style.display = "inline";
              inputRadius.max = Math.max(canvasWidth.value/2, canvasHeight.value/2);
              inputRadius.value = obj.radius;
              objSizeSetting.style.display = "none";
              rotateElement.style.display = "none";
            }
            else {
              rotateElement.style.display = "block";
              objSizeSetting.style.display = "inline";
              elmRadius.style.display = "none";
                elmWidth.max = canvasWidth.value;
                elmWidth.value = obj.width;
                elmHeight.max = canvasHeight.value;
                elmHeight.value = obj.height;
            }

          }
        }
      }
      for (const objType of Object.keys(rotatingObj)) {
        for (const obj of rotatingObj[objType]) {
          if ((!selected.obj || JSON.stringify(selected.obj) != JSON.stringify(obj)) && mausx > obj.hitbox.x && mausx < obj.hitbox.x +  obj.hitbox.width && mausy > obj.hitbox.y && mausy < obj.hitbox.y +  obj.hitbox.height)  {
            selected.obj = obj;
            selected.type = objType;
            newSelection = true;
            layoutObjs();
            rotateTile.checked = true;
            miliSecPerRotationNumber.value = currentLevel.rotating.filter(x => x.objNumber == obj.number)[0].miliSecsPerRotation;
          }
        }
      }
      if (newSelection && selected.type != "circles") {
        rotateTileA.style.display = "inline";
        if (!rotateTile.checked) rotateSettings.style.display = 'none';
        else rotateSettings.style.display = 'block';
    }
    else tileUnselectedOrDeleted(true);
  }
    if (!newSelection) {
      if (!newSpawnpoint) {
        if (!selected.obj && gerät == "Handy") togglePause();
        if ((!selected.obj || !randomMapCreatorVisable.checked) && /*joyStick == "place" && */gerät == "PC" && setSchieberSpawnPoint.style.backgroundColor == "") {
          joyStick = {coordinates : {x: mausx - scrollX, y: mausy - scrollY}};
        }
      }
      if (randomMapCreatorVisable.checked) tileUnselectedOrDeleted();
    }
  }
  function tileUnselectedOrDeleted(doNotDelete) {
    if (!doNotDelete) delete selected.obj;
    rotateTileA.style.display = "none";
    rotateSettings.style.display = 'none';
    layoutObjs();
  }
  function removeElement() {
    if (!selected.obj) alert("Please select an element (click on it) before clicking this button to remove it!");
    for (const objType of Object.keys(objects)) {
      objects[objType] = objects[objType].filter(x => JSON.stringify(x) != JSON.stringify(selected.obj));
      currentLevel.rotating = currentLevel.rotating?.filter(x => x.objNumber != selected.obj.number);
      rotatingObj[selected.type] = rotatingObj[selected.type].filter(x => x.number != selected.obj.number);
    }
    tileUnselectedOrDeleted();
    layoutObjs();
  }
  function deleteAllElements() {
    objects = {circles: [], triangles: [], rectangles: []/*, squares: []*/}; currentLevel.rotating = []; 
    rotatingObj = {circles: [], triangles: [], rectangles: []/*, squares: []*/}; 
    tileUnselectedOrDeleted(); 
    layoutObjs();
  }
  var selected = {};
  var collideCount = 0;
  function collides(a, b) {
      return /*{boolean: */!(
        ((a.y + a.height) < (b.y)) ||
        (a.y > (b.y + b.height)) ||
        ((a.x + a.width) < b.x) ||
        (a.x > (b.x + b.width))
        )/*, area: Math.abs(a.x - b.x) + Math.abs(a.width - b.width) + Math.abs(a.y - b.y) + Math.abs(a.height - b.height)}*/;
  }
  function layoutObjs() {
    canvas.clearRect(0, 0, textur.width, textur.height);
    canvas.fillStyle = "#787878";
    canvas.fillRect(0, 0, textur.width, textur.height)
    for (const objType of Object.keys(objects)) {
      for (const obj of objects[objType]) {
        if (JSON.stringify(obj) == JSON.stringify(selected.obj)) {
          canvas.fillStyle = "red";
        }
        else {
          canvas.fillStyle = "black";
        }
        if (objType == "circles") {
          canvas.beginPath();
          canvas.arc(obj.x, obj.y, obj.radius, 0, 2 * Math.PI, false);
          canvas.fill();
        }
        if (objType == "rectangles") canvas.fillRect(obj.x, obj.y, obj.width, obj.height);
        if (objType == "triangles") {
          canvas.save();
          canvas.translate(obj.middle.x, obj.middle.y);
          canvas.fill(obj.path);
          canvas.restore();
        }
      }
    }
    canvas.fillStyle = "rgb(255, 242, 0)";
    canvas.fillRect(goalHitbox.x, goalHitbox.y, goalHitbox.width, goalHitbox.height);
  }
  var goalHitbox = {x: textur.width - 33, y: 0, width: 33, height: textur.height};
    function initializeBlinkWall(walls) {
      for (const wall of walls) {
        if (!wall.start) wall.start = {};
        if (!wall.start.visible) wall.start.visible = true;
        if (!wall.start.timeUntilChange) wall.start.timeUntilChange = wall.timeVisible;
        if (!wall.changing) wall.changing = wall.start;
      }
    }
    if ([0, 180].includes(window.orientation)) {
      if (confirm('Please hold your device horizontally (in landscape mode) to start playing. If you have trouble with the detection of the screen orientation or you want to play the game in portrait mode (although this is not recommended), you can click on "cancel". Otherwise please change the orientation and click on "OK')) {
        window.location.reload()
      }
    }
    var mapBefore = "";
    oppositeDirectionBefore = inOrAgainstDirection;
    var calibrating;
    function calibrate(silent) {
      calibratedDirection = 1;
      inOrAgainstDirection = 1;
      if (!silent) alert("calibrating! Please hold your device horizontally (in landscape mode) and tilt the device towards you so a ball on your screen would roll towards you and the screen faces you. Then click OK.");
      mapBefore = Bild.src
      Bild = new Image();
      Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gelduldspiel/calibration.png";
      Layout();
      setTimeout(() => {
        Layout();
        window.scroll(0, 0);
      }, 500);
      calibrating = true;
    }
    function showGameInstructions() {
      alert('The browser Chrome is recommended. If you are using an apple device and want to play with motion control, it might be needed to switch to Safari though. Also, you may have to "request mobile website" on Safari. Hold your device flat like it is lying on a table and tilt it to move! Holding the device horizontally (in landscape mode) is recommended. Do not touch the black and try to reach the yellow goal! If you want to change settings like the sensitivity, scroll down. Clicking on the screen or pressing p will pause the game. ');
      localStorage.setItem("gameInstructionsGeduldspiel", true);
      if (gerät == "Handy") startTutorial();
    }
    var highscores = {}
    var AblageListe = [];
    AblageListe[5] = window.innerHeight;
    for (var i = 0; i < Object.keys(level).length - 1; i++) {
      highscores[Object.keys(level)[i]] = {true: {}, false: {}};
      // highscores[Object.keys(level)[i]] = [];
    }
    AblageListe[6] = false;
    function selected() {
      if (AblageListe[6] == true) {AblageListe[6] = false; document.getElementById('select').style.background = "";}
      else {AblageListe[6] = true; document.getElementById('select').style.background = "blue";}
    }
    var checkpoints = {normal: {}};
    var checkpoint;
    folgenDbgetHighscores();
    function folgenDbgetHighscores() {
      if (localStorage.getItem('geduldsspielHighscores')) highscores = JSON.parse(localStorage.getItem('geduldsspielHighscores'));
      if (localStorage.getItem('checkpointsGeduldspiel')) checkpoints = JSON.parse(localStorage.getItem('checkpointsGeduldspiel'));
      showLevels();
      if (highscores.normal[joyStickPlay.checked][easyMaps.checked]) courceSelection.value = (parseInt(Object.keys(highscores.normal[joyStickPlay.checked][easyMaps.checked])[Object.keys(highscores.normal[joyStickPlay.checked][easyMaps.checked]).length - 1]) + 1) + '. map';
      if (courceSelection.value == "") courceSelection.value = "1. map";
      setTimeout(() => {
        courceSelected();
        startPause();
      }, 777);
    }
    var app = new Vue({
      el: '#app',
      data: {
        db: []
      }
    })
    function showLevels() {
      var value = courceSelection.value;
      while (courceSelection.options.length > 0) {
        courceSelection.options[0] = undefined;
      }
      Object.keys(level.normal.vorgefertigt).forEach((levelNrNow, i) => {
        opt = document.createElement("option");
        document.getElementById("courceSelection").options.add(opt);
        opt.setAttribute("id", i);
        if (highscores.normal[joyStickPlay.checked][easyMaps.checked] && Object.keys(highscores.normal[joyStickPlay.checked][easyMaps.checked]).includes((level.normal.vorgefertigt[levelNrNow].levelNr).toString())) opt.text = "✅ " +  (i + 1) + ". map";
        else opt.text = (i + 1) + ". map";
        opt.value = (i + 1) + ". map";
      });
      courceSelection.value = value;
    }
    var deathMarkers = [];
    function restartLevel() {
      vx1 = vx2 = vy1 = vy2 = 0;
      if (level.mode == "growing") {
        modeSelected("growing");
        startPause();
      }
      x1 = currentLevel.spawnPoint.x;
      y1 = currentLevel.spawnPoint.y; //AblageListe[5] - 150 + 3;
      rotationStartTime = rotationTime;
      stopClockText.style.color = "green";
      goToCheckpoint();
    }
    function difficultyChanged(pEasyMaps, doNotSelectCource) {
      if (pEasyMaps) level.normal.levelType = 'easyMaps';
      else level.normal.levelType = 'vorgefertigt'; 
      if (!doNotSelectCource) courceSelected(); 
      showLevels();
      easyMaps.checked = pEasyMaps;
      checkpointSelected(checkpointSelection.value);
    }
    var currentLevel;
    function courceSelected() {
      bullets = [];
      if (currentLevel) var levelBefore = JSON.parse(JSON.stringify(currentLevel));
      for (let i = 1; i > 0 && window.innerHeight < textur.height; i -= 0.01) {
        scaleControler.content = "maximum-scale=" + i;
      }
      window.scroll(0, 0);
      if (document.getElementById('courceSelection').value != "vorgefertigt") app._data.db = [];
      /*if (document.getElementById('modeSelection').value == "survive") */
        clearInterval(RotatingWall);
      if (document.getElementById('courceSelection').value == "show Scores") {
        showScores();
        document.getElementById('levelEditTool').style.display = "none";
        level[level.mode].levelType = "showScores";      
      } else {
        time = 0;
        stopClockText.style.color = "green";
        if (document.getElementById('courceSelection').value != "") {
          level[level.mode].number = JSON.parse(document.getElementById('courceSelection').value.toString().split('.')[0]);
          currentLevel = level.normal[level.normal.levelType][level[level.mode].number];
          level.currentsensitivity = currentLevel.sensitivity;
          if (joyStickPlay.checked) level.currentsensitivity = currentLevel.joySticksensitivity;
          if (!checkpoints[level.mode][currentLevel.levelNr]) checkpoints[level.mode][currentLevel.levelNr] = {};
          if (!checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked]) checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked] = [];
          checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked][0] = {position: {x: currentLevel.spawnPoint.x, y: currentLevel.spawnPoint.y}, timeNeededToReach: 0};
          // start blinkWalls
          for (let i = 0; i < currentLevel.blinkWall?.length; i++) {
            var wall = currentLevel.blinkWall[i];
            wall.changing = wall.start;
          }
        }
        if (level[level.mode].number > Object.keys(level[level.mode].vorgefertigt).length) {
          alert('This is the last level :(  If you can not get enough of this game you can try out the random level creator, increase the sensitivity or check out the game "transport the ball", which is pretty similar but a bit more complicated and difficult. ');
          if (easyMaps.checked) {
            alert('But first, you can try to beat the hard version of the levels now, if you did not do so already! Just uncheck "easy level versions". ');
            difficultyChanged(false, true);
          }
          level.normal.number = 1;
          document.getElementById('courceSelection').value = "1. map";
          courceSelected();
        }
        if (checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked]) {
          levelCheckpoints = checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked];
          checkpoint = levelCheckpoints[levelCheckpoints.length - 1];
        }
        else checkpoint = undefined;
        while (document.getElementById('checkpointSelection').options.length > 0) {
          document.getElementById('checkpointSelection').options[0] = undefined;
        }
        for (var i = 0; checkpoint && i < levelCheckpoints.length; i++) {
          opt = document.createElement("option");
          document.getElementById("checkpointSelection").options.add(opt);
          if (i > 0) opt.text = i + ". checkpoint";
          else opt.text = "start";
        }
        if (levelCheckpoints?.length > 1) checkpointManagement.style.display = "inline";
        else checkpointManagement.style.display = "none";
        document.getElementById('textur').style.display = "inline";
        Layout();
        setTimeout(function() {
          Layout();
        }, 500);
        // startPause();
        window.scroll(0, 0)
    if (level && currentLevel.cannons && !levelBefore?.cannons) requestAnimationFrame(renderLoop);
      }
      if (!["vorgefertigt", "easyMaps"].includes(level[level.mode].levelType)) document.getElementById('textur').style.display = "none";
      if (level[level.mode].levelType != "showScores") document.getElementById('scores').style.display = "none";
      else document.getElementById('scores').style.display = "inline";
      if (level.type != "showScores" && currentLevel != undefined) {
      x1 = currentLevel.spawnPoint.x;
      y1 = currentLevel.spawnPoint.y;
      goToCheckpoint();
    }
    if (["vorgefertigt", "easyMaps"].includes(level[level.mode].levelType)) {
      Bild = new Image();
      if (easyMaps.checked) Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gelduldspiel/" + level.mode + "/easyMaps/GeduldsspielMap" + level[level.mode].number + ".png"
      else Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gelduldspiel/" + level.mode + "/GeduldsspielMap" + level[level.mode].number + ".png"
    }
    setTimeout(() => {
      textur.width = Bild.width;
      textur.height = Bild.height;
      Layout();
      setTimeout(() => {
        textur.width = Bild.width;
        textur.height = Bild.height;
        Layout();
        if (localStorage.getItem('checkpointsGeduldspiel')) checkpoints = JSON.parse(localStorage.getItem('checkpointsGeduldspiel'));
        levelCheckpoints = checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked];
      }, 1111);
    }, 777);
    if (automaticResetsensitivity.checked) {
      document.getElementById('sensitivity').value = level.currentsensitivity;
      sensitivityAcc = {x: level.currentsensitivity, y: level.currentsensitivity};
    }
    if (currentLevel.rotatingDreieck && !levelBefore?.rotatingDreieck) requestAnimationFrame(renderLoop);
    if (currentLevel.rotatingWall && !levelBefore?.rotatingWall) requestAnimationFrame(renderLoop);
    }

    sphere1.style.width = 50 + "px";
    sphere1.style.height = 50 + "px";
    if ((window.DeviceMotionEvent != undefined || joyStick.coordinates)) {
      window.ondevicemotion = function(e) {
        if (!pause && !tutorial) {
          if (tabletPositionModeSelection.value.split(' (')[0] == "flat") ax1 = inOrAgainstDirection * calibratedDirection * event.accelerationIncludingGravity.x * sensitivityAcc.x;
          else if (tabletPositionModeSelection.value.split(' (')[0] == "almost on end") ax1 = inOrAgainstDirection * calibratedDirection * (event.accelerationIncludingGravity.z - 1) * (-sensitivityAcc.x);
          else ax1 = inOrAgainstDirection * calibratedDirection * (event.accelerationIncludingGravity.z + 1.7) * (-sensitivityAcc.x);
          if (tabletPositionModeSelection.value.split(' (')[0] != "flat") ay1 = inOrAgainstDirection * calibratedDirection * event.accelerationIncludingGravity.y * 1.88 * sensitivityAcc.y;
          else ay1 = inOrAgainstDirection * calibratedDirection * event.accelerationIncludingGravity.y * sensitivityAcc.y;
       }
      }
      screen.orientation.onchange = (event) => {
        inOrAgainstDirection *= -1;
      }
      function goToCheckpoint() {
        if (checkpoint) {
          x1 = checkpoint.position.x;
          y1 = checkpoint.position.y;
          time = checkpoint.timeNeededToReach;
        }
      }
      setInterval(function() {
        // joy-stick:
        var nextCoordinates = {x: 0, y: 0};
        if (joyStickPlay.checked && document.getElementById('courceSelection').value != "show Scores" && !pause) {
          if (joyStick && joyStick.coordinates) {
            if (!oppositeCheck.checked) var nextCoordinates = {x: x1 + (mausx - joyStick.coordinates.x)/(JSON.parse(document.getElementById('sensitivity').value)*3), y: y1 + (mausy - joyStick.coordinates.y)/(JSON.parse(document.getElementById('sensitivity').value)*3)};
            else var nextCoordinates = {x: x1 - (mausx - joyStick.coordinates.x)/(JSON.parse(document.getElementById('sensitivity').value)*3), y: y1 - (mausy - joyStick.coordinates.y)/(JSON.parse(document.getElementById('sensitivity').value)*3)};
          }
        }
        // else if (gerät == "Handy") var nextCoordinates = {x: parseInt(x1 + vx1 / cssToNumber(sphere1.style.width)), y: parseInt(y1 + vy1 / cssToNumber(sphere1.style.height))}
        if (!pause && !tutorial) {
        var landscapeOrientation = window.innerWidth / window.innerHeight > 1;
        if (landscapeOrientation) {
          vx1 = vx1 + ay1;
          vy1 = vy1 + ax1;
          vx2 = vx2 + ay1;
          vy2 = vy2 + ax1;
        } else {
          vy1 = vy1 - ay1;
          vx1 = vx1 + ax1;
          vy2 = vy2 - ay1;
          vx2 = vx2 + ax1;
        }
        vx1 = vx1 * 0.98;
        vy1 = vy1 * 0.98;
        y1 = parseInt(y1 + vy1 / 50);
        x1 = parseInt(x1 + vx1 / 50);

        vx2 = vx2 * 0.98;
        vy2 = vy2 * 0.98;
        y2 = parseInt(y2 + vy2 / 30);
        x2 = parseInt(x2 + vx2 / 30);
        //  if (scrollY > 0) document.getElementById('sphere1').style.display = "none";
        boundingBoxCheck();
          if (joyStickPlay.checked) {
            x1 = nextCoordinates.x;
            y1 = nextCoordinates.y;
            if (x1 < 0) x1 = 0;
            if (x1 > textur.getBoundingClientRect().right - JSON.parse(sphere1.style.height.replace("px", ""))) x1 = textur.getBoundingClientRect().right - JSON.parse(sphere1.style.height.replace("px", ""));
            if (y1 < 0) y1 = 0;
            if (y1 > textur.getBoundingClientRect().bottom - JSON.parse(sphere1.style.height.replace("px", ""))) y1 = textur.getBoundingClientRect().bottom - JSON.parse(sphere1.style.height.replace("px", ""));
          }
          sphere1.style.top = y1 + "px";
          sphere1.style.left = x1 + "px";
        }
        // if ( /*y1 <= AblageListe[5]*/ scrollY == 0) sphere1.style.display = "inline";
        // else sphere1.style.display = "none";
        var numbers = [
          [x1 + JSON.parse(sphere1.style.width.replace("px", "")) - (textur.getBoundingClientRect().left + parseInt(textur.style.borderWidth.split("px")[0]) + scrollX), y1 + JSON.parse(sphere1.style.height.replace("px", "")) / 2 - (textur.getBoundingClientRect().top + parseInt(textur.style.borderWidth.split("px")[0]))],
          [x1 + JSON.parse(sphere1.style.width.replace("px", "")) / 2 - (textur.getBoundingClientRect().left + parseInt(textur.style.borderWidth.split("px")[0]) + scrollX), y1 - (textur.getBoundingClientRect().top + parseInt(textur.style.borderWidth.split("px")[0]))],
          [x1 + JSON.parse(sphere1.style.width.replace("px", "")) / 2 - (textur.getBoundingClientRect().left + parseInt(textur.style.borderWidth.split("px")[0]) + scrollX), y1 + JSON.parse(sphere1.style.height.replace("px", "")) - (textur.getBoundingClientRect().top + parseInt(textur.style.borderWidth.split("px")[0]))],
          [x1 - (textur.getBoundingClientRect().left + parseInt(textur.style.borderWidth.split("px")[0]) + scrollX), y1 + JSON.parse(sphere1.style.height.replace("px", "")) / 2 - (textur.getBoundingClientRect().top + parseInt(textur.style.borderWidth.split("px")[0]))]
        ]
        for (var i = 0; i < 4; i++) {
          // canvas.fillStyle = "red";
          // canvas.fillRect(numbers[i][0] - 10, numbers[i][1] - 10, 10, 10);
            data = canvas.getImageData(numbers[i][0], numbers[i][1], 1, 1);
            red = data.data[0];
            green = data.data[1];
            blue = data.data[2];
            alpha = data.data[3];
            if ((joyStick != "place" || !joyStickPlay.checked) && (((red == 0 && blue == 0 && alpha == 255 && green == 0) || (red == 34 && blue == 76 && green == 177)))) {
              console.log("Fail!");
              i = 4;
              deathMarkers.push({x: x1 - (textur.getBoundingClientRect().left + parseInt(textur.style.borderWidth.split("px")[0]) + scrollX) + 1, y: y1 - (textur.getBoundingClientRect().top + parseInt(textur.style.borderWidth.split("px")[0]) + scrollY), width: JSON.parse(sphere1.style.width.replace("px", "")), height: JSON.parse(sphere1.style.height.replace("px", "")), visibility: 0.5});
              restartLevel();
            }
            if (!checkpoints[level.mode]) checkpoints[level.mode] = [];
            if (!checkpoints[level.mode][currentLevel.levelNr]) checkpoints[level.mode][currentLevel.levelNr] = {};
            if (!checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked]) {
              checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked] = [{position: {x: currentLevel.spawnPoint.x, y: currentLevel.spawnPoint.y}, timeNeededToReach: 0}];
              levelCheckpoints = checkpoints[level.mode][currentLevel.levelNr][easyMaps.checked];
            }
            var newCheckpoint = 0;
            levelCheckpoints.forEach((pCheckpoint, i1) => {
              
          if ((red == 168 && green == 230 && blue == 29) && Math.abs(x1 - pCheckpoint.position.x) > 100 || Math.abs(y1 - pCheckpoint.position.y) > 100) {
            newCheckpoint++;
          }
            if ((red == 168 && green == 230 && blue == 29) && Math.abs(x1 - pCheckpoint.position.x) < 100 && Math.abs(y1 - pCheckpoint.position.y) < 100) {
            if (i1) checkpointSelection.value = i1 + '. checkpoint';
            else checkpointSelection.value = 'start';
            level.checkpoint = i1;
            checkpoint = levelCheckpoints[i1];
          }
          });
          if (newCheckpoint == levelCheckpoints.length && (red == 168 && green == 230 && blue == 29)) {
            console.log("checkpoint!!!");
            levelCheckpoints.push({position: {x: x1, y: y1}, timeNeededToReach: time})
            level.checkpoint++;
            checkpoint = levelCheckpoints[level.checkpoint];
            localStorage.setItem('checkpointsGeduldspiel', JSON.stringify(checkpoints));
            opt = document.createElement("option");
            document.getElementById("checkpointSelection").options.add(opt);
            opt.text = level.checkpoint + ". checkpoint";
            checkpointManagement.style.display = "inline";
          }
            if (red == 255 && blue == 0 && alpha == 255 && green == 242) {
              if (calibrating) {
                if (y1 < 70) calibratedDirection = -1;
                localStorage.setItem("calibratedDirection", calibratedDirection)
                Bild.src = mapBefore;
                inOrAgainstDirection = oppositeDirectionBefore;
                Layout();
                setTimeout(() => {
                  Layout();
                  calibrating = false;
                  if (!localStorage.getItem('gameInstructionsGeduldspiel')) showGameInstructions();
                }, 500);
              restartLevel()
              break;
              }
              else {
                if (randomMapCreatorVisable.checked) {
                  x1 = checkpoint.position.x;
                  y1 = checkpoint.position.y;
                  time = 0;
                  if (newRandomLevelAfterGoal.checked) {
                    deleteAllElements();
                    automaticallyCreateNewRandomMap(0);
                  }
                  else alert("You reached the goal!");
                }
                else zielErreicht();
                i = 4;
            }
      }
      if ((randomMapCreatorVisable.checked && joyStickPlay)) layoutObjs();
        if ((joyStickPlay.checked && document.getElementById('courceSelection').value != "show Scores" && !currentLevel.rotatingWall && !currentLevel.rotatingDreieck) || deathMarkers.length) Layout();
        drawJoystick();
        if (currentLevel.blinkWall) blinkWall();
      }, 25);
    }
    function automaticallyCreateNewRandomMap(equalAmoutOfObj) {
      var objectsBefore = Object.keys(objects).reduce((acc, val) => acc + objects[val].length, 0);
      createRandomMap(true);
      setTimeout(() => {
        if (Object.keys(objects).reduce((acc, val) => acc + objects[val].length, 0) == objectsBefore) equalAmoutOfObj++;
        if (fillScreenAutoNewLevel.checked && !equalAmoutOfObj) automaticallyCreateNewRandomMap(equalAmoutOfObj);
        else setSpawnPoints();
      }, 1);
    }
    function drawJoystick() {
      if (joyStick && joyStick.coordinates && joyStickPlay.checked) {
          canvas.fillStyle = "blue";
          canvas.beginPath();
          canvas.arc(joyStick.coordinates.x, joyStick.coordinates.y, 10, 0, Math.PI*2, false);
          canvas.fill();
          canvas.strokeStyle = "green";
          canvas.beginPath();
          canvas.moveTo(joyStick.coordinates.x, joyStick.coordinates.y);
          canvas.lineTo(mausx, mausy);
          canvas.stroke();
          canvas.closePath();
        }
    }
    document.onkeydown = (event) => {
      if (event.key == "p") togglePause();
    }
    var pause = false;
    function togglePause() {
      pause = !pause;
      if (!pause) {
        increment();
      }
    }
    function blinkWall() {
      for (const wall of currentLevel.blinkWall) {
        if (!pause) {
          wall.changing.timeUntilChange -= 25;
        }
        if (wall.changing.timeUntilChange <= 0) {
          wall.changing.visible = !wall.changing.visible;
          if (wall.changing.visible) wall.changing.timeUntilChange = wall.timeVisible;
          else wall.changing.timeUntilChange = wall.timeInvisible;
          Layout();
        }
      }
    }

    function zielErreicht() {
      x1 = 0;
      y1 = 0;
      courceSelection.options[level.normal.number - 1].innerHTML = "✅ " +  level.normal.number + ". map";
      if (document.getElementById('courceSelection').value == "" && level[level.mode].number > Object.keys(level[level.mode].vorgefertigt).length) {
        alert("That was the last level :(");
      }
      if (["vorgefertigt", "easyMaps"].includes(level[level.mode].levelType)) {
        if (sensitivityAcc.x == currentLevel.sensitivity) {
          if (!highscores[level.mode][joyStickPlay.checked]) highscores[level.mode][joyStickPlay.checked] = {};
          if (!highscores[level.mode][joyStickPlay.checked][easyMaps.checked]) highscores[level.mode][joyStickPlay.checked][easyMaps.checked] = {};
          if (highscores[level.mode][joyStickPlay.checked][easyMaps.checked][currentLevel.levelNr] == undefined || highscores[level.mode][joyStickPlay.checked][easyMaps.checked][currentLevel.levelNr] > mins + ":" + secs + ":" + "0" + tenths) {
            if (highscores[level.mode][joyStickPlay.checked][easyMaps.checked][currentLevel.levelNr]) new Audio('https://adi.nicolaiweitkemper.de/Sounds/old-victory-sound-roblox-youtubemp3free.org.mp3').play();
            highscores[level.mode][joyStickPlay.checked][easyMaps.checked][currentLevel.levelNr] = mins + ":" + secs + ":" + "0" + tenths;
            localStorage.setItem("geduldsspielHighscores", JSON.stringify(highscores));
          }
        }
        level[level.mode].number++;
        document.getElementById('courceSelection').value = level[level.mode].number + ". map";
        courceSelected();
        if (level[level.mode].vorgefertigt[level[level.mode].number] == undefined) {
          console.log("everything Finished!");
          clearInterval(RotatingWall);
          clearInterval(RotatingDreieck);
          showScores();
        }
      }
    if (currentLevel != undefined) {
    x1 = currentLevel.spawnPoint.x;
    y1 = currentLevel.spawnPoint.y;
  }
  }
var calibratedDirection = 1;
if ([null, "undefined", "null"].includes(localStorage.getItem("calibratedDirection")) && gerät == "Handy") {
  setTimeout(() => {
    calibrate();
  }, 1000);
}
else {
  calibratedDirection = Number(localStorage.getItem("calibratedDirection"));
  if (!localStorage.getItem('gameInstructionsGeduldspiel')) showGameInstructions();
}
// "tutorial"
var tutorial = false;
function startTutorial() {
  alert("Bring the blue circle into the yellow one for 3 seconds by tilting your device. By doing this you can understand how to hold the device");
  mapBefore = Bild.src
  Bild = new Image();
  Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gelduldspiel/tutorial.png";
  Layout();
  setTimeout(() => {
    Layout();
    canvas.beginPath();
    canvas.arc(textur.width/2, textur.height/2, 50, 0, 2 * Math.PI, false);
    canvas.fillStyle = 'rgb(255, 242, 0)';
    canvas.fill();
  }, 500);
  window.scroll(0, 0);
  tutorial = true;
  inCircle = false;
  window.addEventListener("deviceorientation", detectDeviceOrientation);
}
var inCircle;
var inYellowTime;
function detectDeviceOrientation(event) {
  diff = {x: (event.beta/90)*(textur.width/2), y: (event.gamma/90)*(textur.height/2)}
  sphere1.style.top = textur.height/2 + diff.y - textur.getBoundingClientRect().top + "px";
  sphere1.style.left = textur.width/2 - diff.x - textur.getBoundingClientRect().left + "px";
  if (diff.x < 25 && diff.y < 25 && !inCircle) {
    inYellowTime = time;
    inCircle = true;
    // console.log("in");
  }
  if (diff.x > 25 || diff.y > 25) {
    inYellowTime = time;
    inCircle = false;
    // console.log("out");
  }
  if ((time - inYellowTime)*100 > 3000) {
    alert("You did it! So now try to reach the yellow again , but this time you also have to avoid anything black. ");
    Bild.src = mapBefore;
    restartLevel();
    Layout();
    tutorial = false;
    window.removeEventListener("deviceorientation", detectDeviceOrientation);
  }
}
    function showScores() {
      var pHighscores = highscores[level.mode][joyStickPlay.checked][easyMaps.checked];
      for (var i = 0; i < 11; i++) {
        try {
          document.getElementById("scores").deleteRow(0);
        } catch (e) {
          console.log("wanted to delete too many elements of table");
          i = 11
        }
      }
      document.getElementById('textur').style.display = "none";
      var cell = [ /*row.insertCell(0)*/ ];
        //  var cell = [/*row.insertCell(0)*/];
        for (var i1 = 1; i1 < Object.keys(level[level.mode][level[level.mode].levelType]).length && ["vorgefertigt", "easyMaps"].includes(level[level.mode].levelType); i1++) {
            if (i1 < pHighscores.length + 1) {
              cell[cell.length - 2] = row.insertCell(i1);
              if (pHighscores[i1]) cell[cell.length - 2].innerHTML = pHighscores[i1];
              if (pHighscores[i1] > pHighscores[name][i1]) cell[cell.length - 2].style.color = "green";
              else if (pHighscores[i1] < pHighscores[name][i1]) cell[cell.length - 2].style.color = "red";
              else if (name == Object.keys(pHighscores)[i]) cell[cell.length - 2].style.color = "blue";
              else cell[cell.length - 2].style.color = "black";

            } else {
              cell[cell.length - 2] = row.insertCell(i1);
              //  cell[cell.length - 2].innerHTML = "unmade";
              //  cell[cell.length - 2].style.color = "black";
            }
        }
        if (table) var row = table.insertRow(i);
        if (i == 0) {}
        //  var row = table.insertRow(i+1);
        // var row = table.insertRow(i + 1);
      //  var row = table.insertRow(0);
      //  var cell = [/*row.insertCell(0)*/];
      // cell.push(row.insertCell(0));
      // cell[cell.length - 1].innerHTML = "name";f
      var row = table.insertRow(0);
      cell.push(row.insertCell(0));
      cell[cell.length - 1].innerHTML = "name";
      for (var i1 = 1; i1 < Object.keys(level[level.mode][level[level.mode].levelType]).length; i1++) {
        cell.push(row.insertCell(i1));
        cell[cell.length - 1].innerHTML = (i1) + ". Map";
      }
    }
    // Für rotatingDreieck:
    const point = (x, y) => ({
      x,
      y
    });
    var triangle = createPath([point(0,-25), point(-50,-75), point(-100,-25)]);
    var rectangle = createPath([point(0,-25), point(-50,-25), point(-50,-125), point(0,-125)]);

    function drawPath_V2(path, x, y, scale, angle, strokeStyle, fillStyle) {
      canvas.setTransform(scale, 0, 0, scale, x, y);
      canvas.rotate(angle);
      fillStyle && (canvas.fillStyle = fillStyle, canvas.fill(path));
      strokeStyle && (canvas.strokeStyle = strokeStyle, canvas.stroke(path));
    }
    function drawRechteck(x, y, width, height, angle) {
      canvas.fillStyle = "black";
      canvas.setTransform(1, 0, 0, 1, x, y);
      canvas.rotate(angle);
      canvas.fillRect(Math.floor(-width/2), Math.floor(-height/2), width, height);
    }
    var rotationStartTime = 0;
    var rotationTime = 0;
    function renderLoop(time) {
      if (pause) rotationStartTime += (time - rotationTime);
      rotationTime = time;
      time -= rotationStartTime;
      Layout(true);
      canvas.fillStyle = "black";
      drawJoystick();
      //  canvas.clearRect(0, 0, textur.width, textur.height);
      const scale = Math.sin(time / 500) * 0.2 + 1.0;
      const scale2 = Math.cos(time / 1000) * 0.4 + 1.0;
    //  if (["vorgefertigt", "easyMaps"].includes(level[level.mode].levelType)) Layout();
    if (currentLevel.rotatingDreieck) {
      for (const dreieck of currentLevel.rotatingDreieck) {
        drawPath_V2(triangle, dreieck.x, dreieck.y, dreieck.size / 10 /*dreieck.size*/ ,
          time / (dreieck.timeFor360GradRotation/2) * Math.PI + dreieck.angle*Math.PI/180 /*dreieck.angle*/ , "black", "black", i);
      }
    }
    if (currentLevel.rotatingWall) {
      for (const wall of currentLevel.rotatingWall) {
        drawRechteck(wall.x, wall.y, wall.width, wall.height, time / (wall.timeFor360GradRotation/2) * Math.PI + wall.angle*Math.PI/180);
      }
    }
    if (currentLevel.rotating) {
      for (const obj of currentLevel.rotating) {
        var color = "black";
        if (selected.obj?.number == obj.objNumber) color = "red";
        if (obj.shape && obj.shape == "randomMapCreator") drawPath_V2(obj.path, obj.position.x, obj.position.y, obj.sizeRelationToOriginal, (time / (obj.miliSecsPerRotation/2) * Math.PI) + obj.angle*Math.PI/180, "", color); //360 every 4 second
      }
    }
      canvas.setTransform(1, 0, 0, 1, 0, 0);
      // bullets animation
      if (currentLevel.cannons) {
        for (var cannon of currentLevel.cannons) {
          canvas.fillRect(cannon.x, cannon.y, cannon.width, cannon.height);
          cannon.timeGone += 16;
          if (cannon.timeGone == 16 || cannon.timeGone >= cannon.speed) {
            cannon.timeGone = 1;
            bullets.push({speed: cannon.bulletSpeed, x: cannon.x + 1*Math.abs(cannon.direction.y), y: cannon.y + 1*Math.abs(cannon.direction.x), width: cannon.width - 2*Math.abs(cannon.direction.y), height: cannon.height - 2*Math.abs(cannon.direction.x), direction: cannon.direction});
          }
        }
      }
      for (var bullet of bullets) {
        bullet.x += bullet.speed*bullet.direction.x;
        bullet.y += bullet.speed*bullet.direction.y;
        canvas.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      }
      bullets = bullets.filter(b => b.x < window.innerWidth + 101 && b.y < textur.height && b.y >= -(b.height) && b.x >= -(b.width));
      if (currentLevel.cannons || currentLevel.rotatingDreieck || currentLevel.rotatingWall || currentLevel.rotating) {
        requestAnimationFrame(renderLoop);
      }
    }
    function createPath(points, randomMapCreator, middle) {
    var cx = 0; cy = 0;
    for (const p of points) {
        cx += p.x;
        cy += p.y;
    }
    cx /= points.length;
    cy /= points.length;

    const path = new Path2D;
    for (const p of points) {
      if (randomMapCreator) path.lineTo(p.x - middle.x, p.y - middle.y);
      else path.lineTo(p.x - cx , p.y - cy);
    }
    path.closePath();
    path.data = {points, middle};
    return path;
  }

    function boundingBoxCheck() {
      if (x1 < 0) {
        x1 = 0;
        vx1 = -vx1;
      }
      if (y1 < 0) {
        y1 = 0;
        vy1 = -vy1;
      }
      if (x1 > textur.width - JSON.parse(sphere1.style.width.toString().split('px')[0]) / 2) {
        x1 = textur.width - JSON.parse(sphere1.style.width.toString().split('px')[0]) / 2;
        vx1 = -vx1;
      }
      if (y1 > textur.height - JSON.parse(sphere1.style.height.toString().split('px')[0]) / 2) {
        y1 = textur.height - JSON.parse(sphere1.style.height.toString().split('px')[0]) / 2;
        vy1 = -vy1;
      }
      if (x2 < 0) {
        x2 = 0;
        vx2 = -vx2;
      }
      if (y2 < 0) {
        y2 = 0;
        vy2 = -vy2;
      }
      if (x2 > textur.width - JSON.parse(sphere1.style.width.toString().split('px')[0]) / 2) {
        x2 = textur.width - JSON.parse(sphere1.style.width.toString().split('px')[0]) / 2;
        vx2 = -vx2;
      }
      if (y2 > textur.height - JSON.parse(sphere1.style.height.toString().split('px')[0]) / 2) {
        y2 = textur.height - JSON.parse(sphere1.style.height.toString().split('px')[0]) / 2;
        vy2 = -vy2;
      }
    }
    var deathMarkers = [];
    function Layout(calledByRotateLoop) {
      if (!randomMapCreatorVisable.checked) {
        // if (["vorgefertigt", "easyMaps"].includes(level[level.mode].levelType)) {
          canvas.drawImage(Bild, 0, 0/*, window.innerWidth, AblageListe[5]*/);
        // }
        // visualize blinkWalls
        canvas.fillStyle = "black";
        for (let i = 0; i < currentLevel?.blinkWall?.length; i++) {
          var wall = currentLevel.blinkWall[i];
          if (wall.changing.visible) canvas.fillRect(wall.x, wall.y, wall.width, wall.height);
        }
      }
      for (const marker of deathMarkers) {
        canvas.fillStyle = "hsla(240, 100%, 50%, " + marker.visibility + ")";
        canvas.fillRect(marker.x, marker.y, marker.width, marker.height);
        if (!calledByRotateLoop) marker.visibility -= 0.0075;
      }
      deathMarkers = deathMarkers.filter(x => x.visibility > 0);
    }
    // stopWatch:
    var time = 0;
    var running = 0;

    function startPause() {
      if (running == 0) {
        running = 1;
        time = 0;
        increment();
      } else {
        running = 0;
      }
    }

    function reset() {
      running = 0;
      timer = 0;
    }

    function increment() {
      if (running == 1) {
        setTimeout(function() {
          time++;
          mins = Math.floor(time / 10 / 60);
          secs = Math.floor(time / 10);
          secs -= 60 * mins;
          tenths = time % 10;
          if (mins < 10) {
            mins = "0" + mins
          }
          if (secs < 10) {
            secs = "0" + secs;
          }
          stopClockText.innerHTML = mins + ":" + secs + ":" + "0" + tenths;
          if (!randomMapCreatorVisable.checked && stopClockText.style.color != "red" && highscores.normal[joyStickPlay.checked] && highscores.normal[joyStickPlay.checked][easyMaps.checked] && highscores.normal[joyStickPlay.checked][easyMaps.checked][currentLevel.levelNr] < mins + ":" + secs + ":" + "0" + tenths) {
            new Audio('https://adi.nicolaiweitkemper.de/Sounds/deep%20Fail%20-%20N%c3%b6%c3%b6t.mp3').play();
            stopClockText.style.color = "red";
          }
          if (!pause) increment();
        }, 100);
      }
    }


    function readMouseMove(e) {
      mausx = e.clientX + scrollX;
      mausy = e.clientY + scrollY;
      folgenMouseMove();
      //  console.log(mausx + " - " + mausy);
    }
    function folgenMouseMove() {
      if (state.x) {
        if (state.type == "rectangle") {
          selected.obj.width = mausx - state.x;
          selected.obj.height = mausy - state.y;
          selected.obj.hitbox = calculateHitbox('rectangle', selected.obj); 
          selected.obj.middle = calculateMiddle('rectangle', selected.obj); 
          selected.obj.path = calculatePath('rectangle', selected.obj);
        }
        if (state.type == "triangle") {
          selected.obj.width = mausx - state.x;
          selected.obj.height = mausy - state.y;
          selected.obj.hitbox = calculateHitbox('triangle', selected.obj); 
          selected.obj.middle = calculateMiddle('triangle', selected.obj); 
          selected.obj.path = calculatePath('triangle', selected.obj);
        }
        if (state.type == "circle") {
          selected.obj.radius = Math.sqrt(Math.pow(mausx - state.x, 2) + Math.pow(mausy - state.y, 2));
          selected.obj.hitbox = calculateHitbox('circle', selected.obj); 
          selected.obj.middle = calculateMiddle('circle', selected.obj); 
          selected.obj.path = calculatePath('circle', selected.obj);
        }
        if (state.type.includes("move")) {
          selected.obj.x += mausx - state.x;
          selected.obj.y += mausy - state.y;
          state = {x: mausx, y: mausy, type: "moveDone"};
          selected.obj.hitbox = calculateHitbox(selected.type, selected.obj); 
          if (selected.type != "circle") {
            selected.obj.middle = calculateMiddle(selected.type, selected.obj); 
            selected.obj.path = calculatePath(selected.type, selected.obj);
          }
        }
      }
    }
    document.onmousemove = readMouseMove
    var state = {}
    textur.onmousedown = () => {
      folgenMouseDown();
    }
    function folgenMouseDown() {
      state = {x: mausx, y: mausy, type: "move"};
      if (addRectangle.style.backgroundColor == "rgb(0, 251, 255)") {
        createRectangles(0, 0, mausx, mausy, true)
        state.type = "rectangle";
      }
      if (addTriangle.style.backgroundColor == "rgb(0, 251, 255)") {
        createTriangles(0, 0, mausx, mausy, 0, true)
        state.type = "triangle";
      }
      if (addCircle.style.backgroundColor == "rgb(0, 251, 255)") {
        createCircles(0, mausx, mausy, true)
        state.type = "circle";
      }
    }
    textur.onmouseup = () => {
      folgenMouseUp();
    }
    function folgenMouseUp() {
      // addRectangle.style.backgroundColor = "";
      state = {}
    }

    // var f = function() {
    //   var eventHandler = function(event) {
    //     //  console.log(window.scrollX + " - " + window.scrollY);
    //     console.log("scroll - " + scrollY);
    //   };
    //   window.addEventListener('scroll', eventHandler, false)
    // };
    // window.addEventListener('DOMContentLoaded', f, false)

    function visible(list) {
      for (var i = 0; i < list.length; i++) {
        document.getElementById(list[i][0]).style.display = list[i][1];
      }
    }
    AblageListe[3] = false;

    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    document.addEventListener('touchmove', touch);
    document.addEventListener('touchstart', touch);
    document.addEventListener('touchend', touch);
    var joyStick;
  function touch(ev) {
    if (joyStickPlay.checked && ev.type == "touchend" && joyStick.coordinates) {
      //textur.style.touchAction = '';
      mausx = joyStick.coordinates.x;
      mausy = joyStick.coordinates.y;
    }
    if (ev.type == "touchend" && (state.type != "move")) {
      folgenMouseUp();
      delete selected.obj;
    }
    if (ev.touches[0] != undefined) {
        mausx = ev.touches[0]["pageX"]// + scrollX;
        mausy = ev.touches[0]["pageY"]// + scrollY;
      }
    if (ev.type == "touchmove") {
      folgenMouseMove();
    }
    if (joyStickPlay.checked && ev.type == "touchstart" && mausy < textur.getBoundingClientRect().bottom) {
      joyStick = {coordinates : {x: mausx, y: mausy}};
      // if (!ev.touches[1]) textur.style.touchAction = 'none';
      // else textur.style.touchAction = '';
    }
    if (ev.type == "touchstart") {
      folgenMouseDown();
    }
  }
  function cssToNumber(string) {
    return JSON.parse(string.toString().split("px")[0]);
  }
  // cannon
var bullets = [];

  </script>
</body>

</html>
