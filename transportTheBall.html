<title>transport the ball</title>
<meta charset="utf-8">
<canvas id="textur" onclick="canvasClicked();" width="1582" height="740"></canvas>
<h1 id="nameEingeloggt" onclick='name = prompt ("Which user(name) do you want to log in?"); nameEingeloggt.innerHTML = "als " + name + " eingeloggt"; getDatabase();'></h1>
<script src="https://adi.nicolaiweitkemper.de/Database2/js.js"></script>
<select name="course" id="gameModeSelection" value="normal" onchange="modeSelected(value);">
  <option id="normalSelection" value="normal">normal</option>
  <option id="magnetSelection" value="magnet">magnet</option>
  <option id="allDirectionsSelection" value="allDirections">all directions</option>
  <option id="slideSelection" value="slide">slide</option>
  <!-- <option id="oppositeSelection" value="opposite">opposite</option> -->
  <option value="showScores">show scores</option>
</select>
<input id="easyMaps" type="checkbox"> easy map versions
<br>
<input type="checkbox" onchange="inOrAgainstDirection *= -1; setupLevel(true);" id="oppositeCheck"> opposite
<br>
<select name="course" id="levelSelector" value="normal" onchange="levelSelected(value);"></select>
<select id="checkpointSelection" onchange="checkpointSelected(value);">

</select>
<button name="button" onclick="removeCheckpoint();">spawn one spawnpoint before (checkpoint will be removed)</button>
<br>
<button type="button" onclick="scrollingInterac.user = false; window.scroll(cssToNumber(sphere.schieber.style.left), cssToNumber(sphere.schieber.style.top))" name="button">autoscroll again</button>
<p id="joyStickPlayP"> <input type="checkbox" onchange="if (checked) textur.style.touchAction = 'none';" id="joyStickPlay"> joystick control </p>
<br>
<h3>sensibility</h3>
<input type="range" min="1" onchange="if (confirm('As long as you play with changed sensibility, the progress and the score will not be saved after leaving the website. If you do not want to continue, please press cancel!')) {saveHighscores = false; sensibility = {x: value, y: value};} value = sensibility.x" max="35" value="17" class="slider" id="sensibility">
<button type="button" id="normalSensibility" onclick="normalSensibility();" name="button">back to normal</button>
<br>
<select id="tabletPositionModeSelection">
  <option>flat (most natural)</option>
  <option>almost on end (slopes away from you a bit, best? for your posture)</option>
  <option>on end (better for your posture)</option>
</select>
<div id="ball">
  <style>
    .shape {
      position: absolute;
      width: 50px;
      height: 50px;
      -webkit-radius: 50px;
      margin: 0;
      width padding: 0;
    }

    #sphere1 {
      border-radius: 50px;
      background-color: blue;
    }

    #sphere2 {
      border-radius: 50px;
      background-color: red;
    }
  </style>
</div>
<div id="content">
  <div class="shape" id="sphere1"></div>
</div>
<div id="content">
  <div class="shape" id="sphere2"></div>
</div>
<table id="scores"></table>

<script>
  function normalSensibility() {
    if (oppositeCheck.checked) sensibility = {x: 1, y: 1};
    else if (!level[level.mode][level.aktuell].sensibility) sensibility = {x: 17, y: 17};
    else sensibility = level[level.mode][level.aktuell].sensibility;
    document.getElementById('sensibility').value = sensibility;
    saveHighscores = true;
  }
  var canvas = textur.getContext('2d'); //Dimension
  var highscores = {};
  var checkpoints = {};
  if (!localStorage.getItem("storedName")) {
    var name = prompt("What's your user name? (This information is needed to save your highscores (best time) and level progress)");
    while (Object.keys(highscores.normal).includes(name) && !confirm('This username is in use already! Do you want to sign into this account?')) {
      var name = prompt("So What's your user name then? (This information is needed to save your highscores (best time))");
    }
  }
  else var name = localStorage.getItem("storedName");
localStorage.setItem("storedName", name);
  nameEingeloggt.innerHTML = "als " + name + " eingeloggt"
  var x1 = 10,
    y1 = 177; //window.innerHeight - 150 + 3,
  x2 = 0, y2 = 0,
    vx1 = 0, vy1 = 0,
    vx2 = 0, vy2 = 0,
    ax1 = 0, ay1 = 0;

  var sphere = {
    schieber: document.getElementById("sphere1"),
    ball: document.getElementById("sphere2")
  };
  sphere.schieber.style.width = "50px";
  sphere.schieber.style.height = "50px";
  sphere.schieber.style.ball = "50px";
  sphere.schieber.style.ball = "50px";
  var level = {
    aktuell: 0,
    mode: "normal",
    normal: {
      1: {

      },
      2: {
        ballTeleporter: [{
          ballSide: {
            x: 150,
            y: 250,
            width: 100,
            height: 100
          },
          ballTeleportedSide: {
            x: 833,
            y: 377
          },
          schieberSide: {
            x: 777,
            y: 444,
            width: 50,
            height: 50
          }
        }]
      },
      3: {
        checkpointWhen_touches: "schieber"
      },
      4: {
        heart: {
          ball: {
            min: 17,
            max: 44,
            pixelPerFunctionCall: 3,
            waitBeforeDirectionSwitchInSec: {
              min: 1,
              max: 2,
              levelBegin: 0
            }
          },
          schieber: {
            min: 37,
            max: 47,
            pixelPerFunctionCall: 3,
            waitBeforeDirectionSwitchInSec: {
              min: 2,
              max: 1
            }
          }
        },
        sizes: {
          schieber: {
            width: 47,
            height: 47
          },
          ball: {
            width: 44,
            height: 44
          }
        }
      },
      5: {
        invisible: {
          timeUntilInvisible: 3,
          timeUntilVisivleAgain: 3,
          anyOtherSide: true,
          amStück: {
            unvisible: true,
            visible: true
          }
        }
      },
      6: {
        sizes: {
          ball: {
            width: 200,
            height: 55
          },
          schieber: {
            width: 44,
            height: 88
          }
        },
        spawnPoint: {
          schieber: {
            x: 155,
            y: 160
          },
          ball: {
            x: 155,
            y: 250
          }
        }
        /*
        schieber: {
          x: 155,
          y: 200
        },
        ball: {
          x: 155,
          y: 250
        }
        */
      },
      7: {
        sizes: {
          ball: {
            width: 17,
            height: 17
          },
          schieber: {
            width: 17,
            height: 17
          }
        },
        spawnPoint: {
          schieber: {
            x: 83,
            y: 143
          },
          ball: {
            x: 97,
            y: 237
          }
        }
      }
    },
    magnet: {
      // 1. normale Level übernommen
      2: {},
      3: {},
      4: {},
      5: {},
      6: {
        rotating: [
        {
          shape: "rectangle",
          position: {
            x: 800,
            y: 355
          },
          angle: 144,
          miliSecsPerRotation: 2333,
          miliSecsPerRotationEasy: 3333,
          sizeRelationToOriginal: 6.4
        }
        ]
      }
    },
    allDirections: {
      1: {

      },
      2: {
        spawnPoint: {
          schieber: {
            x: 50,
            y: 333
          },
          ball: {
            x: 100,
            y: 333
          }
        }
      },
      3: {
        spawnPoint: {
          schieber: {
            x: 30,
            y: 50
          },
          ball: {
            x: 60,
            y: 150
          }
        }
      },
      4: {
        rotating: [
          {
        shape: "rectangle",
        position: {
          x: 800,
          y: 355
        },
        angle: 144,
        miliSecsPerRotation: 11111,
        miliSecsPerRotationEasy: 17777,
        sizeRelationToOriginal: 6.4,
        heart: {
          onceInMiliSec: 1111,
          onceInMiliSecEasy: 2777
        }
      }
    ],
    },
    5: {
      spawnPoint: {
        schieber: {
          x: 300,
          y: 600
        },
        ball: {
          x: 440,
          y: 500
        }
      }
    },
    6: {
      spawnPoint: {
        schieber: {
          x: 70,
          y: 120
        },
        ball: {
          x: 100,
          y: 199
        },
        rotating: [{
          shape: "rectangle",
          position: {
            x: 500,
            y: 355
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 1,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      }
    }
    },
    slide: {
      2: {

        slidestop: 44
      },
      4: {

        ballTeleporter: [{
          ballSide: {
            x: 1200,
            y: 600 - 50,
            width: 100,
            height: 100
          },
          ballTeleportedSide: {
            x: 1200,
            y: 211
          },
          schieberSide: {
            x: 1000,
            y: 290 - 50,
            width: 100,
            height: 100,
          }//,
          //checkpoint: true
        }]
      },
      5: {

      },
      6: {
        ballTeleporter: [{
          ballSide: {
            x: 1111,
            y: 550,
            width: 100,
            height: 100
          },
          ballTeleportedSide: {
            x: 600,
            y: 250
          },
          schieberSide: {
            x: 1111 - 277,
            y: 555,
            width: 233,
            height: 100
          }
        }]
      },
      7: {
        heart: {
          ball: {
            min: 13,
            max: 44,
            pixelPerFunctionCall: 1,
            waitBeforeDirectionSwitchInSec: {
              min: 1.5,
              max: 0
            }
          },
        }
      },
      8: {
        heart: {
          ball: {
            min: 13,
            max: 55,
            pixelPerFunctionCall: 1.7,
            waitBeforeDirectionSwitchInSec: {
              min: 2.2,
              max: 0
            }
          },
        }
      },
      9: {
        heart: {
          ball: {
            min: 13,
            max: 55,
            pixelPerFunctionCall: 1.7,
            waitBeforeDirectionSwitchInSec: {
              min: 2.2,
              max: 0
            }
          },
          schieber: {
            min: 13,
            max: 55,
            pixelPerFunctionCall: 1.7,
            waitBeforeDirectionSwitchInSec: {
              min: 2.2,
              max: 0
            }
          }
        },
        sizes: {
          ball: {
            width: 15,
            height: 15
          },
          schieber: {
            width: 53,
            height: 53
          }
        }
      },
      10: {
        rotating: [
          {
        shape: "rectangle",
        position: {
          x: 800,
          y: 577
        },
        angle: 144,
        miliSecsPerRotation: 11111,
        sizeRelationToOriginal: 1.9/*,
        heart: {
          onceInMiliSec: 1111
        }*/
      }
    ],
    sizes: {
      ball: {
        width: 15,
        height: 15
      },
      schieber: {
        width: 50,
        height: 50
      }
    },
  },
    }

  };
  level.magnet[1] = level.normal[1];
  level.slide[1] = level.normal[1];
  level.slide[3] = JSON.parse(JSON.stringify(level.slide[4]));
  level.slide[3].ballTeleporter[0].checkpoint = true;
  level.opposite = level.normal;
   // rotating examples:
//   var shapes = [
//     {
//       points: [
//         {
//           shape: "triangle",
//           position: {
//             x: 133,
//             y: 233
//           },
//           angle: 33,
//           miliSecsPerRotation: 7777,
//           heart: {
//             onceInMiliSec: 3333
//           }
//       },
//       {
//         shape: "rectangle",
//         position: {
//           x: 133,
//           y: 444
//         },
//         angle: 144,
//         miliSecsPerRotation: 9999,
//         heart: {
//           onceInMiliSec: 1111
//         }
//     },
//     {
//       shape: "thing",
//       points: [
//         {x: 0, y: 0},
//         {x: 0, y: 77},
//         {x: 100, y: 77},
//         {x: 100, y: 0}
//       ],
//       position: {
//         x: 222,
//         y: 222
//       },
//       angle: 90,
//       miliSecsPerRotation: 11111,
//       heart: {
//         onceInMiliSec: 500
//       }
//   },
//   {
//     shape: "thing",
//     points: [
//       {x: 0, y: 0},
//       {x: 177, y: 0},
//       {x: 133, y: 77}
//     ],
//     position: {
//       x: 333,
//       y: 444
//     },
//     angle: 180,
//     miliSecsPerRotation: 777,
//     heart: {
//       onceInMiliSec: 177
//     }
// }
//       ]
//     }
  // ]

  // transform points to forms:
  var point = (x, y) => ({x, y});
  var triangle = createPath(point(0,-25), point(-50,-75), point(-100,-25));
  var rectangle = createPath(point(0,-25), point(-50,-25), point(-50,-125), point(0,-125));
  var pointShapes = [];
  /*for (var i = 0; i < level[level.mode][level.aktuell].rotating.length; i++) {
    for (var i1 = 0; i1 < level[level.mode][level.aktuell].rotating[i].points.length; i1++) {
      if (level[level.mode][level.aktuell].rotating[i].points[i1].shape == "thing") {
      var points = [];
      for (var i2 = 0; i2 < level[level.mode][level.aktuell].rotating[i].points[i1].points.length; i2++) {
        points.push(point(level[level.mode][level.aktuell].rotating[i].points[i1].points[i2].x, level[level.mode][level.aktuell].rotating[i].points[i1].points[i2].y));
      }
      if (points[1] && !points[2]) pointShapes.push({path: createPath(points[0], points[1]), position: level[level.mode][level.aktuell].rotating[i].points[i1].position, angle: level[level.mode][level.aktuell].rotating[i].points[i1].angle, miliSecsPerRotation: level[level.mode][level.aktuell].rotating[i].points[i1].miliSecsPerRotation, onceInMiliSec: level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSec, sizeRelationToOriginal: level[level.mode][level.aktuell].rotating[i].sizeRelationToOriginal});
      if (points[2] && !points[3]) pointShapes.push({path: createPath(points[0], points[1], points[2]), position: level[level.mode][level.aktuell].rotating[i].points[i1].position, angle: level[level.mode][level.aktuell].rotating[i].points[i1].angle, miliSecsPerRotation: level[level.mode][level.aktuell].rotating[i].points[i1].miliSecsPerRotation, onceInMiliSec: level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSec, sizeRelationToOriginal: level[level.mode][level.aktuell].rotating[i].sizeRelationToOriginal});
      if (points[3] && !points[4]) pointShapes.push({path: createPath(points[0], points[1], points[2], points[3]), position: level[level.mode][level.aktuell].rotating[i].points[i1].position, angle: level[level.mode][level.aktuell].rotating[i].points[i1].angle, miliSecsPerRotation: level[level.mode][level.aktuell].rotating[i].points[i1].miliSecsPerRotation, onceInMiliSec: level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSec, sizeRelationToOriginal: level[level.mode][level.aktuell].rotating[i].sizeRelationToOriginal});

    }
    }
  }*/

  for (var i = 1; i < Object.keys(level.slide).length + 1; i++) {
    if (!level.slide[i].slideStop) level.slide[i].slideStop = 44;
    if (!level.slide[i].slideLength) level.slide[i].slideLength = 20;
  }
  for (var i = 0; i < Object.keys(level).length; i++) {
    if (!(["aktuell", "mode"].includes(Object.keys(level)[i]))) {
      for (var i1 = 1; i1 < Object.keys(level[Object.keys(level)[i]]).length + 1; i1++) {
        if (!level[Object.keys(level)[i]][i1].sizes) level[Object.keys(level)[i]][i1].sizes = {ball: {width: 50, height: 50}, schieber: {width: 50, height: 50}};
        if (!level[Object.keys(level)[i]][i1].bounceUpDown) level[Object.keys(level)[i]][i1].bounceUpDown = 3;
        if (!level[Object.keys(level)[i]][i1].bounceleftRight) level[Object.keys(level)[i]][i1].bounceleftRight = 10;
        if (!level[Object.keys(level)[i]][i1].checkpointWhen_touches) level[Object.keys(level)[i]][i1].checkpointWhen_touches = "ball";
        if (!level[Object.keys(level)[i]][i1].spawnPoint) level[Object.keys(level)[i]][i1].spawnPoint =     {
                    schieber: {
                      x: 155,
                      y: 200
                    },
                    ball: {
                      x: 155,
                      y: 266
                    }
                  }
      }
    }
  }
  level.slide[1].slidestop = 16;
  var alertWhenFinishedSaving = false;
  window.onbeforeunload = function(){
  console.log("Leave Website");
    if (dbSetWarteschlange.length > 0) {alertWhenFinishedSaving = true; return 'Es wurden noch nicht alle Änderungen gespeichert! Bitte klicken sie auf "bleiben" und warten sie auf die Meldung, dass der Speichervorgang erfolgreich war!';}
};
  getDatabase();
function getDatabase() {
  dbGet("transportTheBall", "checkpoints " + name).then(result => {
    checkpoints = JSON.parse(result)
  }).catch(function(e) {
    console.log(e);
  });
  dbGet("transportTheBall", "highscores").then(result => {
    highscores = JSON.parse(result);
    for (var i = 0; i < Object.keys(level).length; i++) {
      if (highscores[Object.keys(level)[i]] && highscores[Object.keys(level)[i]][Object.keys(level[Object.keys(level)[i]]).length] && highscores[Object.keys(level)[i]][Object.keys(level[Object.keys(level)[i]]).length][name]) document.getElementById(Object.keys(level)[i] + "Selection").innerHTML = "✅" + Object.keys(level)[i];
    }
    modeSelected("normal");
  }).catch(function(e) {
    for (var i = 0; i < Object.keys(level).length; i++) {
      if (highscores[Object.keys(level)[i]] && highscores[Object.keys(level)[i]][Object.keys(level[Object.keys(level)[i]]).length] && highscores[Object.keys(level)[i]][Object.keys(level[Object.keys(level)[i]]).length][name]) document.getElementById(Object.keys(level)[i] + "Selection").innerHTML = "✅" + Object.keys(level)[i];
    }
    levelSelector.style.display = "none";
    modeSelected("normal");
  });
}
function checkpointSelected(value) {
  if (value.includes(".")) checkpoint.push(JSON.parse(JSON.stringify(checkpoint[value.split(".")[0]])));
  else checkpoint.push(JSON.parse(JSON.stringify(checkpoint[0])));
  // checkpoint[checkpoint.length - 1].notListed = true;
  restartLevel();
}
  var direction = "long";
  var Bild = new Image();
  // function scrollWindow(direction, achse, scrollXBefore, scrollYBefore) {
  //   scrolling = true;
  //   if (achse == "right") window.scroll(scrollX + direction, scrollY);
  //   else window.scroll(scrollX, scrollY + direction);
  //   var scroll = {aktuell: {x: scrollX, y: scrollY}, max: {x: 0, y: 0}};
  //   window.scroll(Bild.width, Bild.height);
  //   scroll.max.x = scrollX;
  //   scroll.max.y = scrollY;
  //   window.scroll(scroll.aktuell.x, scroll.aktuell.y);
  //   if (((achse == "right" && direction == 1 && scrollX != scroll.max.x) || (achse == "right" && direction == -1 && scrollX != 0) || (achse == "down" && direction == 1 && scrollY != scroll.max.y) || (achse == "down" && direction == -1 && scrollY != 0)) &&  ((Bild.width > window.innerWidth && achse == "right") || (Bild.height > window.screen.height && achse != "right") && ((achse == "right" && scrollX < window.innerWidth - level[level.mode][level.aktuell].sizes.schieber.width*2 + scrollXBefore) || (achse != "right" && scrollY < window.innerHeight - level[level.mode][level.aktuell].sizes.schieber.height*2 + scrollYBefore)))) {
  //     setTimeout(function () {
  //       scrollWindow(direction, achse, scrollXBefore, scrollYBefore);
  //     }, 1);
  //   }
  //   else scrolling = false;
  // }
  var sensibility = {x: 17, y: 17};
  if (window.DeviceMotionEvent != undefined || joyStick.coordinates) {
    window.ondevicemotion = function(e) {
      if (tabletPositionModeSelection.value.split(' (')[0] == "flat") ax1 = inOrAgainstDirection * event.accelerationIncludingGravity.x * sensibility.x;
      else if (tabletPositionModeSelection.value.split(' (')[0] == "almost on end") ax1 = inOrAgainstDirection * (event.accelerationIncludingGravity.z - 1) * (-sensibility.x);
      else ax1 = inOrAgainstDirection * (event.accelerationIncludingGravity.z + 1.7) * (-sensibility.x);
      if (tabletPositionModeSelection.value.split(' (')[0] != "flat") ay1 = inOrAgainstDirection * event.accelerationIncludingGravity.y * 1.88 * sensibility.y;
      else ay1 = inOrAgainstDirection * event.accelerationIncludingGravity.y * sensibility.y;
    }
    setInterval(function() {
      // joy-stick:
      var nextCoordinates = {x: 0, y: 0};
      if (joyStickPlay.checked && document.getElementById('gameModeSelection').value != "show Scores") {
        if (level.aktuell != "winnerScreen" && !level[level.mode][level.aktuell].rotating) Layout();
        if (joyStick && joyStick.coordinates) {
          if (JSON.parse(document.getElementById('sensibility').value) < 12) document.getElementById('sensibility').value = 12
          if (!oppositeCheck.checked) var nextCoordinates = {x: x1 + (mausx - joyStick.coordinates.x)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11), y: y1 + (mausy - joyStick.coordinates.y)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11)};
          else var nextCoordinates = {x: x1 - (mausx - joyStick.coordinates.x)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11), y: y1 - (mausy - joyStick.coordinates.y)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11)};
          nextCoordinates = {x: nextCoordinates.x - scrollX/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11), y: nextCoordinates.y - scrollY/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11)}
        }
      }
      // zoom: window.parent.document.body.style.zoom = 1.5;
      // scroll when at bootom
      if (level.aktuell == "winnerScreen") sphere.schieber.style.backgroundColor = "rgba(" + Math.round(Math.random()*255) + ", " + Math.round(Math.random()*255) + ", "+ Math.round(Math.random()*255) + ",1)";
      else/* if (!scrollingByUser)*/ {
        scrollingInterac.PC = true;
        if (!scrollingInterac.user && x1 > window.innerWidth + scrollX - level[level.mode][level.aktuell].sizes.schieber.width*5) window.scroll(scrollX + 3, scrollY);
        if (!scrollingInterac.user && y1 > window.innerHeight + scrollY - level[level.mode][level.aktuell].sizes.schieber.height*5) window.scroll(scrollX, scrollY + 3);
        if (!scrollingInterac.user && x1 - scrollX < (level[level.mode][level.aktuell].sizes.schieber.width + level[level.mode][level.aktuell].sizes.ball.width*5) && scrollX > 2) window.scroll(scrollX - 3, scrollY);
        if (!scrollingInterac.user && y1 - scrollY < (level[level.mode][level.aktuell].sizes.schieber.height + level[level.mode][level.aktuell].sizes.ball.height*5) && scrollY > 2) window.scroll(scrollX, scrollY - 3);
        setTimeout(function () {
          scrollingInterac.PC = false;
        }, 23);
      }
      // scroll all the way down when at bottom
      // if (scrollX != Bild.width - window.screen.width && !scrolling && x1 > window.innerWidth + scrollX - level[level.mode][level.aktuell].sizes.schieber.width*2) scrollWindow(1, "right", scrollX, scrollY);
      // if (scrollY != Bild.height - window.screen.height && !scrolling && y1 > window.innerHeight + scrollY - level[level.mode][level.aktuell].sizes.schieber.height*2) scrollWindow(1, "down", scrollX, scrollY);
      // if (scrollX != 0 && !scrolling && x1 - scrollX < (level[level.mode][level.aktuell].sizes.schieber.width + level[level.mode][level.aktuell].sizes.ball.width*2) && scrollX > 2) scrollWindow(-1, "right", scrollX, scrollY);
      // if (scrollY != 0 && !scrolling && y1 - scrollY < (level[level.mode][level.aktuell].sizes.schieber.height + level[level.mode][level.aktuell].sizes.ball.height*2) && scrollY > 2) scrollWindow(-1, "down", scrollX, scrollY);

      var landscapeOrientation = window.innerWidth - window.innerHeight > 1;
      if (landscapeOrientation) {
        vx1 = vx1 + ay1;
        vy1 = vy1 + ax1;
        vx2 = vx2 + ay1;
        vy2 = vy2 + ax1;
      } else {
        vy1 = vy1 - ax1;
        vx1 = vx1 + ay1;
        vy2 = vy2 - ax1;
        vx2 = vx2 + ay1;
      }
      if (landscapeOrientation && direction == "small") {
        inOrAgainstDirection *= -1;
        direction = "long";
     } if (!landscapeOrientation && direction == "long") {
       inOrAgainstDirection *= -1;
       direction = "small";
      }
      vx1 = vx1 * 0.98;
      vy1 = vy1 * 0.98;
      ball.x = JSON.parse(sphere.ball.style.left.replace("px", ""));
      ball.y = JSON.parse(sphere.ball.style.top.replace("px", ""));
      coordinatesBefore = {x1: x1, y1: y1}
      if (!level[level.mode][level.aktuell] || !level[level.mode][level.aktuell].invisible || invisible.boolean == false) {
      if (joyStickPlay.checked && joyStick.coordinates) {
        if (nextCoordinates.x < 0) nextCoordinates.x = 0;
        if (nextCoordinates.x > textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""))) nextCoordinates.x = textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""));
        if (nextCoordinates.y < 0) nextCoordinates.y = 0;
        if (nextCoordinates.y > textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""))) nextCoordinates.y = textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""));
      }
      else nextCoordinates = {x: parseInt(x1 + vx1 / 50), y: parseInt(y1 + vy1 / 50)};
      // allDirections
      if (level.mode == "allDirections") {
      var collision = isCollide({x: /*nextCoordinates.x*/x1, y: /*nextCoordinates.y*/y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball);
      while (collision && !((nextCoordinates.y - y1) == 0 && (y1 - nextCoordinates.y) == 0 && (y1 - nextCoordinates.y) == 0 && (nextCoordinates.y - y1) == 0 && (nextCoordinates.y - y1) == 0 && (x1 - nextCoordinates.x) == 0 && (nextCoordinates.x - x1) == 0 && (nextCoordinates.x - x1) == 0 && (x1 - nextCoordinates.x) == 0)) {
        collision = isCollide({x: nextCoordinates.x, y: nextCoordinates.y, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball);
        if (collision && nextCoordinates.y < ball.y) {
          // setTimeout(function () {
            if (nextCoordinates.y > y1) ball.y += (nextCoordinates.y - y1)//3; // down
            else ball.y += (y1 - nextCoordinates.y)
          // }, 1);
        }
        if (collision && nextCoordinates.y > ball.y)  {
          // setTimeout(function () {
            if (y1 > nextCoordinates.y) ball.y -= (y1 - nextCoordinates.y)//3; // up
            else ball.y -= (nextCoordinates.y - y1)//3; // up
          // }, 1);
        }
        if (collision && nextCoordinates.x > ball.x) {
          // setTimeout(function () {
            if (x1 > nextCoordinates.x) ball.x -=  (x1 - nextCoordinates.x)//3; // left
            else ball.x -= (nextCoordinates.x - x1)
          // }, 1);
          }
        if (collision && nextCoordinates.x < ball.x) {
          // setTimeout(function () {
            if (nextCoordinates.x > x1) ball.x += (nextCoordinates.x - x1)//3;// right
            else ball.x += (x1 - nextCoordinates.x)
          // }, 1);
        }
    }
    }

      // magnet
      if (level.mode == "magnet") {
      if (nextCoordinates.y + 30 > ball.y) {
        // setTimeout(function () {
        ball.y += (nextCoordinates.y - y1) / 10 + timeDirection.down; // down
        // }, 1);
        timeDirection.down += 0.1 //1
      }
      // else if (timeDirection.over.down < 50) {
      //   timeDirection.over.down++;
      //   ball.y += (nextCoordinates.y - y1)/10; // down
      // }
      else {
        timeDirection.down = 0;
        timeDirection.over.down = 0;
      }
      if (nextCoordinates.y < ball.y + 30) {
        // setTimeout(function () {
        ball.y -= (y1 - nextCoordinates.y) / 10 + timeDirection.up; // up
        // }, 1);
        timeDirection.up += 0.1 //1
      }
      // else if (timeDirection.over.up < 50) {
      //   timeDirection.over.up++;
      //   ball.y -= (y1 - nextCoordinates.y)/10; // up
      // }
      else {
        timeDirection.up = 0;
        timeDirection.over.up = 0;
      }
      if (nextCoordinates.x < ball.x + 30) {
        // setTimeout(function () {
        ball.x -= (x1 - nextCoordinates.x) / 10 + timeDirection.left; // left
        // }, 1);
        timeDirection.left += 0.1 //1
      }
      // else if (timeDirection.over.left < 50) {
      //   timeDirection.over.left++;
      //   ball.x -=  (x1 - nextCoordinates.x)/10; // left
      // }
      else {
        timeDirection.left = 0;
        timeDirection.over.left = 0;
      }
      if (nextCoordinates.x + 30 > ball.x) {
        // setTimeout(function () {
        ball.x += (nextCoordinates.x - x1) / 10 + timeDirection.right; // right
        // }, 1);
        timeDirection.right += 0.1 //1
      }
      // else if (timeDirection.over.right < 50) {
      //   timeDirection.over.right++;
      //   ball.x += (nextCoordinates.x - x1)/10; // right
      // }
      else {
        timeDirection.right = 0;
        timeDirection.over.right = 0;
      }
    }
      if (level.mode == "slide" && isCollide({x: nextCoordinates.x, y:  nextCoordinates.y, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && zaehler == 0) moveDirection(directionBefore, nextCoordinates);
      invisibleDirectionCheck(nextCoordinates);
      // normal mode
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("left")) ball.x = x1 - cssToNumber(sphere./*schieber*/ball.style.width)//-= 3;
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("right")) ball.x = x1 + cssToNumber(sphere.schieber.style.width)//+= 3;
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("up")) ball.y = y1 - cssToNumber(sphere./*schieber*/ball.style.height)//-= 3;
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("down")) ball.y = y1 + cssToNumber(sphere.schieber.style.height) //+= 3;
    }
    else {
      invisibleDirectionCheck(nextCoordinates);
    }
      if (level[level.mode][level.aktuell] && level[level.mode][level.aktuell].invisible) {
        invisible.directions[invisible.direction] += 25;
      if (!invisible.boolean && invisible.directions[invisible.direction]/1000 > level[level.mode][level.aktuell].invisible.timeUntilInvisible) {
        invisible.mainDirection = invisible.direction;
        for (var i = 0; i < 4; i++) {
          /*if (Object.keys(invisible.directions)[i] != invisible.direction) */invisible.directions[Object.keys(invisible.directions)[i]] = 0;
        }
        invisible.boolean = true;
      }
      var totalTime = 0;
      for (var i = 0; i < 4; i++) {
        if (Object.keys(invisible.directions)[i] != invisible.mainDirection) totalTime += invisible.directions[Object.keys(invisible.directions)[i]];
      }
      if ((((level[level.mode][level.aktuell].invisible.anyOtherSide) && totalTime/1000 > level[level.mode][level.aktuell].invisible.timeUntilVisivleAgain) || ((!level[level.mode][level.aktuell].invisible.anyOtherSide && (invisible.directions.right/1000 > level[level.mode][level.aktuell].invisible.timeUntilVisivleAgain || invisible.directions.left/1000 > level[level.mode][level.aktuell].invisible.timeUntilVisivleAgain || invisible.directions.up/1000 > level[level.mode][level.aktuell].invisible.timeUntilVisivleAgain || invisible.directions.down/1000 > level[level.mode][level.aktuell].invisible.timeUntilVisivleAgain)))) && invisible.mainDirection != undefined) {
        for (var i = 0; i < 4; i++) {
          invisible.directions[Object.keys(invisible.directions)[i]] = 0;
        }
        invisible.boolean = false;
        invisible.mainDirection = undefined;
      }
      if (invisible.boolean) sphere.ball.style.display = "none";
      else sphere.ball.style.display = "inline";
    }
      sphere.ball.style.left = ball.x + "px";
      sphere.ball.style.top = ball.y + "px";
      checkColourCollisions();
      if (joyStick && joyStick.coordinates && joyStickPlay.checked) {
        canvas.fillStyle = "blue";
        canvas.beginPath();
        canvas.arc(joyStick.coordinates.x + scrollX, joyStick.coordinates.y + scrollY, 10, 0, Math.PI*2, false);
        canvas.fill();
        canvas.strokeStyle = "green";
        canvas.beginPath();
        canvas.moveTo(joyStick.coordinates.x + scrollX, joyStick.coordinates.y + scrollY);
        canvas.lineTo(mausx, mausy);
        canvas.stroke();
        canvas.closePath();
      }
    }, 25);
  }
  else if (gerät == "Handy") {
    alert("Please call up this website as https (secure) to be able to use the required motion control (Chrome recommended)");
    // alert("Bitte rufen sie diese Seite als https (sicher) auf, um die benötigte Bewegungssteuerung benutzen zu können!")
    gerät = "unsaveHandyBrowser";
  }
  var scrollingInterac = {user: false, PC: false}
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
  } else {
    var gerät = "PC"
    console.log("PC");
    scrollingInterac.user = true;
    joyStickPlayP.style.display = "none";
    joyStickPlay.checked = true;
  }
  var invisible = {directions: {left: 0, right: 0, up: 0, down: 0}, boolean: false};
  var checkpoint = {schieber: {x: 0, y: 0}, ball: {x: 0, y: 0}}
  var timeDirection = {
    right: 0,
    left: 0,
    up: 0,
    down: 0,
    over: {
      right: 0,
      left: 0,
      up: 0,
      down: 0
    }
  };
  var zaehler = 0;
  var geteiltDurch = 0.5;
  var coordinatesBefore;
  var bounceCoordinates;
  var scrolling = false;
  function invisibleDirectionCheck(nextCoordinates) {
    var invisibleDirection = invisible.direction;
    invisible.direction = {};
    if (x1 > nextCoordinates.x) invisible.direction.left = x1 - nextCoordinates.x;// = "left";
    if (x1 < nextCoordinates.x) invisible.direction.right = nextCoordinates.x - x1;// = "right";
    if (y1 > nextCoordinates.y) invisible.direction.up = y1 - nextCoordinates.y;// = "up";
    if (y1 < nextCoordinates.y) invisible.direction.down = nextCoordinates.y - y1;// = "down";
    var highestDirection = {number: 0};
    for (var i = 0; i < Object.keys(invisible.direction).length; i++) {
      if (invisible.direction[Object.keys(invisible.direction)[i]] > highestDirection.number && Object.keys(invisible.direction)[i] != invisible.mainDirection) {highestDirection.number = invisible.direction[Object.keys(invisible.direction)[i]]; highestDirection.string = Object.keys(invisible.direction)[i];}
    }
    if (level[level.mode][level.aktuell] != undefined && invisibleDirection != undefined && highestDirection.string != undefined && level[level.mode][level.aktuell].invisible && level[level.mode][level.aktuell].invisible.amStück && invisibleDirection != highestDirection.string && ((invisible.boolean == true && level[level.mode][level.aktuell].invisible.amStück.invisible == true) || (invisible.boolean == false && level[level.mode][level.aktuell].invisible.amStück.visible == true))) {
      for (var i = 0; i < 4; i++) {
        /*if (Object.keys(invisible.directions)[i] != invisible.direction) */invisible.directions[Object.keys(invisible.directions)[i]] = 0;
      }
    }
    invisible.direction = highestDirection.string;
    y1 = nextCoordinates.y;
    x1 = nextCoordinates.x;

    vx2 = vx2 * 0.98;
    vy2 = vy2 * 0.98;
    y2 = parseInt(y2 + vy2 / 30);
    x2 = parseInt(x2 + vx2 / 30);
    boundingBoxCheck();
    if (joyStickPlay.checked && joyStick.coordinates) {
      x1 = nextCoordinates.x;
      y1 = nextCoordinates.y;
      if (x1 < 0) x1 = 0;
      if (x1 > textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""))) x1 = textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""));
      if (y1 < 0) y1 = 0;
      if (y1 > textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""))) y1 = textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""));
    }
    sphere.schieber.style.top = y1 + "px";
    sphere.schieber.style.left = x1 + "px";
  }
  window.onscroll = function (e) {
    if (!scrollingInterac.PC) {
      scrollingInterac.user = true;
    }
    if (scrollY  < 5 && document.getElementById('gameModeSelection').value != "showScores"/*== 0 && scrollX == 0*/) scrollingInterac.user = false;
  }
  document.addEventListener('touchstart', touch);
  function touch(ev){
    scrollingInterac.user = true;
  }
  function moveDirection(pDirectionBefore, nextCoordinates) {
    if (zaehler != "newLevel") {
    if (pDirectionBefore.includes( "right") && nextCoordinates.x > x1) ball.x += (nextCoordinates.x - x1)/geteiltDurch;
    else if (pDirectionBefore.includes( "right")) ball.x += (x1 - nextCoordinates.x)/geteiltDurch;
    if (pDirectionBefore.includes( "left") && nextCoordinates.x > x1) ball.x -= (nextCoordinates.x - x1)/geteiltDurch;
    else if (pDirectionBefore.includes( "left")) ball.x -= (x1 - nextCoordinates.x)/geteiltDurch;
    if (pDirectionBefore.includes( "down") && nextCoordinates.y > y1) ball.y += (nextCoordinates.y - y1)/geteiltDurch;
    else if (pDirectionBefore.includes( "down")) ball.y += (y1 - nextCoordinates.y)/geteiltDurch;
    if (pDirectionBefore.includes( "up") && nextCoordinates.y > y1) ball.y -= (nextCoordinates.y - y1)/geteiltDurch;
    else if (pDirectionBefore.includes( "up")) ball.y -= (y1 - nextCoordinates.y)/geteiltDurch;
    zaehler++;
    sphere.ball.style.top = ball.y + "px";
    sphere.ball.style.left = ball.x + "px";
    checkColourCollisions();
    if (zaehler < /*20*/(level.slide[level.aktuell].slideLength) || (geteiltDurch < level.slide[level.aktuell].slidestop)) {
      if (zaehler > (level.slide[level.aktuell].slideLength - 1)/*19*/) geteiltDurch++;
      setTimeout(function () {
        moveDirection(pDirectionBefore, nextCoordinates);
      }, 10);
    }
    else {
      geteiltDurch = 0.5;
      zaehler = 0;
    }
  }
  }
  var directionBeforeScrolling = {x: 0, y: 0};
  function checkColourCollisions() {
    // scrollWithBall
    // if (directionBeforeScrolling.x > x1 && (x1 > window.innerWidth/2 - 17 && x1 < window.innerWidth/2 + 17) || (scrollX > 0)) window.scroll(scrollX - (directionBeforeScrolling.x - x1), scrollY);
    // if (directionBeforeScrolling.x < x1 && (x1 > window.innerWidth/2 - 17 && x1 < window.innerWidth/2 + 17) || (scrollX > 0)) window.scroll(scrollX +  (x1 - directionBeforeScrolling.x), scrollY);
    // if (directionBeforeScrolling.y > y1 && (y1 > window.innerHeight/2 - 17 && y1 < window.innerHeight/2 + 17) || (scrollY > 0)) window.scroll(scrollX, scrollY - (directionBeforeScrolling.y - y1));
    // if (directionBeforeScrolling.y < y1 && (y1 > window.innerHeight/2 - 17 && y1 < window.innerHeight/2 + 17) || (scrollY > 0)) window.scroll(scrollX, scrollY +  (y1 - directionBeforeScrolling.y));
    // directionBeforeScrolling = {x: x1, y: y1};
    var numbers = [
      [x1 + cssToNumber(sphere.schieber.style.width) - 7, y1 + cssToNumber(sphere.schieber.style.height) / 2],
      [x1 + cssToNumber(sphere.schieber.style.width) / 2, y1 - 8],
      [x1 + cssToNumber(sphere.schieber.style.width) / 2, y1 + cssToNumber(sphere.schieber.style.height) - 7],
      [x1 - 10, y1 + cssToNumber(sphere.schieber.style.height) / 2],

      [ball.x + cssToNumber(sphere.ball.style.width) - 7, ball.y + cssToNumber(sphere.ball.style.height) / 2],
      [ball.x + cssToNumber(sphere.ball.style.width) / 2, ball.y - 8],
      [ball.x + cssToNumber(sphere.ball.style.width) / 2, ball.y + cssToNumber(sphere.ball.style.height) - 7],
      [ball.x - 10, ball.y + cssToNumber(sphere.ball.style.height) / 2]
    ]
    for (var i = 0; i < 8; i++) {
      // canvas.fillStyle = "red";
      // canvas.fillRect(numbers[i][0] - 10, numbers[i][1] - 10, 10, 10);
      try {
        data = canvas.getImageData(numbers[i][0], numbers[i][1], 1, 1);
        red = data.data[0];
        green = data.data[1];
        blue = data.data[2];
        alpha = data.data[3];
      } catch (e) {
        console.log("Das ist ein Fehler :( )");
      }
      if (!goalReached && (/*schwarzer Rand*/(red == 0 && blue == 0 && alpha == 255 && green == 0) || /*onGreen*/ (joyStickPlay.checked && red == 34 && blue == 76 && green == 177) || /*Durchlass Schieber*/ (red == 47 && green == 54 && blue == 153 && i > 3) || /*Durchlass Ball*/ (red == 237 && green == 28 && blue == 36 && i < 4))) {
        console.log("Fail!");
        time = 0;
        if (checkpoint.length > 1) time = checkpoint[checkpoint.length - 1].timeNeededToReach;
        zaehler = "newLevel";
        setTimeout(function () {
          zaehler = 0;
        }, 500);
        restartLevel();
      }
      if (red == 255 && blue == 0 && alpha == 255 && (green > 241) && i > 3 && level[level.mode][level.aktuell + 1] && level.aktuell != "winnerScreen") {
        console.log("goal reached (yellow)");
        goalReached = true;
          i = 8;
          sphere.ball.style.top = "0px";
          sphere.ball.style.left = "0px";
          ball.x = 0;
          ball.y = 0;
          // inOrAgainstDirection = 0;
          //restartLevel();
          setHighscores(true);
      }
      else if (!(sphere.ball.style.top == "0px" && sphere.ball.style.left == "0px") && red == 255 && blue == 0 && alpha == 255 && (green > 241) && i > 3 && level.aktuell != "winnerScreen") {
        i = 8;
        sphere.ball.style.top = "0px";
        sphere.ball.style.left = "0px";
        ball.x = 0;
        ball.y = 0;
        alert("This was the last level :( but you can check out the other modes if you haven't done that already!");
        // alert("Das war leider das letzte Level :(  Du kannst aber noch die anderen modi ausprobieren, wenn du das noch nicht getan hast.");
        setHighscores();
        zaehler = "newLevel";
        setTimeout(function () {
          zaehler = 0;
        }, 500);
      }
      if ((((red == 168 && green == 230 && blue == 29) || (onTeleporter().checkpoint && (onTeleporter().ball || onTeleporter().schieber))) && ((level[level.mode][level.aktuell].checkpointWhen_touches == "ball" && i > 3) || (level[level.mode][level.aktuell].checkpointWhen_touches == "schieber" && i < 4)) && ((level[level.mode][level.aktuell].checkpointWhen_touches == "schieber" && ((((((checkpoint[checkpoint.length - 1].schieber.y - y1 > 100 && level.mode != "magnet") || (checkpoint[checkpoint.length - 1].schieber.y - y1 > 300 && level.mode == "magnet")) || ((y1 - checkpoint[checkpoint.length - 1].schieber.y > 100 && level.mode != "magnet") || (level.mode == "magnet" && y1 - checkpoint[checkpoint.length - 1].schieber.y > 300))))) || (((level.mode != "magnet" && checkpoint[checkpoint.length - 1].schieber.x - x1 > 100) || (level.mode == "magnet" && checkpoint[checkpoint.length - 1].schieber.x - x1 > 300)) || ((level.mode == "mode" && x1 - checkpoint[checkpoint.length - 1].schieber.x > 300) || ((level.mode != "magnet" && x1 - checkpoint[checkpoint.length - 1].schieber.x > 100)))))) || (level[level.mode][level.aktuell].checkpointWhen_touches == "ball" && ((level.mode == "magnet" && checkpoint[checkpoint.length - 1].ball.x - ball.x > 300) || (level.mode != "magnet" && checkpoint[checkpoint.length - 1].ball.x - ball.x > 100)) || ((level.mode == "magnet" && ball.x - checkpoint[checkpoint.length - 1].ball.x > 300) || (level.mode != "magnet" && ball.x - checkpoint[checkpoint.length - 1].ball.x > 100))) ||
      (((level.mode != "magnet" && checkpoint[checkpoint.length - 1].ball.y - ball.y > 100) || (level.mode == "magnet" && checkpoint[checkpoint.length - 1].ball.y - ball.y > 300)) || ((level.mode == "magnet" && ball.y - checkpoint[checkpoint.length - 1].ball.y > 300) || (level.mode != "magnet" && ball.y - checkpoint[checkpoint.length - 1].ball.y > 100)))))) {
        console.log("checkpoint!!!");
        if (!checkpoints[level.mode]) checkpoints[level.mode] = [];
        checkpoint.push({schieber: {x: x1, y: y1}, ball: {x: ball.x, y: ball.y}, timeNeededToReach: time})
        checkpoints[level.mode][level.aktuell] = checkpoint;
        if (name != "allLevel") dbSetWarteschlange.push({tag: "checkpoints " + name, data: JSON.stringify(checkpoints)});//dbSet("transportTheBall", "checkpoints " + name, JSON.stringify(checkpoints));
      }
    }
     numbers = [
      [ball.x, ball.y],
      [ball.x + ball.width, ball.y],
      [ball.x, ball.y + ball.height],
      [ball.x + ball.width, ball.y + ball.height]
    ]
    for (var i = 0; i < 4; i++) {
      data = canvas.getImageData(numbers[i][0], numbers[i][1], 1, 1);
      red = data.data[0];
      green = data.data[1];
      blue = data.data[2];
      alpha = data.data[3];
      if (red = 255 && green == 126 && blue == 0) {
        console.log("bouncing");
        bounceCoordinates = {x1: x1, y1: y1}
        if (x1 - coordinatesBefore.x1 > -3 && x1 - coordinatesBefore.x1 < 3) bounceCoordinates.x1 = coordinatesBefore.x1 + 3;
        zaehler = "bouncing";
        if (i == 0) {bounceBall(["down", "right"], 0);}
        if (i == 1) {bounceBall(["down", "left"], 0);}
        if (i == 2) {bounceBall(["up", "right"], 0);}
        if (i == 3) {bounceBall(["up", "left"], 0);}
      }
    }
    for (var i = 0; level[level.mode][level.aktuell] && level[level.mode][level.aktuell].ballTeleporter && i < level[level.mode][level.aktuell].ballTeleporter.length; i++) {
      if (x1 > level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.x && x1 < level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.x + level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.width && y1 > level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.y && y1 < level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.y + level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.height &&
         ball.x > level[level.mode][level.aktuell].ballTeleporter[i].ballSide.x && ball.x < level[level.mode][level.aktuell].ballTeleporter[i].ballSide.x + level[level.mode][level.aktuell].ballTeleporter[i].ballSide.width && ball.y > level[level.mode][level.aktuell].ballTeleporter[i].ballSide.y && ball.y < level[level.mode][level.aktuell].ballTeleporter[i].ballSide.y + level[level.mode][level.aktuell].ballTeleporter[i].ballSide.height)
         {
           ball.x = level[level.mode][level.aktuell].ballTeleporter[i].ballTeleportedSide.x;
           ball.y = level[level.mode][level.aktuell].ballTeleporter[i].ballTeleportedSide.y;
         }
    }
    sphere.ball.style.left = ball.x + "px";
    sphere.ball.style.top = ball.y + "px";
  }
  function setHighscores(nextLevel) {
    dbGet("transportTheBall", "highscores").then(result => {
      highscores = JSON.parse(result);
      addToHighscore(nextLevel);
    }).catch(function(e) {
      addToHighscore(nextLevel);
    });
  // if (checkpoint.length > 1 /*checkpoint[checkpoint.length - 1].schieber.x != level[level.mode][level.aktuell].spawnPoint.schieber.x || checkpoint[checkpoint.length - 1].schieber.y != level[level.mode][level.aktuell].spawnPoint.schieber.y || checkpoint[checkpoint.length - 1].ball.x != level[level.mode][level.aktuell].spawnPoint.ball.x || checkpoint[checkpoint.length - 1].ball.y != level[level.mode][level.aktuell].spawnPoint.ball.y*/) {
  //   checkpoints[level.mode].splice(level.aktuell, 1);
  //   setTimeout(function () {
  //     if (name != "allLevel") dbSetWarteschlange.push({tag: "checkpoints " + name, data: JSON.stringify(checkpoints)});//dbSet("transportTheBall", "checkpoints " + name, JSON.stringify(checkpoints));
  //   }, 1000);
  // }
  }
  function onTeleporter() {
    var onTeleporterObj = {schieber: false, ball: false, checkpoint: false}
    for (var i = 0; level[level.mode][level.aktuell] && level[level.mode][level.aktuell].ballTeleporter && i < level[level.mode][level.aktuell].ballTeleporter.length; i++) {
      if (x1 > level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.x && x1 < level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.x + level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.width && y1 > level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.y && y1 < level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.y + level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.height) onTeleporterObj.schieber = true;
      if (ball.x > level[level.mode][level.aktuell].ballTeleporter[i].ballSide.x && ball.x < level[level.mode][level.aktuell].ballTeleporter[i].ballSide.x + level[level.mode][level.aktuell].ballTeleporter[i].ballSide.width && ball.y > level[level.mode][level.aktuell].ballTeleporter[i].ballSide.y && ball.y < level[level.mode][level.aktuell].ballTeleporter[i].ballSide.y + level[level.mode][level.aktuell].ballTeleporter[i].ballSide.height) onTeleporterObj.ball = true;
      if (level[level.mode][level.aktuell].ballTeleporter[i].checkpoint) onTeleporterObj.checkpoint = true;
    }
    return onTeleporterObj;
  }
  var goalReached = false;
  function addToHighscore(pNextLevel) {
    if (oppositeCheck.checked) level.mode += ' opposite';
    if (easyMaps.checked) level.mode += ' easy_maps';
    if (!highscores[level.mode]) highscores[level.mode] = {};
    if (!highscores[level.mode][level.aktuell]) highscores[level.mode][level.aktuell] = {};
    if (!highscores[level.mode][level.aktuell][joyStickPlay.checked]) highscores[level.mode][level.aktuell][joyStickPlay.checked] = {};
    if (!highscores[level.mode][level.aktuell] || !highscores[level.mode][level.aktuell][joyStickPlay.checked][name] || highscores[level.mode][level.aktuell][joyStickPlay.checked][name] > mins + ":" + secs + ":" + "0" + tenths) highscores[level.mode][level.aktuell][joyStickPlay.checked][name] = mins + ":" + secs + ":" + "0" + tenths;
    goalReached = false;
    setTimeout(function () {
      if (name != "allLevel") dbSetWarteschlange.push({tag: "highscores", data: JSON.stringify(highscores)});//dbSet("transportTheBall", "highscores", JSON.stringify(highscores));
      for (var i = 0; i < Object.keys(level).length; i++) {
        if (highscores[Object.keys(level)[i]] && highscores[Object.keys(level)[i]][Object.keys(level[Object.keys(level)[i]]).length] && highscores[Object.keys(level)[i]][Object.keys(level[Object.keys(level)[i]]).length][name]) document.getElementById(Object.keys(level)[i] + "Selection").innerHTML = "✅" + Object.keys(level)[i];
      }
    }, 1000);
    level.mode = level.mode.replace(' opposite', '');
    level.mode = level.mode.replace(' easy_maps', '');
    if (pNextLevel) nextLevel();
    else winnerScreen();
  }
  var dbSetWarteschlange = [];
  setInterval(function () {
    if (dbSetWarteschlange.length > 0) {
      dbSet("transportTheBall", dbSetWarteschlange[0].tag, dbSetWarteschlange[0].data);
      dbSetWarteschlange.shift();
    }
    else if (alertWhenFinishedSaving) {
      alert("Saving finished! You can now leave the website!");
      alertWhenFinishedSaving = false;
    }
  }, 2222);
  function bounceBall(direction, time) {
    console.log("boundce " + direction);
    if (zaehler != "newLevel") {
    if (direction.includes("right") && bounceCoordinates.x1 > coordinatesBefore.x1) ball.x += (bounceCoordinates.x1- coordinatesBefore.x1)*level[level.mode][level.aktuell].bounceleftRight;
    else if (direction.includes("right")) ball.x += (coordinatesBefore.x1 - bounceCoordinates.x1)*level[level.mode][level.aktuell].bounceleftRight;
    if (direction.includes("left") && bounceCoordinates.x1 > coordinatesBefore.x1) ball.x -= (bounceCoordinates.x1- coordinatesBefore.x1)*level[level.mode][level.aktuell].bounceleftRight;
    else if (direction.includes("left")) ball.x -= (coordinatesBefore.x1 - bounceCoordinates.x1)*level[level.mode][level.aktuell].bounceleftRight;
    if (direction.includes("down") && bounceCoordinates.y1 > coordinatesBefore.y1) ball.y += (bounceCoordinates.y1 - coordinatesBefore.y1)/level[level.mode][level.aktuell].bounceUpDown;
    else if (direction.includes("down")) ball.y += (coordinatesBefore.y1 - bounceCoordinates.y1)/level[level.mode][level.aktuell].bounceUpDown;
    if (direction.includes("up") && bounceCoordinates.y1 > coordinatesBefore.y1) ball.y -= (bounceCoordinates.y1 - coordinatesBefore.y1)/level[level.mode][level.aktuell].bounceUpDown;
    else if (direction.includes("up")) ball.y -= (coordinatesBefore.y1 - bounceCoordinates.y1)/level[level.mode][level.aktuell].bounceUpDown;

  }
  else {
    time = 13;
  }
    time++;
    sphere.ball.style.left = ball.x + "px";
    sphere.ball.style.top = ball.y + "px";
    if (time < 15) {
      setTimeout(function () {
        bounceBall(direction, time + 1);
      }, 27);
    }
    else {
      zaehler = 0;
    }
  }
  function removeCheckpoint() {
    if (checkpoint.length > 1) {
     sphere.ball.style.left = checkpoint[checkpoint.length - 2].ball.x + "px";
     sphere.ball.style.top = checkpoint[checkpoint.length - 2].ball.y + "px";
     checkpoint.pop();
   }
  }
  function boundingBoxCheck() {
    Layout();
    if (x1 < 0) {
      x1 = 0;
      vx1 = -vx1;
    }
    if (y1 < 0) {
      y1 = 0;
      vy1 = -vy1;
    }
    if (x1 > Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2) {
      x1 = Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2;
      vx1 = -vx1;
    }
    if (y1 > Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2) {
      y1 = Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2;
      vy1 = -vy1;
    }
    if (x2 < 0) {
      x2 = 0;
      vx2 = -vx2;
    }
    if (y2 < 0) {
      y2 = 0;
      vy2 = -vy2;
    }
    if (x2 > Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2) {
      x2 = Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2;
      vx2 = -vx2;
    }
    if (y2 > Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2) {
      y2 = Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2;
      vy2 = -vy2;
    }
  }

  function Layout() {
    if (level.aktuell != "winnerScreen") {
    if (easyMaps.checked) Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/transportTheBall/easy_versions/" + level.mode + "/map" + level.aktuell + ".png";
    else Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/transportTheBall/" + level.mode + "/map" + level.aktuell + ".png";
    textur.width = Bild.width;
    textur.height = Bild.height;
    canvas.drawImage(Bild, 0, 0);
    for (var i = 0; level[level.mode][level.aktuell].ballTeleporter && i < level[level.mode][level.aktuell].ballTeleporter.length; i++) {
      if (level[level.mode][level.aktuell].ballTeleporter[i].checkpoint) canvas.fillStyle = "rgba(168, 230, 29, 1)";
      else canvas.fillStyle = "blue";
      canvas.fillRect(level[level.mode][level.aktuell].ballTeleporter[i].ballSide.x, level[level.mode][level.aktuell].ballTeleporter[i].ballSide.y, level[level.mode][level.aktuell].ballTeleporter[i].ballSide.width, level[level.mode][level.aktuell].ballTeleporter[i].ballSide.height);
      canvas.fillRect(level[level.mode][level.aktuell].ballTeleporter[i].ballTeleportedSide.x, level[level.mode][level.aktuell].ballTeleporter[i].ballTeleportedSide.y, cssToNumber(ball.width), ball.height);
      canvas.fillStyle = "red";
      canvas.fillRect(level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.x, level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.y, level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.width, level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.height);
      canvas.beginPath();
      canvas.moveTo(level[level.mode][level.aktuell].ballTeleporter[i].ballSide.x + level[level.mode][level.aktuell].ballTeleporter[i].ballSide.width/2, level[level.mode][level.aktuell].ballTeleporter[i].ballSide.y + level[level.mode][level.aktuell].ballTeleporter[i].ballSide.height/2);
      canvas.lineTo(level[level.mode][level.aktuell].ballTeleporter[i].ballTeleportedSide.x + cssToNumber(ball.width/2), level[level.mode][level.aktuell].ballTeleporter[i].ballTeleportedSide.y + ball.height/2);
      canvas.lineTo(level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.x + level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.width/2, level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.y + level[level.mode][level.aktuell].ballTeleporter[i].schieberSide.height/2);
      canvas.stroke();
    }
  }
  }
  var ball = {
    x: 0,
    y: 0,
    width: 50,
    height: 50
  };

  function restartLevel(value) {
    var valueBefore = checkpointSelection.value;
    // if (valueBefore == "" && checkpoints[level.mode] && checkpoints[level.mode][level.aktuell]) valueBefore = (checkpoints[level.mode][level.aktuell].length - 1) + ". checkpoint";
    if (valueBefore == "") valueBefore = "start";
    while (document.getElementById('checkpointSelection').options.length > 0) {
      document.getElementById('checkpointSelection').options[0] = undefined;
    }
    for (var i = 0; checkpoints[level.mode] && checkpoints[level.mode][level.aktuell] && i < checkpoints[level.mode][level.aktuell].length; i++) {
      opt = document.createElement("option");
      document.getElementById("checkpointSelection").options.add(opt);
      if (i > 0) opt.text = i + ". checkpoint";
      else opt.text = "start";
    }
    checkpointSelection.value = valueBefore;
    if (document.getElementById('checkpointSelection').options.length > 0 && highscores[level.mode] && highscores[level.mode][Object.keys(level[level.mode]).length] && highscores[level.mode][Object.keys(level[level.mode]).length][name]) checkpointSelection.style.display = 'inline';
    else checkpointSelection.style.display = 'none';
    x1 = checkpoint[checkpoint.length - 1].schieber.x;
    y1 = checkpoint[checkpoint.length - 1].schieber.y;
    ball.x = checkpoint[checkpoint.length - 1].ball.x;
    ball.y = checkpoint[checkpoint.length - 1].ball.y;
    sphere.ball.style.top = ball.x + "px";
    sphere.ball.style.left = ball.y + "px";
    scrollingInterac.PC = true;
    for (var i = 0; i < Bild.width; i++) {
      if (!scrollingInterac.user && x1 > window.innerWidth + scrollX - level[level.mode][level.aktuell].sizes.schieber.width*5) window.scroll(scrollX + 3, scrollY);
      if (!scrollingInterac.user && y1 > window.innerHeight + scrollY - level[level.mode][level.aktuell].sizes.schieber.height*5) window.scroll(scrollX, scrollY + 3);
      if (!scrollingInterac.user && x1 - scrollX < (level[level.mode][level.aktuell].sizes.schieber.width + level[level.mode][level.aktuell].sizes.ball.width*5) && scrollX > 2) window.scroll(scrollX - 3, scrollY);
      if (!scrollingInterac.user && y1 - scrollY < (level[level.mode][level.aktuell].sizes.schieber.height + level[level.mode][level.aktuell].sizes.ball.height*5) && scrollY > 2) window.scroll(scrollX, scrollY - 3);
    }
    setTimeout(function () {
      scrollingInterac.PC = false;
    }, 1000);
  }

  function nextLevel() {
    level.aktuell++;
    zaehler = "newLevel";
    setTimeout(function () {
      zaehler = 0;
    }, 500);
    setupLevel();
    levelSelected(level.aktuell + ". level");
    // inOrAgainstDirection = 1;
  }
  var heartBeatInt
  var saveHighscores = true;
  function heartBeatFunc(firstCall) {
    if (level[level.mode][level.aktuell].heart.ball && sphere.ball.heartBeatAction != false) {
      /*sphere.*/sphere.ball.style.width = cssToNumber(sphere.ball.style.width) + level[level.mode][level.aktuell].heart.ball.pixelPerFunctionCall*/*sphere.*/ball.direction + "px";
      /*sphere.*/sphere.ball.style.height = cssToNumber(sphere.ball.style.height) + level[level.mode][level.aktuell].heart.ball.pixelPerFunctionCall*/*sphere.*/ball.direction + "px";
    }
    if (level[level.mode][level.aktuell].heart.schieber && sphere.schieber.heartBeatAction != false) {
      sphere.schieber.style.width = cssToNumber(sphere.schieber.style.width) + level[level.mode][level.aktuell].heart.schieber.pixelPerFunctionCall*sphere.schieber.direction + "px";
      sphere.schieber.style.height = cssToNumber(sphere.schieber.style.height) + level[level.mode][level.aktuell].heart.schieber.pixelPerFunctionCall*sphere.schieber.direction + "px";
    }
    if (level[level.mode][level.aktuell].heart.ball && cssToNumber(sphere.ball.style.width) > level[level.mode][level.aktuell].heart.ball.max && sphere.ball.heartBeatAction != false) {
      ball.direction = -1;
      heartBeatStop("ball", "max", firstCall);
    }
    if (level[level.mode][level.aktuell].heart.ball && cssToNumber(sphere.ball.style.width) < level[level.mode][level.aktuell].heart.ball.min && sphere.ball.heartBeatAction != false) {
      ball.direction =  1;
      heartBeatStop("ball", "min", firstCall);
    }
    // if (ball.height > level[level.mode][level.aktuell].heart.ball.max) ball.direction = -1;
    // if (ball.height < level[level.mode][level.aktuell].heart.ball.min) ball.direction =  1;
    if (level[level.mode][level.aktuell].heart.schieber && cssToNumber(sphere.schieber.style.width) > level[level.mode][level.aktuell].heart.schieber.max && sphere.schieber.heartBeatAction != false) {
      sphere.schieber.direction = -1;
      heartBeatStop("schieber", "max", firstCall);
    }
    if (level[level.mode][level.aktuell].heart.schieber && cssToNumber(sphere.schieber.style.width) < level[level.mode][level.aktuell].heart.schieber.min && sphere.schieber.heartBeatAction != false) {
      sphere.schieber.direction =  1;
      heartBeatStop("schieber", "min", firstCall);
    }
      setTimeout(function () {
        if (level[level.mode][level.aktuell].heart != undefined) heartBeatFunc();
      }, 100);
    ball.width = cssToNumber(sphere.ball.style.width);
    ball.height = cssToNumber(sphere.ball.style.height);
  }
  function heartBeatStop(component, extrempunt, firstCall) {
    if (level[level.mode][level.aktuell].heart[component].waitBeforeDirectionSwitchInSec[extrempunt]) {
      sphere[component].heartBeatAction = false;
      var time = level[level.mode][level.aktuell].heart[component].waitBeforeDirectionSwitchInSec[extrempunt]*1000;
      if (firstCall && level[level.mode][level.aktuell].heart[component].waitBeforeDirectionSwitchInSec.levelBegin != undefined) time = level[level.mode][level.aktuell].heart[component].waitBeforeDirectionSwitchInSec.levelBegin;
      setTimeout(function () {
        sphere[component].heartBeatAction = true;
      }, time);
    }
  }
  function setupLevel(direction) {
    if (oppositeCheck.checked) sensibility = {x: 1, y: 1};
    else if (saveHighscores) sensibility = {x: 17, y: 17};
    sensibility.value = sensibility.x;
    if (!direction) checkpoint = [{schieber: {x: level[level.mode][level.aktuell].spawnPoint.schieber.x, y: level[level.mode][level.aktuell].spawnPoint.schieber.y}, ball: {x: level[level.mode][level.aktuell].spawnPoint.ball.x, y: level[level.mode][level.aktuell].spawnPoint.ball.y}}];
    restartLevel();
    ball.width = level[level.mode][level.aktuell].sizes.ball.width;
    ball.height = level[level.mode][level.aktuell].sizes.ball.height;
    sphere.schieber.style.width = level[level.mode][level.aktuell].sizes.schieber.width + "px";
    sphere.schieber.style.height = level[level.mode][level.aktuell].sizes.schieber.height + "px";
    sphere.ball.style.width = ball.width + "px";
    sphere.ball.style.height = ball.height + "px";
    if (!direction && level[level.mode][level.aktuell].heart != undefined) {sphere.schieber.direction = 1; /*sphere.*/ball.direction = 1; heartBeatFunc(true);}
    scrollingInterac.user = false;
  }
  var directionBefore = [];

  function isCollide(a, b) {
    if ((level.mode == "slide" && (!(
      ((a.y + a.height) < (b.y)) ||
      (a.y > (b.y + b.height)) ||
      ((a.x + a.width) < b.x) ||
      (a.x > (b.x + b.width))
    ) || zaehler == 0)) || level.mode != "slide") {
    if (((a.y + a.height) < (b.y)) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "down";
    // else if (((a.y + a.height) < (b.y))) directionBefore.push("down");
    // else if ((
    //     (a.y > (b.y + b.height)) ||
    //     ((a.x + a.width) < b.x) ||
    //     (a.x > (b.x + b.width))
    //   )) removeDirection("down");
    if (((a.y > (b.y + b.height))) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "up";
    // else if (((a.y > (b.y + b.height)))) directionBefore.push("up");
    // else if ((
    //     ((a.y + a.height) < (b.y)) ||
    //     ((a.x + a.width) < b.x) ||
    //     (a.x > (b.x + b.width))
    //   )) removeDirection("up");
    if ((((a.x + a.width) < b.x)) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "right";
    // else if ((((a.x + a.width) < b.x))) directionBefore.push("right");
    // else if ((
    //     ((a.y + a.height) < (b.y)) ||
    //     (a.y > (b.y + b.height)) ||
    //     (a.x > (b.x + b.width))
    //   )) removeDirection("right");
    if (((a.x > (b.x + b.width))) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "left";
    // else if (((a.x > (b.x + b.width)))) directionBefore.push("left");
    // else if ((
    //     ((a.y + a.height) < (b.y)) ||
    //     (a.y > (b.y + b.height)) ||
    //     ((a.x + a.width) < b.x)
    //   )) removeDirection("left");
    // if (!(
    //     ((a.y + a.height) < (b.y)) ||
    //     (a.y > (b.y + b.height)) ||
    //     ((a.x + a.width) < b.x) ||
    //     (a.x > (b.x + b.width))
    //   )) {}
    }
    return !(
      ((a.y + a.height) < (b.y)) ||
      (a.y > (b.y + b.height)) ||
      ((a.x + a.width) < b.x) ||
      (a.x > (b.x + b.width))
    );
  }
  var inOrAgainstDirection = 1;

  function winnerScreen() {
    level.aktuell = "winnerScreen";
    Bild = new Image();
    Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gewinnerbildschirm.jpeg";
    canvas.drawImage(Bild, 0, 0);
    setTimeout(function () {
      canvas.drawImage(Bild, 0, 0, window.innerWidth, window.innerHeight);
    }, 500);
  }
  function levelSelected(value) {
    sphere.schieber.backgroundColor = "blue";
    if (value == "winnerScreen") {
      winnerScreen();
    }
    else {
    levelSelector.value = value;
    level.aktuell = JSON.parse(value.toString().split('. level')[0]);
    if (running == 0) startPause();
    else time = 0;
    setupLevel();
    if (checkpoints[level.mode] && checkpoints[level.mode][level.aktuell]) {checkpoint = JSON.parse(JSON.stringify(checkpoints[level.mode][level.aktuell])); time = checkpoint[checkpoint.length - 1].timeNeededToReach;}
  }
  if (level[level.mode][level.aktuell].rotating) requestAnimationFrame(renderLoop);
  }
  function modeSelected(mode) {
    if (mode != "showScores") {
      textur.style.display = "inline";
      levelSelector.style.display = "inline";
      sphere.schieber.style.display = "inline";
      sphere.ball.style.display = "inline";
    level.mode = mode;
    while (document.getElementById('levelSelector').options.length > 0) {
      document.getElementById('levelSelector').options[0] = undefined;
    }
    var mapsFinished = 0;
    for (var i = 0; highscores[mode] && i < Object.keys(highscores[mode]).length; i++) {
      if (Object.keys(highscores[mode][Object.keys(highscores[mode])[0]]).includes(name)) mapsFinished++;
    }
    if (name == "allLevel") mapsFinished = Object.keys(level[mode]).length;
    for (var i = 0; ((mapsFinished == 0 && i < 1) || (mapsFinished == Object.keys(level[mode]).length && i < mapsFinished) || (highscores[mode] && mapsFinished != Object.keys(level[mode]).length && i < mapsFinished + 1)); i++) {
      if ( mapsFinished > 0) {
      opt = document.createElement("option");
      document.getElementById("levelSelector").options.add(opt);
      // opt.setAttribute("id", i);
      opt.text = (i + 1) + ". level";
    }
    else if (i == 0) {
      levelSelector.style.display = "none";
    }
    }
    if (mapsFinished == Object.keys(level[mode]).length) {
      opt = document.createElement("option");
      document.getElementById("levelSelector").options.add(opt);
      // opt.setAttribute("id", i);
      opt.text = "winnerScreen";
      levelSelected(/*"1. level"*/mapsFinished + ". level");
  }
    else levelSelected(/*"1. level"*/(mapsFinished + 1) + ". level");
    // else inOrAgainstDirection = 1;
    gameModeSelection.value = mode;
}
  else {
    showScores(highscores);
  }
  }
  var highscoresDisplayedBefore = {};
  function showScores(highscores) {
    scores.style.display = "inline";
     textur.style.display = "none";
     sphere.schieber.style.display = "none";
     sphere.ball.style.display = "none";
    for (var i = 0; i < 100; i++) {
      try {
        document.getElementById("scores").deleteRow(0);
      } catch (e) {
        console.log("wanted to delete too many elements of table");
      }
    }
    highscoresDisplayedBefore = highscores;
    console.log("highScores: " + highscores);
    var cell = [ /*row.insertCell(0)*/ ];
    var player = []
    var mostLevel = 0;
    for (var i2 = 0; i2 < Object.keys(highscores).length; i2++) {

      for (var i = 1; i < Object.keys(highscores[Object.keys(highscores)[i2]]).length + 1; i++) {
        for (var i1 = 0; highscores[Object.keys(highscores)[i2]][i][joyStickPlay.checked] && i1 < Object.keys(highscores[Object.keys(highscores)[i2]][i][joyStickPlay.checked]).length; i1++) {
          if (!(player.includes(Object.keys(highscores[Object.keys(highscores)[i2]][i][joyStickPlay.checked])[i1]))) player.push(Object.keys(highscores[Object.keys(highscores)[i2]][i][joyStickPlay.checked])[i1]);
        }
      }
      if (mostLevel < Object.keys(highscores[Object.keys(highscores)[i2]]).length) mostLevel = Object.keys(highscores[Object.keys(highscores)[i2]]).length;
    for (var i = 0; i < player.length; i++) {
      // if (!(Object.keys(highscores)[i] == "allMaps")) {
     // if (player[i] != "allLevel") {
        var table = document.getElementById("scores");
        var row = table.insertRow(i); // row geht nach unten (Spalt)
        cell.push(row.insertCell(0)); // cell geht nach rechts (Zeit))
        cell.push(row.insertCell(1));
        cell[cell.length - 1].innerHTML = player[i];
      // }
      //  var cell = [/*row.insertCell(0)*/];
        cell[cell.length - 2] = row.insertCell(1);
      for (var i1 = 1; highscores[Object.keys(highscores)[i2]] && i1 < Object.keys(highscores[Object.keys(highscores)[i2]]).length + 1; i1++) {
        // if (!(Object.keys(highscores[Object.keys(highscores)[i2]])[i] == "allMaps")) {
          if (i1 < Object.keys(highscores[Object.keys(highscores)[i2]]).length + 1) {
            cell[cell.length] = row.insertCell(i1 + 2);
            // if (level[level.mode].levelType == "worldWideLevel" && i1 == 0) {
            //   i1--;
            // }
            if (highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked]) {
              if (highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked][player[i]]) cell[cell.length - 1].innerHTML = highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked][player[i]]
              if (highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked][player[i]] < highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked][name]) cell[cell.length - 1].style.color = "red";
              else if (highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked][player[i]] > highscores[Object.keys(highscores)[i2]][i1][joyStickPlay.checked][name]) cell[cell.length - 1].style.color = "green";
              else if (name == player[i]) cell[cell.length - 1].style.color = "blue";
              else cell[cell.length - 1].style.color = "black";
            }

          } else {
            cell[cell.length - 1] = row.insertCell(i1 + 1);
            //  cell[cell.length - 2].innerHTML = "unmade";
            //  cell[cell.length - 2].style.color = "black";
          }
        // }
      }
      if (table) var row = table.insertRow(i);
      //  var row = table.insertRow(i+1);
      // var row = table.insertRow(i + 1);
    //}
  }
  if (table) {
    var row = table.insertRow(/*i2*/0);
    cell[0] = row.insertCell(0);
    cell[0].innerHTML = "";
    cell[0] = row.insertCell(0);
    cell[0].innerHTML = Object.keys(highscores)[i2];
  }
  }
    //  var row = table.insertRow(0);
    //  var cell = [/*row.insertCell(0)*/];
    // cell.push(row.insertCell(0));
    // cell[cell.length - 1].innerHTML = "name";
    var row = table.insertRow(0);
    cell.push(row.insertCell(0));
    for (var i1 = 0; i1 < mostLevel + 1; i1++) {
      cell.push(row.insertCell(i1));
      if (i1 == 0) cell[cell.length - 1].innerHTML = "mode";
      else cell[cell.length - 1].innerHTML = (i1) + ". level";
    }
    cell.push(row.insertCell(1));
    cell.push(row.insertCell(2));
    cell[cell.length - 1].innerHTML = "name"
  }
  // function removeDirection(direction) {
  //   for (var i = 0; i < directionBefore.length; i++) {
  //     if (directionBefore[i] == direction) {
  //       directionBefore.splice(i, 1);
  //       i--;
  //     }
  //   }
  // }

  function cssToNumber(cssStyle) {
    return JSON.parse(cssStyle.toString().split('px')[0])
  }
  var time = 0;
  var running = 0;

function startPause() {
if (running == 0) {
  running = 1;
  time = 0;
  increment();
}
else {
  running = 0;
}
}
function reset() {
running = 0;
timer = 0;
}
var mins = 0;
var secs = 0;
var tenths = 0;
function increment() {
if (running == 1) {
setTimeout(function () {
  time++;
  mins = Math.floor(time/10/60);
  secs = Math.floor(time/10);
      secs -= 60*mins;
  tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  increment();
}, 100);
}
}
startPause();
// rotating shapes:
function drawPath(path, x, y, angle) {
    canvas.setTransform(1, 0, 0, 1, x, y);
    canvas.rotate(angle);
    canvas.stroke(path);
}

function drawPath_V2(path, x, y, scale, angle, strokeStyle, fillStyle) {
    canvas.setTransform(scale, 0, 0, scale, x, y);
    canvas.rotate(angle);
    fillStyle && (canvas.fillStyle = fillStyle, canvas.fill(path));
    strokeStyle && (canvas.strokeStyle = strokeStyle, canvas.stroke(path));
}


function renderLoop(time) {
    //canvas.clearRect(0, 0, textur.width, textur.height);
    checkColourCollisions();
    var scale = Math.sin(time / 500) * 0.2 + 1.0;
    var scale2 = Math.cos(time / 1000) * 0.4 + 1.0;
    var miliSecsPerRotation = 2222;
    var angle = 0;
    var sizeRelationToOriginal = 1.0;
    for (var i = 0; i < level[level.mode][level.aktuell].rotating.length; i++) {
      if (level[level.mode][level.aktuell].rotating[i].angle) angle = level[level.mode][level.aktuell].rotating[i].angle;
      if (level[level.mode][level.aktuell].rotating[i].miliSecsPerRotation) miliSecsPerRotation = level[level.mode][level.aktuell].rotating[i].miliSecsPerRotation;
      if (easyMaps.checked && level[level.mode][level.aktuell].rotating[i].miliSecsPerRotationEasy) miliSecsPerRotation = level[level.mode][level.aktuell].rotating[i].miliSecsPerRotationEasy;
      if (level[level.mode][level.aktuell].rotating[i].sizeRelationToOriginal) sizeRelationToOriginal = level[level.mode][level.aktuell].rotating[i].sizeRelationToOriginal;
      scale2 = Math.cos(time / 1000) * 0.4 + 1.0;
      if (level[level.mode][level.aktuell].rotating[i].heart && level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSec) scale2 = Math.cos(time / level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSec) * 0.4 + sizeRelationToOriginal;
      else if (easyMaps.checked && level[level.mode][level.aktuell].rotating[i].heart && level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSecEasy) scale2 = Math.cos(time / level[level.mode][level.aktuell].rotating[i].heart.onceInMiliSecEasy) * 0.4 + sizeRelationToOriginal;
      else scale2 = sizeRelationToOriginal;
    if (level[level.mode][level.aktuell].rotating[i].shape && level[level.mode][level.aktuell].rotating[i].shape == "triangle") drawPath_V2(triangle, level[level.mode][level.aktuell].rotating[i].position.x, level[level.mode][level.aktuell].rotating[i].position.y, scale2, (time / (miliSecsPerRotation/2) * Math.PI) + angle, "", "black"); //360 every 2 second
    // scale path
    if (level[level.mode][level.aktuell].rotating[i].shape && level[level.mode][level.aktuell].rotating[i].shape == "rectangle") drawPath_V2(rectangle, level[level.mode][level.aktuell].rotating[i].position.x, level[level.mode][level.aktuell].rotating[i].position.y, scale2, (time / (miliSecsPerRotation/2) * Math.PI) + angle, "", "black"); //360 every 4 second
    }
    for (var i = 0; i < pointShapes.length; i++) {
      if (pointShapes[i].angle) angle = pointShapes[i].angle;
      if (pointShapes[i].miliSecsPerRotation) miliSecsPerRotation = pointShapes[i].miliSecsPerRotation;
      if (pointShapes[i].sizeRelationToOriginal) sizeRelationToOriginal = pointShapes[i].sizeRelationToOriginal;
      if (pointShapes[i].onceInMiliSec) scale2 = Math.cos(time / pointShapes[i].onceInMiliSec) * 0.4 + sizeRelationToOriginal;
      drawPath_V2(pointShapes[i].path, pointShapes[i].position.x, pointShapes[i].position.y, scale2, (time / (miliSecsPerRotation/2) * Math.PI) + angle, "", "black");
    }
    // fill scale path
    // drawPath_V2(thing  , 125, 100, scale2, time / 3000 * Math.PI, "", "black");

    canvas.setTransform(1, 0, 0, 1, 0, 0);
    if (level[level.mode][level.aktuell].rotating) requestAnimationFrame(renderLoop);
}


function createPath(...points) {
    var cx = 0; cy = 0;
    for (const p of points) {
        cx += p.x;
        cy += p.y;
    }
    cx /= points.length;
    cy /= points.length;

    const path = new Path2D;
    for (const p of points) {
        path.lineTo(p.x - cx , p.y - cy);
    }
    path.closePath();
    return path;
}

if (gerät == "PC") alert("please click to place a joy-stick!"); joyStick = "place";
function canvasClicked() {
  if (joyStick == "place" && gerät == "PC") {
    joyStick = {coordinates : {x: mausx, y: mausy}};
  }
}
document.addEventListener('touchmove', touch);
document.addEventListener('touchstart', touch);
document.addEventListener('touchend', touch);
var joyStick;
function touch(ev) {
if (joyStickPlay.checked && ev.type == "touchend" && joyStick.coordinates) {
  //textur.style.touchAction = '';
  mausx = joyStick.coordinates.x;
  mausy = joyStick.coordinates.y;
}
if (ev.touches[0] != undefined) {
    mausx = ev.touches[0]["pageX"]// + scrollX;
    mausy = ev.touches[0]["pageY"]// + scrollY;
  }
if (joyStickPlay.checked && ev.type == "touchstart" && mausy < textur.getBoundingClientRect().bottom + scrollY) {
  joyStick = {coordinates : {x: mausx, y: mausy}};
  if (!ev.touches[1]) textur.style.touchAction = 'none';
  else textur.style.touchAction = '';
}
}
function readMouseMove(e) {
  mausx = e.clientX + scrollX;
  mausy = e.clientY + scrollY;
  //  console.log(mausx + " - " + mausy);
}
document.onmousemove = readMouseMove
function cssToNumber(string) {
return JSON.parse(string.toString().split("px")[0]);
}

</script>
