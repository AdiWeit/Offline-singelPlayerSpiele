<title>transport the ball</title>
<meta charset="utf-8">
<canvas id="textur" onclick="canvasClicked();" width="1582" height="740"></canvas>
<script src="https://adi.nicolaiweitkemper.de/Database2/js.js"></script>
<select name="course" id="gameModeSelection" value="normal" onchange="modeSelected(value);">
  <option id="normalSelection" value="normal">normal</option>
  <option id="magnetSelection" value="magnet">magnet</option>
  <option id="allDirectionsSelection" value="allDirections">all directions</option>
  <option id="slideSelection" value="slide">slide</option>
  <!-- <option id="oppositeSelection" value="opposite">opposite</option> -->
  <option value="showScores">show scores</option>
</select>
<input id="easyMaps" onchange="difficultyChanged(checked);" checked="true" type="checkbox"> easy map versions
<br>
<input type="checkbox" onchange="inOrAgainstDirection *= -1; setupLevel(true);" id="oppositeCheck"> opposite
<br>
<select name="course" id="levelSelector" value="normal" onchange="levelSelected(value);"></select>
<select id="checkpointSelection" onchange="checkpointSelected(value);">

</select>
<button name="button" id="removeCheckpointB" onclick="removeCheckpoint();">remove this checkpoint</button>
<br>
<button type="button" onclick="scrollingInterac.user = false;" name="button">autoscroll again</button>
<p id="joyStickPlayP"> <input type="checkbox" onchange="if (checked) textur.style.touchAction = 'none';" id="joyStickPlay"> joystick control </p>
<br>
<!-- <button onclick="joyStick = 'place';">move joystick position</button>
<br> -->
<h3>sensibility</h3>
<input type="range" min="1" onchange="if (confirm('As long as you play with changed sensibility, it will not count the completion time!')) {saveHighscores = false; sensibility = {x: value, y: value};} value = sensibility.x" max="35" value="17" class="slider" id="sensibility">
<button type="button" id="normalSensibility" onclick="normalSensibility();" name="button">back to normal</button>
<br>
<select id="tabletPositionModeSelection">
  <option>flat (most natural)</option>
  <option>almost on end (slopes away from you a bit, best? for your posture)</option>
  <option>on end (better for your posture)</option>
</select>
<div id="ball">
  <style>
    .shape {
      position: absolute;
      width: 50px;
      height: 50px;
      -webkit-radius: 50px;
      margin: 0;
      /* width padding: 0; */
    }

    #sphere1 {
      border-radius: 50px;
      background-color: blue;
    }

    #sphere2 {
      border-radius: 50px;
      background-color: red;
    }
  </style>
</div>
<div id="content">
  <div class="shape" style="left: 0px; top: 0px; width: 50px; height: 50px;" id="sphere1"></div>
</div>
<div id="content">
  <div class="shape" style="left: 0px; top: 0px; width: 50px; height: 50px;" id="sphere2"></div>
</div>
<table id="scores"></table>
<br>
<script src="https://www.youtube.com/player_api"></script>
<button type="button" onclick="showYoutubeVideo();" name="button">watch developer playing level (easy maps: all level)</button>
<br>
<div id="vidPlayer"></div>
<script>
  var playerObj;
  var videoIdConverter = {false: {normal: ['tNKoG81CSsI', '_lo9GVktIYk', 'TAg3bnXQKzE', '9SRwETnuRpM', '4K9d9zPykzc', 'y9vokKUCqv4', 'WTWq4Zb2Wd4'], magnet: ['S25pXS6_cDw', 'Lr0aWLST98w', 'WiNPZDJTpVg', '82uctW_BFL8', 'cdWIeg-Oh60', 'hdzR8xr8Osw'], slide: ['1SD5ktvjsu0', 'aBXU5I4BIz8', '5YJOncx1g64', 'Fl8mipUtMCs', 'Jz5Jai65VNg', 'y73vFUkyTx0', 'l5OHULD2_0Y', 'vSABPJ-wbgU', 'ik1UHtkdPEE', '7-QwkxkX9zg'], allDirections: ['u_o_XDMCgHo', 'jqtwOmw71mc', 'rBzDROxUWuI', '8C24IJ0H0IM', 'B573LNYlK0M', 'V00AcXUHn1g']}, true: {normal: 'YbzMNy-zm_o', magnet: '4xYN1uSPKPA', allDirections: 'Q7ND0Q31ml0', slide: 'NgKgJiJmEJU'}}
  function showYoutubeVideo() {
    if (!easyMaps.checked) var vidID = videoIdConverter[easyMaps.checked][level.mode][level.aktuell - 1]
    else var vidID = videoIdConverter[easyMaps.checked][level.mode];
    if (playerObj) {
      playerObj.loadVideoById(vidID);
    }
    else {
    playerObj = new YT.Player('vidPlayer', {
        videoId: vidID, // this is the id of the video at youtube (the stuff after "?v=")
        loop: true,
        events: {
            onReady: function (e) {
                e.target.playVideo();
              },
        }
    });
  }
  }
  function difficultyChanged(checked) {
    if (checked) currentLevel = level.easyMaps[level.mode][level.aktuell];
    else currentLevel = level[level.mode][level.aktuell];
    setupLevel();
  }
  function normalSensibility() {
    if (oppositeCheck.checked) sensibility = {x: 1, y: 1};
    else if (!currentLevel.sensibility) sensibility = {x: 17, y: 17};
    else sensibility = currentLevel.sensibility;
    document.getElementById('sensibility').value = sensibility;
    saveHighscores = true;
  }
  var canvas = textur.getContext('2d'); //Dimension
  var highscores = {};
  var checkpoints = {};
  var x1 = 10,
    y1 = 177; //window.innerHeight - 150 + 3,
  x2 = 0, y2 = 0,
    vx1 = 0, vy1 = 0,
    vx2 = 0, vy2 = 0,
    ax1 = 0, ay1 = 0;

  var sphere = {
    schieber: document.getElementById("sphere1"),
    ball: document.getElementById("sphere2")
  };
  sphere.schieber.style.width = "50px";
  sphere.schieber.style.height = "50px";
  sphere.schieber.style.ball = "50px";
  sphere.schieber.style.ball = "50px";
  var level = {
    aktuell: 1,
    checkpoint: 0,
    mode: "normal",
    easyMaps: {
      normal: {
        3: {
          spawnPoint: {
            schieber: {
              x: 380,
              y: 150
            },
            ball: {
              x: 380,
              y: 300
            }
          }
        },
        4: {
          spawnPoint: {
            schieber: {
              x: 380,
              y: 150
            },
            ball: {
              x: 380,
              y: 300
            }
          }
        },
        5: {
          rotating: [{
          shape: "rectangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 4,
          heart: {
            onceInMiliSec: 3333
          }
        }]
        },
        7: {
          spawnPoint: {
          schieber: {
            x: 0,
            y: 333
          },
          ball: {
            x: 100,
            y: 333
          }
        }
        },
      },
      allDirections: {
        2: {
        spawnPoint: {
          schieber: {
            x: 50,
            y: 533
          },
          ball: {
            x: 150,
            y: 533
          }
        }
        },
        7: {
          rotating: [{
          shape: "rectangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 4,
          heart: {
            onceInMiliSec: 3333
          }
        }]
        },
        10: {
          rotating: [{
          shape: "triangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 13111,
          sizeRelationToOriginal: 6,
          heart: {
            onceInMiliSec: 3333
          }
        }]
        }
      },
      slide: {
        4: {
          rotating: [
          {
        shape: "triangle",
        position: {
          x: 750,
          y: 374
          },
        angle: 144,
        miliSecsPerRotation: 11111,
        sizeRelationToOriginal: 6,
        heart: {
          onceInMiliSec: 1111
        }
      }
    ],
        },
        10: {
          sizes: {
            ball: {
              width: 40,
              height: 40
            },
            schieber: {
              width: 50,
              height: 50
            }
          },
          ballTeleporter: [{
          ballSide: {
            x: 1100,
            y: 600 - 50,
            width: 200,
            height: 100
          },
          ballTeleportedSide: {
            x: 1200,
            y: 211
          },
          schieberSide: {
            x: 1000,
            y: 290 - 50,
            width: 100,
            height: 100,
          },
          checkpoint: true
        }],
        },
      11: {
        sizes: {
          ball: {
            width: 40,
            height: 40
          },
          schieber: {
            width: 50,
            height: 50
          }
    },
      },
      12: {
        heart: {
          ball: {
            min: 13,
            max: 44,
            pixelPerFunctionCall: 1,
            waitBeforeDirectionSwitchInSec: {
              min: 1.5,
              max: 0
            }
          },
        }
      },
      14: {
        deceleration: 0.05,
        heart: {
          ball: {
            min: 13,
            max: 55,
            pixelPerFunctionCall: 1.3,
            waitBeforeDirectionSwitchInSec: {
              min: 2.2,
              max: 0
            }
          },
          schieber: {
            min: 17,
            max: 55,
            pixelPerFunctionCall: 1.3,
            waitBeforeDirectionSwitchInSec: {
              min: 2.2,
              max: 1.5
            }
          }
        },
      },
      15: {
        rotating: [
          {
        shape: "rectangle",
        position: {
          x: 800,
          y: 577
        },
        angle: 144,
        miliSecsPerRotation: 13333,
        sizeRelationToOriginal: 1.6/*,
        heart: {
          onceInMiliSec: 1111
        }*/
      }
    ],
      }
      },
      magnet: {
        6: {
          rotating: [{
          shape: "rectangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 3,
          heart: {
            onceInMiliSec: 3333
          }
        }]
        },
        9: {
          rotating: [{
          shape: "triangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 4,
          heart: {
            onceInMiliSec: 3333
          }
        }]
        }
      }
    },
    normal: {
      1: {
        sizes: {
          ball: {
            width: 200,
            height:200
          },
          schieber: {
            width: 200,
            height:200
          }
        },
        spawnPoint: {
          schieber: {
            x: 300,
            y: 300
          },
          ball: {
            x: 511,
            y: 300
          }
        }
      },
      2: {
        sizes: {
          ball: {
            width: 100,
            height:100
          },
          schieber: {
            width: 150,
            height:150
          }
        },
        spawnPoint: {
          schieber: {
            x: 800,
            y: 300
          },
          ball: {
            x: 80,
            y: 350
          }
        },
        ballTeleporter: [{
          ballSide: {
            x: 50,
            y: 300,
            width: 200,
            height: 200
          },
          ballTeleportedSide: {
            x: 1133,
            y: 300
          },
          schieberSide: {
            x: 550,
            y: 300,
            width: 200,
            height: 200
          }
        }]
      },
      3: {
        sizes: {
          ball: {
            width: 50,
            height:50
          },
          schieber: {
            width: 100,
            height:100
          }
        },
        spawnPoint: {
          schieber: {
            x: 155,
            y: 200
          },
          ball: {
            x: 233,
            y: 377
          }
        }
      },
      4: {
        sizes: {
          ball: {
            width: 50,
            height:50
          },
          schieber: {
            width: 100,
            height:100
          }
        },
        spawnPoint: {
          schieber: {
            x: 155,
            y: 200
          },
          ball: {
            x: 233,
            y: 377
          }
        }
      },
      5: {
        rotating: [{
          shape: "rectangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 10000,
          sizeRelationToOriginal: 5,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      },
      6: {},
      7: {},
      8: {},
      9: {

      },
      10: {
        ballTeleporter: [{
          ballSide: {
            x: 150,
            y: 250,
            width: 100,
            height: 100
          },
          ballTeleportedSide: {
            x: 833,
            y: 377
          },
          schieberSide: {
            x: 777,
            y: 444,
            width: 50,
            height: 50
          }
        }]
      },
      11: {
        checkpointWhen_touches: "schieber"
      },
      12: {
        heart: {
          ball: {
            min: 17,
            max: 44,
            pixelPerFunctionCall: 3,
            waitBeforeDirectionSwitchInSec: {
              min: 1,
              max: 2,
              levelBegin: 0
            }
          },
          schieber: {
            min: 37,
            max: 47,
            pixelPerFunctionCall: 3,
            waitBeforeDirectionSwitchInSec: {
              min: 2,
              max: 1
            }
          }
        },
        sizes: {
          schieber: {
            width: 47,
            height: 47
          },
          ball: {
            width: 44,
            height: 44
          }
        }
      },
      13: {
        invisible: {
          timeUntilInvisible: 3,
          timeUntilVisivleAgain: 3,
          anyOtherSide: true,
          amStück: {
            unvisible: true,
            visible: true
          }
        }
      },
      14: {
        sizes: {
          ball: {
            width: 200,
            height: 55
          },
          schieber: {
            width: 44,
            height: 88
          }
        },
        spawnPoint: {
          schieber: {
            x: 155,
            y: 160
          },
          ball: {
            x: 155,
            y: 250
          }
        }
        /*
        schieber: {
          x: 155,
          y: 200
        },
        ball: {
          x: 155,
          y: 250
        }
        */
      },
      15: {
        sizes: {
          ball: {
            width: 17,
            height: 17
          },
          schieber: {
            width: 17,
            height: 17
          }
        },
        spawnPoint: {
          schieber: {
            x: 83,
            y: 143
          },
          ball: {
            x: 97,
            y: 237
          }
        }
      }
    },
    magnet: {
      // 4. normale Level übernommen
      1: {},
      2: {},
      3: {},
      4: {
        spawnPoint: {
            schieber: {
            x: 100,
            y: 400
          },
          ball: {
            x: 111,
            y: 350
          }
        },
      },
      5: {
        spawnPoint: {
          schieber: {
            x: 83,
            y: 166
          },
          ball: {
            x: 97,
            y: 277
          }
        }
      },
      6: {
        rotating: [{
          shape: "rectangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 4,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      },
      7: {},
      8: {},
      9: {
        rotating: [{
          shape: "triangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 6,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      },
      11: {},
      12: {},
      13: {},
      14: {},
      15: {
        rotating: [
        {
          shape: "rectangle",
          position: {
            x: 800,
            y: 355
          },
          angle: 144,
          miliSecsPerRotation: 2333,
          miliSecsPerRotationEasy: 3333,
          sizeRelationToOriginal: 6.4
        }
        ]
      }
    },
    allDirections: {
      1: {
        spawnPoint: {
          schieber: {
            x: 50,
            y: 333
          },
          ball: {
            x: 250,
            y: 333
          }
        },
        sizes: {
          ball: {
            width: 50,
            height: 50
          },
          schieber: {
            width: 100,
            height: 100
          }
        }
      },
      2: {
        spawnPoint: {
          schieber: {
            x: 80,
            y: 589
          },
          ball: {
            x: 150,
            y: 577
          }
        }
      },
      3: {
        spawnPoint: {
          schieber: {
            x: 222,
            y: 200
          },
          ball: {
            x: 222,
            y: 266
          }
        }
      },
      4: {
        spawnPoint: {
          schieber: {
            x: 50,
            y: 433
          },
          ball: {
            x: 150,
            y: 433
          }
        },
      },
      5: {
        spawnPoint: {
          schieber: {
            x: 80,
            y: 289
          },
          ball: {
            x: 150,
            y: 377
          }
        }
      },
      6: {
        spawnPoint: {
          schieber: {
            x: 222,
            y: 300
          },
          ball: {
            x: 222,
            y: 366
          }
        }
      },
      7: {
        rotating: [{
          shape: "rectangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 5,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      }, 
      8: {},
      9: {},
      10: {
        rotating: [{
          shape: "triangle",
          position: {
            x: 750,
            y: 374
          },
          miliSecsPerRotation: 10000,
          sizeRelationToOriginal: 6,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      },
      11: {},
      12: {
        spawnPoint: {
          schieber: {
            x: 50,
            y: 333
          },
          ball: {
            x: 100,
            y: 333
          }
        }
      },
      13: {
        spawnPoint: {
          schieber: {
            x: 30,
            y: 50
          },
          ball: {
            x: 60,
            y: 150
          }
        }
      },
      14: {
        rotating: [
          {
        shape: "rectangle",
        position: {
          x: 800,
          y: 355
        },
        angle: 144,
        miliSecsPerRotation: 11111,
        miliSecsPerRotationEasy: 17777,
        sizeRelationToOriginal: 6.4,
        heart: {
          onceInMiliSec: 1111,
          onceInMiliSecEasy: 2777
        }
      }
    ],
    },
    15: {
      spawnPoint: {
        schieber: {
          x: 300,
          y: 600
        },
        ball: {
          x: 440,
          y: 500
        }
      }
    },
    16: {
      spawnPoint: {
        schieber: {
          x: 70,
          y: 120
        },
        ball: {
          x: 100,
          y: 199
        },
        rotating: [{
          shape: "rectangle",
          position: {
            x: 500,
            y: 355
          },
          miliSecsPerRotation: 11111,
          sizeRelationToOriginal: 1,
          heart: {
            onceInMiliSec: 3333
          }
        }]
      }
    }
    },
    slide: {
      1: {
        spawnPoint: {
        schieber: {
          x: 400,
          y: 400
        },
        ball: {
          x: 400,
          y: 466
        }
      }
      },
      2: {
        spawnPoint: {
          schieber: {
            x: 400,
            y: 400
          },
          ball: {
            x: 400,
            y: 466
          }
        }
      },
      3: {
        spawnPoint: {
          schieber: {
            x: 250,
            y: 200
          },
          ball: {
            x: 250,
            y: 266
          }
      }
      },
      4: {
        rotating: [
          {
        shape: "triangle",
        position: {
          x: 750,
          y: 374
          },
        angle: 144,
        miliSecsPerRotation: 11111,
        sizeRelationToOriginal: 6,
        // heart: {
        //   onceInMiliSec: 1111
        // }
      }
    ],
      },
      5: {
        deceleration: 0.05
      },
      6: {},
      7: {},
      8: {},
      9: {},
      10: {
        ballTeleporter: [{
          ballSide: {
            x: 1200,
            y: 600 - 50,
            width: 100,
            height: 100
          },
          ballTeleportedSide: {
            x: 1200,
            y: 211
          },
          schieberSide: {
            x: 1000,
            y: 290 - 50,
            width: 100,
            height: 100,
          }
        }]
      },
      11: {
        ballTeleporter: [{
          ballSide: {
            x: 1111,
            y: 550,
            width: 100,
            height: 100
          },
          ballTeleportedSide: {
            x: 600,
            y: 250
          },
          schieberSide: {
            x: 1111 - 277,
            y: 555,
            width: 233,
            height: 100
          }
        }],
        deceleration: 0.07
      },
      12: {
        deceleration: 0.05,
        heart: {
          ball: {
            min: 13,
            max: 44,
            pixelPerFunctionCall: 0.7,
            waitBeforeDirectionSwitchInSec: {
              min: 1.82,
              max: 0
            }
          },
        }
      },
      13: {
        deceleration: 0.05,
        heart: {
          ball: {
            min: 13,
            max: 55,
            pixelPerFunctionCall: 1.7,
            waitBeforeDirectionSwitchInSec: {
              min: 2.2,
              max: 0
            }
          },
        }
      },
      14: {
        // deceleration: 0.05,
        heart: {
          schieber: {
            min: 13,
            max: 55,
            pixelPerFunctionCall: 1.7,
            waitBeforeDirectionSwitchInSec: {
              min: 3.2,
              max: 1
            }
          }
        },
        sizes: {
          ball: {
            width: 15,
            height: 15
          },
          schieber: {
            width: 53,
            height: 53
          }
        }
      },
      15: {
        rotating: [
          {
        shape: "rectangle",
        position: {
          x: 800,
          y: 577
        },
        angle: 144,
        miliSecsPerRotation: 11111,
        sizeRelationToOriginal: 1.9/*,
        heart: {
          onceInMiliSec: 1111
        }*/
      }
    ],
    sizes: {
      ball: {
        width: 15,
        height: 15
      },
      schieber: {
        width: 50,
        height: 50
      }
    },
  },
    }
  };
  level.magnet[10] = level.normal[9];
  level.slide[8] = level.normal[9];
  level.opposite = level.normal;
   // rotating examples:
//   var shapes = [
//     {
//       points: [
//         {
//           shape: "triangle",
//           position: {
//             x: 133,
//             y: 233
//           },
//           angle: 33,
//           miliSecsPerRotation: 7777,
//           heart: {
//             onceInMiliSec: 3333
//           }
//       },
//       {
//         shape: "rectangle",
//         position: {
//           x: 133,
//           y: 444
//         },
//         angle: 144,
//         miliSecsPerRotation: 9999,
//         heart: {
//           onceInMiliSec: 1111
//         }
//     },
//     {
//       shape: "thing",
//       points: [
//         {x: 0, y: 0},
//         {x: 0, y: 77},
//         {x: 100, y: 77},
//         {x: 100, y: 0}
//       ],
//       position: {
//         x: 222,
//         y: 222
//       },
//       angle: 90,
//       miliSecsPerRotation: 11111,
//       heart: {
//         onceInMiliSec: 500
//       }
//   },
//   {
//     shape: "thing",
//     points: [
//       {x: 0, y: 0},
//       {x: 177, y: 0},
//       {x: 133, y: 77}
//     ],
//     position: {
//       x: 333,
//       y: 444
//     },
//     angle: 180,
//     miliSecsPerRotation: 777,
//     heart: {
//       onceInMiliSec: 177
//     }
// }
//       ]
//     }
  // ]

  // transform points to forms:
  var point = (x, y) => ({x, y});
  var triangle = createPath(point(0,-25), point(-50,-75), point(-100,-25));
  var rectangle = createPath(point(0,-25), point(-50,-25), point(-50,-125), point(0,-125));
  var pointShapes = [];
  /*for (var i = 0; i < currentLevel.rotating.length; i++) {
    for (var i1 = 0; i1 < currentLevel.rotating[i].points.length; i1++) {
      if (currentLevel.rotating[i].points[i1].shape == "thing") {
      var points = [];
      for (var i2 = 0; i2 < currentLevel.rotating[i].points[i1].points.length; i2++) {
        points.push(point(currentLevel.rotating[i].points[i1].points[i2].x, currentLevel.rotating[i].points[i1].points[i2].y));
      }
      if (points[1] && !points[2]) pointShapes.push({path: createPath(points[0], points[1]), position: currentLevel.rotating[i].points[i1].position, angle: currentLevel.rotating[i].points[i1].angle, miliSecsPerRotation: currentLevel.rotating[i].points[i1].miliSecsPerRotation, onceInMiliSec: currentLevel.rotating[i].heart.onceInMiliSec, sizeRelationToOriginal: currentLevel.rotating[i].sizeRelationToOriginal});
      if (points[2] && !points[3]) pointShapes.push({path: createPath(points[0], points[1], points[2]), position: currentLevel.rotating[i].points[i1].position, angle: currentLevel.rotating[i].points[i1].angle, miliSecsPerRotation: currentLevel.rotating[i].points[i1].miliSecsPerRotation, onceInMiliSec: currentLevel.rotating[i].heart.onceInMiliSec, sizeRelationToOriginal: currentLevel.rotating[i].sizeRelationToOriginal});
      if (points[3] && !points[4]) pointShapes.push({path: createPath(points[0], points[1], points[2], points[3]), position: currentLevel.rotating[i].points[i1].position, angle: currentLevel.rotating[i].points[i1].angle, miliSecsPerRotation: currentLevel.rotating[i].points[i1].miliSecsPerRotation, onceInMiliSec: currentLevel.rotating[i].heart.onceInMiliSec, sizeRelationToOriginal: currentLevel.rotating[i].sizeRelationToOriginal});

    }
    }
  }*/
  for (var i = 1; i < Object.keys(level.slide).length + 1; i++) {
    if (!level.slide[i].deceleration) level.slide[i].deceleration = 0.09;
  }
  for (const mode of Object.keys(level)) {
    if (!(["aktuell", "mode", "easyMaps"].includes(mode))) {
      for (const pLevel of Object.keys(level[mode])) {
        if (!level[mode][pLevel].sizes) level[mode][pLevel].sizes = {ball: {width: 50, height: 50}, schieber: {width: 50, height: 50}};
        if (!level[mode][pLevel].checkpointWhen_touches) level[mode][pLevel].checkpointWhen_touches = "ball";
        if (!level[mode][pLevel].spawnPoint) level[mode][pLevel].spawnPoint =     {
          schieber: {
            x: 155,
            y: 200
          },
          ball: {
            x: 155,
            y: 266
          }
        }
        if (!level.easyMaps[mode]) level.easyMaps[mode] = {};
        if (!level.easyMaps[mode][pLevel]) level.easyMaps[mode][pLevel] = {};
        for (const param of Object.keys(level[mode][pLevel])) {
          if (!level.easyMaps[mode][pLevel][param]) level.easyMaps[mode][pLevel][param] = level[mode][pLevel][param];
        }
      }
    }
  }
  var alertWhenFinishedSaving = false;
var name = '';
function getDatabase() {
  if (localStorage.getItem('checkpointsTransportTheBall')) checkpoints = JSON.parse(localStorage.getItem('checkpointsTransportTheBall'));
  result = localStorage.getItem('highscoresTransportTheBall');
    if (result) highscores = JSON.parse(result);
    modeSelected("normal");
    difficultyChanged(true);
}
function checkpointSelected(value) {
  level.checkpoint = value.split(".")[0];
  if (!value.includes(".")) level.checkpoint = 0;
  restartLevel();
}
  var direction = "long";
  var Bild = new Image();
  // function scrollWindow(direction, achse, scrollXBefore, scrollYBefore) {
  //   scrolling = true;
  //   if (achse == "right") window.scroll(scrollX + direction, scrollY);
  //   else window.scroll(scrollX, scrollY + direction);
  //   var scroll = {aktuell: {x: scrollX, y: scrollY}, max: {x: 0, y: 0}};
  //   window.scroll(Bild.width, Bild.height);
  //   scroll.max.x = scrollX;
  //   scroll.max.y = scrollY;
  //   window.scroll(scroll.aktuell.x, scroll.aktuell.y);
  //   if (((achse == "right" && direction == 1 && scrollX != scroll.max.x) || (achse == "right" && direction == -1 && scrollX != 0) || (achse == "down" && direction == 1 && scrollY != scroll.max.y) || (achse == "down" && direction == -1 && scrollY != 0)) &&  ((Bild.width > window.innerWidth && achse == "right") || (Bild.height > window.screen.height && achse != "right") && ((achse == "right" && scrollX < window.innerWidth - currentLevel.sizes.schieber.width*2 + scrollXBefore) || (achse != "right" && scrollY < window.innerHeight - currentLevel.sizes.schieber.height*2 + scrollYBefore)))) {
  //     setTimeout(function () {
  //       scrollWindow(direction, achse, scrollXBefore, scrollYBefore);
  //     }, 1);
  //   }
  //   else scrolling = false;
  // }
  var sensibility = {x: 17, y: 17};
  if (window.DeviceMotionEvent != undefined || joyStick.coordinates) {
    window.ondevicemotion = function(e) {
      if (tabletPositionModeSelection.value.split(' (')[0] == "flat") ax1 = inOrAgainstDirection * event.accelerationIncludingGravity.x * sensibility.x;
      else if (tabletPositionModeSelection.value.split(' (')[0] == "almost on end") ax1 = inOrAgainstDirection * (event.accelerationIncludingGravity.z - 1) * (-sensibility.x);
      else ax1 = inOrAgainstDirection * (event.accelerationIncludingGravity.z + 1.7) * (-sensibility.x);
      if (tabletPositionModeSelection.value.split(' (')[0] != "flat") ay1 = inOrAgainstDirection * event.accelerationIncludingGravity.y * 1.88 * sensibility.y;
      else ay1 = inOrAgainstDirection * event.accelerationIncludingGravity.y * sensibility.y;
    }
    setInterval(function() {
      if (!pause) { 
      // joy-stick:
      var nextCoordinates = {x: 0, y: 0};
      if (joyStickPlay.checked && document.getElementById('gameModeSelection').value != "show Scores"/* && !pause*/) {
        if (level.aktuell != "winnerScreen" && !currentLevel.rotating) Layout();
        if (joyStick && joyStick.coordinates) {
          if (JSON.parse(document.getElementById('sensibility').value) < 12) document.getElementById('sensibility').value = 12
          if (!oppositeCheck.checked) var nextCoordinates = {x: x1 + (mausx - joyStick.coordinates.x)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11), y: y1 + (mausy - joyStick.coordinates.y)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11)};
          else var nextCoordinates = {x: x1 - (mausx - joyStick.coordinates.x)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11), y: y1 - (mausy - joyStick.coordinates.y)/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11)};
          nextCoordinates = {x: nextCoordinates.x - scrollX/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11), y: nextCoordinates.y - scrollY/Math.abs(JSON.parse(document.getElementById('sensibility').value) - 11)}
        }
      }
      if (pause) newCoordinates = {x: ball.x, y: ball.y};
      // zoom: window.parent.document.body.style.zoom = 1.5;
      // scroll when at bootom
      if (level.aktuell == "winnerScreen") sphere.schieber.style.backgroundColor = "rgba(" + Math.round(Math.random()*255) + ", " + Math.round(Math.random()*255) + ", "+ Math.round(Math.random()*255) + ",1)";
      else/* if (!scrollingByUser)*/ {
        if (currentLevel) {
          scrolling = true;
          while (scrolling) {
            var scrolledBefore = {x: scrollX, y: scrollY};
            if (!scrollingInterac.user && x1 > window.innerWidth + scrollX - currentLevel.sizes.schieber.width- window.innerWidth/5.4) {
              window.scroll(scrollX + 3, scrollY);
              registerAutoScrolling({x: 3, y: 0});
            }
            if (!scrollingInterac.user && y1 > window.innerHeight + scrollY - currentLevel.sizes.schieber.height- window.innerHeight/5.4) {
              window.scroll(scrollX, scrollY + 3);
              registerAutoScrolling({x: 0, y: 3});
            }
            if (!scrollingInterac.user && x1 - scrollX < (window.innerWidth/5.4) && scrollX > 2) {
              window.scroll(scrollX - 3, scrollY);
              registerAutoScrolling({x: -3, y: 0});
            }
            if (!scrollingInterac.user && y1 - scrollY < (window.innerHeight/5.4) && scrollY > 2) {
              window.scroll(scrollX, scrollY - 3);
              registerAutoScrolling({x: 0, y: -1});
            }
            else {
            }
            if (scrollX == scrolledBefore.x && scrollY == scrolledBefore.y) {
              scrolling = false;
              scrollingInterac.PC = false;
            }
          }
        }
      }
      // scroll all the way down when at bottom
      // if (scrollX != Bild.width - window.screen.width && !scrolling && x1 > window.innerWidth + scrollX - currentLevel.sizes.schieber.width*2) scrollWindow(1, "right", scrollX, scrollY);
      // if (scrollY != Bild.height - window.screen.height && !scrolling && y1 > window.innerHeight + scrollY - currentLevel.sizes.schieber.height*2) scrollWindow(1, "down", scrollX, scrollY);
      // if (scrollX != 0 && !scrolling && x1 - scrollX < (currentLevel.sizes.schieber.width + currentLevel.sizes.ball.width*2) && scrollX > 2) scrollWindow(-1, "right", scrollX, scrollY);
      // if (scrollY != 0 && !scrolling && y1 - scrollY < (currentLevel.sizes.schieber.height + currentLevel.sizes.ball.height*2) && scrollY > 2) scrollWindow(-1, "down", scrollX, scrollY);

      var landscapeOrientation = window.innerWidth - window.innerHeight > 1;
      if (landscapeOrientation) {
        vx1 = vx1 + ay1;
        vy1 = vy1 + ax1;
        vx2 = vx2 + ay1;
        vy2 = vy2 + ax1;
      } else {
        vy1 = vy1 - ax1;
        vx1 = vx1 + ay1;
        vy2 = vy2 - ax1;
        vx2 = vx2 + ay1;
      }
      if (landscapeOrientation && direction == "small") {
        inOrAgainstDirection *= -1;
        direction = "long";
     } if (!landscapeOrientation && direction == "long") {
       inOrAgainstDirection *= -1;
       direction = "small";
      }
      vx1 = vx1 * 0.98;
      vy1 = vy1 * 0.98;
      ball.x = JSON.parse(sphere.ball.style.left.replace("px", ""));
      ball.y = JSON.parse(sphere.ball.style.top.replace("px", ""));
      coordinatesBefore = {x1: x1, y1: y1}
      if ((!currentLevel || !currentLevel.invisible || invisible.boolean == false)/* && !pause*/) {
      if (joyStickPlay.checked && joyStick.coordinates) {
        if (nextCoordinates.x < 0) nextCoordinates.x = 0;
        if (nextCoordinates.x > textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""))) nextCoordinates.x = textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""));
        if (nextCoordinates.y < 0) nextCoordinates.y = 0;
        if (nextCoordinates.y > textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""))) nextCoordinates.y = textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""));
      }
      else nextCoordinates = {x: parseInt(x1 + vx1 / 50), y: parseInt(y1 + vy1 / 50)};
      // allDirections
      if (level.mode == "allDirections") {
      var collision = isCollide({x: /*nextCoordinates.x*/x1, y: /*nextCoordinates.y*/y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball);
      while (collision && !((nextCoordinates.y - y1) == 0 && (y1 - nextCoordinates.y) == 0 && (y1 - nextCoordinates.y) == 0 && (nextCoordinates.y - y1) == 0 && (nextCoordinates.y - y1) == 0 && (x1 - nextCoordinates.x) == 0 && (nextCoordinates.x - x1) == 0 && (nextCoordinates.x - x1) == 0 && (x1 - nextCoordinates.x) == 0)) {
        collision = isCollide({x: nextCoordinates.x, y: nextCoordinates.y, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball);
        if (collision && nextCoordinates.y < ball.y) {
          // setTimeout(function () {
            if (nextCoordinates.y > y1) ball.y += (nextCoordinates.y - y1)//3; // down
            else ball.y += (y1 - nextCoordinates.y)
          // }, 1);
        }
        if (collision && nextCoordinates.y > ball.y)  {
          // setTimeout(function () {
            if (y1 > nextCoordinates.y) ball.y -= (y1 - nextCoordinates.y)//3; // up
            else ball.y -= (nextCoordinates.y - y1)//3; // up
          // }, 1);
        }
        if (collision && nextCoordinates.x > ball.x) {
          // setTimeout(function () {
            if (x1 > nextCoordinates.x) ball.x -=  (x1 - nextCoordinates.x)//3; // left
            else ball.x -= (nextCoordinates.x - x1)
          // }, 1);
          }
        if (collision && nextCoordinates.x < ball.x) {
          // setTimeout(function () {
            if (nextCoordinates.x > x1) ball.x += (nextCoordinates.x - x1)//3;// right
            else ball.x += (x1 - nextCoordinates.x)
          // }, 1);
        }
    }
    }

      // magnet
      if (level.mode == "magnet") {
      if (nextCoordinates.y + 30 > ball.y) {
        // setTimeout(function () {
        ball.y += (nextCoordinates.y - y1) / 10 + timeDirection.down; // down
        // }, 1);
        timeDirection.down += 0.1 //1
      }
      // else if (timeDirection.over.down < 50) {
      //   timeDirection.over.down++;
      //   ball.y += (nextCoordinates.y - y1)/10; // down
      // }
      else {
        timeDirection.down = 0;
        timeDirection.over.down = 0;
      }
      if (nextCoordinates.y < ball.y + 30) {
        // setTimeout(function () {
        ball.y -= (y1 - nextCoordinates.y) / 10 + timeDirection.up; // up
        // }, 1);
        timeDirection.up += 0.1 //1
      }
      // else if (timeDirection.over.up < 50) {
      //   timeDirection.over.up++;
      //   ball.y -= (y1 - nextCoordinates.y)/10; // up
      // }
      else {
        timeDirection.up = 0;
        timeDirection.over.up = 0;
      }
      if (nextCoordinates.x < ball.x + 30) {
        // setTimeout(function () {
        ball.x -= (x1 - nextCoordinates.x) / 10 + timeDirection.left; // left
        // }, 1);
        timeDirection.left += 0.1 //1
      }
      // else if (timeDirection.over.left < 50) {
      //   timeDirection.over.left++;
      //   ball.x -=  (x1 - nextCoordinates.x)/10; // left
      // }
      else {
        timeDirection.left = 0;
        timeDirection.over.left = 0;
      }
      if (nextCoordinates.x + 30 > ball.x) {
        // setTimeout(function () {
        ball.x += (nextCoordinates.x - x1) / 10 + timeDirection.right; // right
        // }, 1);
        timeDirection.right += 0.1 //1
      }
      // else if (timeDirection.over.right < 50) {
      //   timeDirection.over.right++;
      //   ball.x += (nextCoordinates.x - x1)/10; // right
      // }
      else {
        timeDirection.right = 0;
        timeDirection.over.right = 0;
      }
    }
      if (level.mode == "slide" && isCollide({x: nextCoordinates.x, y:  nextCoordinates.y, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball)) {
        speed = {x: 0, y: 0};
        moveDirection(directionBefore, nextCoordinates, geteiltDurch != 1);
      }
      invisibleDirectionCheck(nextCoordinates);
      // normal mode
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("left")) ball.x = x1 - cssToNumber(sphere./*schieber*/ball.style.width)//-= 3;
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("right")) ball.x = x1 + cssToNumber(sphere.schieber.style.width)//+= 3;
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("up")) ball.y = y1 - cssToNumber(sphere./*schieber*/ball.style.height)//-= 3;
      if (level.mode == "normal" && isCollide({x: x1, y: y1, width: cssToNumber(sphere.schieber.style.width), height: cssToNumber(sphere.schieber.style.height)}, ball) && directionBefore.includes("down")) ball.y = y1 + cssToNumber(sphere.schieber.style.height) //+= 3;
    }
    else {
      invisibleDirectionCheck(nextCoordinates);
    }
      if (currentLevel && currentLevel.invisible) {
        invisible.directions[invisible.direction] += 25;
      if (!invisible.boolean && invisible.directions[invisible.direction]/1000 > currentLevel.invisible.timeUntilInvisible) {
        invisible.mainDirection = invisible.direction;
        for (var i = 0; i < 4; i++) {
          /*if (Object.keys(invisible.directions)[i] != invisible.direction) */invisible.directions[Object.keys(invisible.directions)[i]] = 0;
        }
        invisible.boolean = true;
      }
      var totalTime = 0;
      for (var i = 0; i < 4; i++) {
        if (Object.keys(invisible.directions)[i] != invisible.mainDirection) totalTime += invisible.directions[Object.keys(invisible.directions)[i]];
      }
      if ((((currentLevel.invisible.anyOtherSide) && totalTime/1000 > currentLevel.invisible.timeUntilVisivleAgain) || ((!currentLevel.invisible.anyOtherSide && (invisible.directions.right/1000 > currentLevel.invisible.timeUntilVisivleAgain || invisible.directions.left/1000 > currentLevel.invisible.timeUntilVisivleAgain || invisible.directions.up/1000 > currentLevel.invisible.timeUntilVisivleAgain || invisible.directions.down/1000 > currentLevel.invisible.timeUntilVisivleAgain)))) && invisible.mainDirection != undefined) {
        for (var i = 0; i < 4; i++) {
          invisible.directions[Object.keys(invisible.directions)[i]] = 0;
        }
        invisible.boolean = false;
        invisible.mainDirection = undefined;
      }
      if (invisible.boolean) sphere.ball.style.display = "none";
      else sphere.ball.style.display = "inline";
    }
      sphere.ball.style.left = ball.x + "px";
      sphere.ball.style.top = ball.y + "px";
      checkColourCollisions();
      if (joyStick && joyStick.coordinates && joyStickPlay.checked && level.aktuell != "winnerScreen") {
        canvas.fillStyle = "blue";
        canvas.beginPath();
        canvas.arc(joyStick.coordinates.x + scrollX, joyStick.coordinates.y + scrollY, 10, 0, Math.PI*2, false);
        canvas.fill();
        canvas.strokeStyle = "green";
        canvas.beginPath();
        canvas.moveTo(joyStick.coordinates.x + scrollX, joyStick.coordinates.y + scrollY);
        canvas.lineTo(mausx, mausy);
        canvas.stroke();
        canvas.closePath();
      }
    }
    }, 25);
  }
  else if (gerät == "Handy") {
    alert("Please enter this website as https (secure) to be able to use the required motion control (Chrome recommended)");
    // alert("Bitte rufen sie diese Seite als https (sicher) auf, um die benötigte Bewegungssteuerung benutzen zu können!")
    gerät = "unsaveHandyBrowser";
  }
  var scrollingInterac = {user: false, PC: false, pos: {x: -1, y: -1}}
  if (navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    var gerät = "Handy"
    console.log("Handy");
  } else {
    var gerät = "PC"
    console.log("PC");
    scrollingInterac.user = true;
    joyStickPlayP.style.display = "none";
    joyStickPlay.checked = true;
  }
  var invisible = {directions: {left: 0, right: 0, up: 0, down: 0}, boolean: false};
  var checkpoint = {schieber: {x: 0, y: 0}, ball: {x: 0, y: 0}}
  var timeDirection = {
    right: 0,
    left: 0,
    up: 0,
    down: 0,
    over: {
      right: 0,
      left: 0,
      up: 0,
      down: 0
    }
  };
  var zaehler = 0;
  var geteiltDurch = 1;
  var coordinatesBefore;
  var bounceCoordinates;
  var scrolling = false;
  function invisibleDirectionCheck(nextCoordinates) {
    var invisibleDirection = invisible.direction;
    invisible.direction = {};
    if (x1 > nextCoordinates.x) invisible.direction.left = x1 - nextCoordinates.x;// = "left";
    if (x1 < nextCoordinates.x) invisible.direction.right = nextCoordinates.x - x1;// = "right";
    if (y1 > nextCoordinates.y) invisible.direction.up = y1 - nextCoordinates.y;// = "up";
    if (y1 < nextCoordinates.y) invisible.direction.down = nextCoordinates.y - y1;// = "down";
    var highestDirection = {number: 0};
    for (var i = 0; i < Object.keys(invisible.direction).length; i++) {
      if (invisible.direction[Object.keys(invisible.direction)[i]] > highestDirection.number && Object.keys(invisible.direction)[i] != invisible.mainDirection) {highestDirection.number = invisible.direction[Object.keys(invisible.direction)[i]]; highestDirection.string = Object.keys(invisible.direction)[i];}
    }
    if (currentLevel != undefined && invisibleDirection != undefined && highestDirection.string != undefined && currentLevel.invisible && currentLevel.invisible.amStück && invisibleDirection != highestDirection.string && ((invisible.boolean == true && currentLevel.invisible.amStück.invisible == true) || (invisible.boolean == false && currentLevel.invisible.amStück.visible == true))) {
      for (var i = 0; i < 4; i++) {
        /*if (Object.keys(invisible.directions)[i] != invisible.direction) */invisible.directions[Object.keys(invisible.directions)[i]] = 0;
      }
    }
    invisible.direction = highestDirection.string;
    y1 = nextCoordinates.y;
    x1 = nextCoordinates.x;

    vx2 = vx2 * 0.98;
    vy2 = vy2 * 0.98;
    y2 = parseInt(y2 + vy2 / 30);
    x2 = parseInt(x2 + vx2 / 30);
    boundingBoxCheck();
    if (joyStickPlay.checked && joyStick.coordinates) {
      x1 = nextCoordinates.x;
      y1 = nextCoordinates.y;
      if (x1 < 0) x1 = 0;
      if (x1 > textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""))) x1 = textur.getBoundingClientRect().right + scrollX - JSON.parse(sphere1.style.height.replace("px", ""));
      if (y1 < 0) y1 = 0;
      if (y1 > textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""))) y1 = textur.getBoundingClientRect().bottom + scrollY - JSON.parse(sphere1.style.height.replace("px", ""));
    }
    if (!pause) {
    sphere.schieber.style.top = y1 + "px";
    sphere.schieber.style.left = x1 + "px";
   }
  }
  window.onscroll = function (e) {
    if (gerät == "PC" && !scrollingInterac.PC && ((scrollingInterac.pos.x != scrollX || textur.width < window.innerWidth) && (scrollingInterac.pos.y != scrollY || textur.height < window.innerHeight))) {
      scrollingInterac.user = true;
    }
    if (scrollY  < 5 && document.getElementById('gameModeSelection').value != "showScores"/*== 0 && scrollX == 0*/) scrollingInterac.user = false;
  }
  document.addEventListener('touchstart', touch);
  var speed = {x: 0, y: 0};
  var originalSpeed = 0;
  function moveDirection(pDirectionBefore, nextCoordinates, addUp) {
    if (zaehler != "newLevel") {
        if ((geteiltDurch == 1 || addUp) && pDirectionBefore) {
          if (addUp) console.log('add up');
          if (pDirectionBefore.includes( "right") || pDirectionBefore.includes( "left")) {
            speed = {x: speed.x + (nextCoordinates.x - x1), y: speed.y};
          }
          if (pDirectionBefore.includes( "up") || pDirectionBefore.includes( "down")) {
            speed = {x: speed.x, y: speed.y + (nextCoordinates.y - y1)};
          }
          originalSpeed = speed;
  }
    ball.x += speed.x;
    ball.y += speed.y;
    speed = {x: originalSpeed.x/geteiltDurch, y: originalSpeed.y/geteiltDurch};
    // zaehler++;
    sphere.ball.style.top = ball.y + "px";
    sphere.ball.style.left = ball.x + "px";
    checkColourCollisions();
    // if (zaehler < /*20*/(level.slide[level.aktuell].slideLength) || (geteiltDurch < level.slide[level.aktuell].slideStop)) {
    if ((speed.x.toString()[0] != "0" || speed.y.toString()[0] != "0")) {
      geteiltDurch += level.slide[level.aktuell].deceleration;
      setTimeout(function () {
        if (zaehler != "newLevel" && geteiltDurch != 1) moveDirection(pDirectionBefore, nextCoordinates);
      }, 10);
    }
    else {
      geteiltDurch = 1;
    }
  }
  }
  var directionBeforeScrolling = {x: 0, y: 0};
  function checkColourCollisions() {
    // scrollWithBall
    // if (directionBeforeScrolling.x > x1 && (x1 > window.innerWidth/2 - 17 && x1 < window.innerWidth/2 + 17) || (scrollX > 0)) window.scroll(scrollX - (directionBeforeScrolling.x - x1), scrollY);
    // if (directionBeforeScrolling.x < x1 && (x1 > window.innerWidth/2 - 17 && x1 < window.innerWidth/2 + 17) || (scrollX > 0)) window.scroll(scrollX +  (x1 - directionBeforeScrolling.x), scrollY);
    // if (directionBeforeScrolling.y > y1 && (y1 > window.innerHeight/2 - 17 && y1 < window.innerHeight/2 + 17) || (scrollY > 0)) window.scroll(scrollX, scrollY - (directionBeforeScrolling.y - y1));
    // if (directionBeforeScrolling.y < y1 && (y1 > window.innerHeight/2 - 17 && y1 < window.innerHeight/2 + 17) || (scrollY > 0)) window.scroll(scrollX, scrollY +  (y1 - directionBeforeScrolling.y));
    // directionBeforeScrolling = {x: x1, y: y1};
    var numbers = [
      [x1 + cssToNumber(sphere.schieber.style.width) - 7, y1 + cssToNumber(sphere.schieber.style.height) / 2],
      [x1 + cssToNumber(sphere.schieber.style.width) / 2, y1 - 8],
      [x1 + cssToNumber(sphere.schieber.style.width) / 2, y1 + cssToNumber(sphere.schieber.style.height) - 7],
      [x1 - 10, y1 + cssToNumber(sphere.schieber.style.height) / 2],

      [ball.x + cssToNumber(sphere.ball.style.width) - 7, ball.y + cssToNumber(sphere.ball.style.height) / 2],
      [ball.x + cssToNumber(sphere.ball.style.width) / 2, ball.y - 8],
      [ball.x + cssToNumber(sphere.ball.style.width) / 2, ball.y + cssToNumber(sphere.ball.style.height) - 7],
      [ball.x - 10, ball.y + cssToNumber(sphere.ball.style.height) / 2]
    ]
    for (var i = 0; i < 8; i++) {
      // canvas.fillStyle = "red";
      // canvas.fillRect(numbers[i][0] - 10, numbers[i][1] - 10, 10, 10);
      try {
        data = canvas.getImageData(numbers[i][0], numbers[i][1], 1, 1);
        red = data.data[0];
        green = data.data[1];
        blue = data.data[2];
        alpha = data.data[3];
      } catch (e) {
        console.log("Das ist ein Fehler :( )");
      }
      if (!pause && !goalReached && (/*schwarzer Rand*/(red == 0 && blue == 0 && alpha == 255 && green == 0) || /*onGreen*/ (joyStickPlay.checked && red == 34 && blue == 76 && green == 177) || /*Durchlass Schieber*/ (red == 47 && green == 54 && blue == 153 && i > 3) || /*Durchlass Ball*/ (red == 237 && green == 28 && blue == 36 && i < 4))) {
        console.log("Fail!");
        time = 0;
        if (checkpoint.length > 1) time = checkpoint[level.checkpoint].timeNeededToReach;
        zaehler = "newLevel";
        setTimeout(function () {
          zaehler = 0;
        }, 500);
        restartLevel();
      }
      if (red == 255 && blue == 0 && alpha == 255 && (green > 241) && i > 3 && level[level.mode][level.aktuell + 1] && level.aktuell != "winnerScreen") {
        console.log("goal reached (yellow)");
        goalReached = true;
          i = 8;
          sphere.ball.style.top = "0px";
          sphere.ball.style.left = "0px";
          ball.x = 0;
          ball.y = 0;
          // inOrAgainstDirection = 0;
          //restartLevel();
          setHighscores(true);
      }
      else if (!(sphere.ball.style.top == "0px" && sphere.ball.style.left == "0px") && red == 255 && blue == 0 && alpha == 255 && (green > 241) && i > 3 && level.aktuell != "winnerScreen") {
        i = 8;
        sphere.ball.style.top = "0px";
        sphere.ball.style.left = "0px";
        ball.x = 0;
        ball.y = 0;
        alert("This was the last level :( but you can check out the other modes if you haven't done that already!");
        // alert("Das war leider das letzte Level :(  Du kannst aber noch die anderen modi ausprobieren, wenn du das noch nicht getan hast.");
        setHighscores();
        zaehler = "newLevel";
        setTimeout(function () {
          zaehler = 0;
        }, 500);
      }
      var newCheckpoint = 0;
      checkpoint.forEach((pCheckpoint, i1) => {
        
        // if ((((red == 168 && green == 230 && blue == 29) || (onTeleporter().checkpoint && (onTeleporter().ball || onTeleporter().schieber))) && ((currentLevel.checkpointWhen_touches == "ball" && i > 3) || (currentLevel.checkpointWhen_touches == "schieber" && i < 4)) && ((currentLevel.checkpointWhen_touches == "schieber" && ((((((pCheckpoint.schieber.y - y1 > 100 && level.mode != "magnet") || (pCheckpoint.schieber.y - y1 > 300 && level.mode == "magnet")) || ((y1 - pCheckpoint.schieber.y > 100 && level.mode != "magnet") || (level.mode == "magnet" && y1 - pCheckpoint.schieber.y > 300))))) || (((level.mode != "magnet" && pCheckpoint.schieber.x - x1 > 100) || (level.mode == "magnet" && pCheckpoint.schieber.x - x1 > 300)) || ((level.mode == "mode" && x1 - pCheckpoint.schieber.x > 300) || ((level.mode != "magnet" && x1 - pCheckpoint.schieber.x > 100)))))) || (currentLevel.checkpointWhen_touches == "ball" && ((level.mode == "magnet" && pCheckpoint.ball.x - ball.x > 300) || (level.mode != "magnet" && pCheckpoint.ball.x - ball.x > 100)) || ((level.mode == "magnet" && ball.x - pCheckpoint.ball.x > 300) || (level.mode != "magnet" && ball.x - pCheckpoint.ball.x > 100))) ||
        // (((level.mode != "magnet" && pCheckpoint.ball.y - ball.y > 100) || (level.mode == "magnet" && pCheckpoint.ball.y - ball.y > 300)) || ((level.mode == "magnet" && ball.y - pCheckpoint.ball.y > 300) || (level.mode != "magnet" && ball.y - pCheckpoint.ball.y > 100)))))) {
      if ((((red == 168 && green == 230 && blue == 29) || (onTeleporter().checkpoint && (onTeleporter().ball || onTeleporter().schieber))) && ((currentLevel.checkpointWhen_touches == "schieber" && i < 4 && Math.abs(pCheckpoint.schieber.x - x1) > 100 && Math.abs(pCheckpoint.schieber.y - y1) > 100) || (currentLevel.checkpointWhen_touches == "ball" && i > 3 && Math.abs(pCheckpoint.ball.x - ball.x) > 100 && Math.abs(pCheckpoint.ball.y - ball.y) > 100)))) {
        newCheckpoint++;
      }
      // if ((((red == 168 && green == 230 && blue == 29) || (onTeleporter().checkpoint && (onTeleporter().ball || onTeleporter().schieber))) && ((currentLevel.checkpointWhen_touches == "ball" && i > 3) || (currentLevel.checkpointWhen_touches == "schieber" && i < 4)) && ((currentLevel.checkpointWhen_touches == "schieber" && ((((((pCheckpoint.schieber.y - y1 < 100 && level.mode != "magnet") || (pCheckpoint.schieber.y - y1 < 300 && level.mode == "magnet")) || ((y1 - pCheckpoint.schieber.y < 100 && level.mode != "magnet") || (level.mode == "magnet" && y1 - pCheckpoint.schieber.y < 300))))) || (((level.mode != "magnet" && pCheckpoint.schieber.x - x1 < 100) || (level.mode == "magnet" && pCheckpoint.schieber.x - x1 < 300)) || ((level.mode == "mode" && x1 - pCheckpoint.schieber.x < 300) || ((level.mode != "magnet" && x1 - pCheckpoint.schieber.x < 100)))))) || (currentLevel.checkpointWhen_touches == "ball" && ((level.mode == "magnet" && pCheckpoint.ball.x - ball.x < 300) || (level.mode != "magnet" && pCheckpoint.ball.x - ball.x < 100)) || ((level.mode == "magnet" && ball.x - pCheckpoint.ball.x < 300) || (level.mode != "magnet" && ball.x - pCheckpoint.ball.x < 100))) ||
      // (((level.mode != "magnet" && pCheckpoint.ball.y - ball.y < 100) || (level.mode == "magnet" && pCheckpoint.ball.y - ball.y < 300)) || ((level.mode == "magnet" && ball.y - pCheckpoint.ball.y < 300) || (level.mode != "magnet" && ball.y - pCheckpoint.ball.y < 100)))))) {
        if ((((red == 168 && green == 230 && blue == 29) || (onTeleporter().checkpoint && (onTeleporter().ball || onTeleporter().schieber))) && ((currentLevel.checkpointWhen_touches == "schieber" && i < 4 && Math.abs(pCheckpoint.schieber.x - x1) < 100 && Math.abs(pCheckpoint.schieber.y - y1) < 100) || (currentLevel.checkpointWhen_touches == "ball" && i > 3 && Math.abs(pCheckpoint.ball.x - ball.x) < 100 && Math.abs(pCheckpoint.ball.y - ball.y) < 100)))) {
        if (i1) checkpointSelection.value = i1 + '. checkpoint';
        else checkpointSelection.value = 'start';
        level.checkpoint = i1;
      }
      });
      // for (const pCheckpoint of checkpoint) {
      // }
      if (newCheckpoint == checkpoint.length) {
        console.log("checkpoint!!!");
        if (!checkpoints[level.mode]) checkpoints[level.mode] = [];
        checkpoint.push({schieber: {x: x1, y: y1, width: sphere.schieber.style.width.replace('px', ''), height: sphere.schieber.style.height.replace('px', '')}, ball: {x: ball.x, y: ball.y, width: ball.width, height: ball.height}, timeNeededToReach: time})
        level.checkpoint++;
        checkpoints[level.mode][level.aktuell] = checkpoint;
        localStorage.setItem('checkpointsTransportTheBall', JSON.stringify(checkpoints));
      }
    }
     numbers = [
      [ball.x, ball.y],
      [ball.x + ball.width, ball.y],
      [ball.x, ball.y + ball.height],
      [ball.x + ball.width, ball.y + ball.height]
    ]
    for (var i = 0; currentLevel && currentLevel.ballTeleporter && i < currentLevel.ballTeleporter.length; i++) {
      if (x1 > currentLevel.ballTeleporter[i].schieberSide.x && x1 < currentLevel.ballTeleporter[i].schieberSide.x + currentLevel.ballTeleporter[i].schieberSide.width && y1 > currentLevel.ballTeleporter[i].schieberSide.y && y1 < currentLevel.ballTeleporter[i].schieberSide.y + currentLevel.ballTeleporter[i].schieberSide.height &&
         ball.x > currentLevel.ballTeleporter[i].ballSide.x && ball.x < currentLevel.ballTeleporter[i].ballSide.x + currentLevel.ballTeleporter[i].ballSide.width && ball.y > currentLevel.ballTeleporter[i].ballSide.y && ball.y < currentLevel.ballTeleporter[i].ballSide.y + currentLevel.ballTeleporter[i].ballSide.height)
         {
           ball.x = currentLevel.ballTeleporter[i].ballTeleportedSide.x;
           ball.y = currentLevel.ballTeleporter[i].ballTeleportedSide.y;
         }
    }
    sphere.ball.style.left = ball.x + "px";
    sphere.ball.style.top = ball.y + "px";
  }
  function setHighscores(nextLevel) {
      addToHighscore(nextLevel);
  }
  function onTeleporter() {
    var onTeleporterObj = {schieber: false, ball: false, checkpoint: false}
    for (var i = 0; currentLevel && currentLevel.ballTeleporter && i < currentLevel.ballTeleporter.length; i++) {
      if (x1 > currentLevel.ballTeleporter[i].schieberSide.x && x1 < currentLevel.ballTeleporter[i].schieberSide.x + currentLevel.ballTeleporter[i].schieberSide.width && y1 > currentLevel.ballTeleporter[i].schieberSide.y && y1 < currentLevel.ballTeleporter[i].schieberSide.y + currentLevel.ballTeleporter[i].schieberSide.height) onTeleporterObj.schieber = true;
      if (ball.x > currentLevel.ballTeleporter[i].ballSide.x && ball.x < currentLevel.ballTeleporter[i].ballSide.x + currentLevel.ballTeleporter[i].ballSide.width && ball.y > currentLevel.ballTeleporter[i].ballSide.y && ball.y < currentLevel.ballTeleporter[i].ballSide.y + currentLevel.ballTeleporter[i].ballSide.height) onTeleporterObj.ball = true;
      if (currentLevel.ballTeleporter[i].checkpoint) onTeleporterObj.checkpoint = true;
    }
    return onTeleporterObj;
  }
  var goalReached = false;
  function addToHighscore(pNextLevel) {
    if (oppositeCheck.checked) level.mode += ' opposite';
    if (easyMaps.checked) level.mode += ' easy maps';
    if (joyStickPlay.checked && !level.mode.includes('joystick')) level.mode += ' (joystick)'; 
    if (!highscores[level.mode]) highscores[level.mode] = {};
    if (!highscores[level.mode][level.aktuell]) highscores[level.mode][level.aktuell] = {};
    if (!highscores[level.mode][level.aktuell] || highscores[level.mode][level.aktuell] > mins + ":" + secs + ":" + "0" + tenths) {
      if (Object.keys(highscores[level.mode][level.aktuell]).length && highscores[level.mode][level.aktuell] > mins + ":" + secs + ":" + "0" + tenths) new Audio('https://adi.nicolaiweitkemper.de/Sounds/old-victory-sound-roblox-youtubemp3free.org.mp3').play();
      highscores[level.mode][level.aktuell] = mins + ":" + secs + ":" + "0" + tenths;
    }
    goalReached = false;
      localStorage.setItem('highscoresTransportTheBall', JSON.stringify(highscores));
    level.mode = level.mode.replace(' opposite', '');
    level.mode = level.mode.replace(' easy maps', '');
    level.mode = level.mode.replace(' (joystick)', '');
    if (pNextLevel) nextLevel();
    else winnerScreen();
  }
  function removeCheckpoint() {
    if (checkpoint.length > 1 && level.checkpoint && confirm('Are you sure you want to delete the selected checkpoint (' + level.checkpoint + '.) ?')) {
      checkpoint.splice(level.checkpoint, 1);
      level.checkpoint--;
      checkpoints[level.mode][level.aktuell] = checkpoint;
      localStorage.setItem('checkpointsTransportTheBall', JSON.stringify(checkpoints));
      // sphere.ball.style.left = checkpoint[level.checkpoint].ball.x + "px";
      // sphere.ball.style.top = checkpoint[level.checkpoint].ball.y + "px";
      if (level.checkpoint) checkpointSelection.value = level.checkpoint + '. checkpoint';
      else checkpointSelection.value = level.checkpoint = "start";
      restartLevel();
   }
  }
  function boundingBoxCheck() {
    Layout();
    if (x1 < 0) {
      x1 = 0;
      vx1 = -vx1;
    }
    if (y1 < 0) {
      y1 = 0;
      vy1 = -vy1;
    }
    if (x1 > Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2) {
      x1 = Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2;
      vx1 = -vx1;
    }
    if (y1 > Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2) {
      y1 = Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2;
      vy1 = -vy1;
    }
    if (x2 < 0) {
      x2 = 0;
      vx2 = -vx2;
    }
    if (y2 < 0) {
      y2 = 0;
      vy2 = -vy2;
    }
    if (x2 > Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2) {
      x2 = Bild.width - JSON.parse(sphere.schieber.style.width.toString().split('px')[0]) / 2;
      vx2 = -vx2;
    }
    if (y2 > Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2) {
      y2 = Bild.height - JSON.parse(sphere.schieber.style.height.toString().split('px')[0]) / 2;
      vy2 = -vy2;
    }
  }

  function Layout() {
    if (level.aktuell != "winnerScreen") {
    if (easyMaps.checked) Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/transportTheBall/easy_versions/" + level.mode + "/map" + level.aktuell + ".png";
    else Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/transportTheBall/" + level.mode + "/map" + level.aktuell + ".png";
    textur.width = Bild.width;
    textur.height = Bild.height;
    canvas.drawImage(Bild, 0, 0);
    for (var i = 0; currentLevel && currentLevel.ballTeleporter && i < currentLevel.ballTeleporter.length; i++) {
      if (currentLevel.ballTeleporter[i].checkpoint) canvas.fillStyle = "rgba(168, 230, 29, 1)";
      else canvas.fillStyle = "blue";
      canvas.fillRect(currentLevel.ballTeleporter[i].ballSide.x, currentLevel.ballTeleporter[i].ballSide.y, currentLevel.ballTeleporter[i].ballSide.width, currentLevel.ballTeleporter[i].ballSide.height);
      canvas.fillRect(currentLevel.ballTeleporter[i].ballTeleportedSide.x, currentLevel.ballTeleporter[i].ballTeleportedSide.y, cssToNumber(ball.width), ball.height);
      canvas.fillStyle = "hsl(0, 100%, 32%)";
      canvas.fillRect(currentLevel.ballTeleporter[i].schieberSide.x, currentLevel.ballTeleporter[i].schieberSide.y, currentLevel.ballTeleporter[i].schieberSide.width, currentLevel.ballTeleporter[i].schieberSide.height);
      canvas.beginPath();
      canvas.moveTo(currentLevel.ballTeleporter[i].ballSide.x + currentLevel.ballTeleporter[i].ballSide.width/2, currentLevel.ballTeleporter[i].ballSide.y + currentLevel.ballTeleporter[i].ballSide.height/2);
      canvas.lineTo(currentLevel.ballTeleporter[i].ballTeleportedSide.x + cssToNumber(ball.width/2), currentLevel.ballTeleporter[i].ballTeleportedSide.y + ball.height/2);
      canvas.lineTo(currentLevel.ballTeleporter[i].schieberSide.x + currentLevel.ballTeleporter[i].schieberSide.width/2, currentLevel.ballTeleporter[i].schieberSide.y + currentLevel.ballTeleporter[i].schieberSide.height/2);
      canvas.stroke();
    }
  }
  }
  var ball = {
    x: 0,
    y: 0,
    width: 50,
    height: 50
  };

  function restartLevel(value) {
    geteiltDurch = 1;
    var valueBefore = checkpointSelection.value;
    // if (valueBefore == "" && checkpoints[level.mode] && checkpoints[level.mode][level.aktuell]) valueBefore = (checkpoints[level.mode][level.aktuell].length - 1) + ". checkpoint";
    if (valueBefore == "") valueBefore = "start";
    while (document.getElementById('checkpointSelection').options.length > 0) {
      document.getElementById('checkpointSelection').options[0] = undefined;
    }
    for (var i = 0; checkpoints[level.mode] && checkpoints[level.mode][level.aktuell] && i < checkpoints[level.mode][level.aktuell].length; i++) {
      opt = document.createElement("option");
      document.getElementById("checkpointSelection").options.add(opt);
      if (i > 0) opt.text = i + ". checkpoint";
      else opt.text = "start";
    }
    checkpointSelection.value = valueBefore;
    // TODO: why highscore checks?
    if (document.getElementById('checkpointSelection').options.length > 0/* && highscores[level.mode] && highscores[level.mode][Object.keys(level[level.mode]).length]*/) {
      checkpointSelection.style.display = 'inline';
      removeCheckpointB.style.display = 'inline';
    }
    else {
      checkpointSelection.style.display = 'none';
      removeCheckpointB.style.display = 'none';
    }
    x1 = checkpoint[level.checkpoint].schieber.x;
    y1 = checkpoint[level.checkpoint].schieber.y;
    ball.x = checkpoint[level.checkpoint].ball.x;
    ball.y = checkpoint[level.checkpoint].ball.y;
    if (checkpoint[level.checkpoint].ball.width) {
      ball.width = checkpoint[level.checkpoint].ball.width;
      ball.height = checkpoint[level.checkpoint].ball.height;
    }
    sphere.ball.style.top = ball.y + "px";
    sphere.ball.style.left = ball.x + "px";
    sphere.schieber.style.top =  checkpoint[level.checkpoint].schieber.y + "px";
    sphere.schieber.style.left =  checkpoint[level.checkpoint].schieber.x + "px";
    if (checkpoint[level.checkpoint].schieber.width) {
      sphere.schieber.style.width = checkpoint[level.checkpoint].schieber.width + "px";
      sphere.schieber.style.height = checkpoint[level.checkpoint].schieber.height + "px";
    }
    // for (var i = 0; i < Bild.width; i++) {
      // if (!scrollingInterac.user && x1 > window.innerWidth + scrollX - currentLevel.sizes.schieber.width*5) {
      //   window.scroll(scrollX + 3, scrollY);
      //   registerAutoScrolling();
      // }
      // else if (!scrollingInterac.user && y1 > window.innerHeight + scrollY - currentLevel.sizes.schieber.height*5) {
      //   window.scroll(scrollX, scrollY + 3);
      //   registerAutoScrolling();
      // }
      // else if (!scrollingInterac.user && x1 - scrollX < (currentLevel.sizes.schieber.width + currentLevel.sizes.ball.width*5) && scrollX > 2) {
      //   window.scroll(scrollX - 3, scrollY);
      //   registerAutoScrolling();
      // }
      // else if (!scrollingInterac.user && y1 - scrollY < (currentLevel.sizes.schieber.height + currentLevel.sizes.ball.height*5) && scrollY > 2) {
      //   window.scroll(scrollX, scrollY - 3);
      //   registerAutoScrolling();
      // }
      // else {
      //   scrollingInterac.PC = false;
      // }
    // }
  }
  var scrolling = false;
  function registerAutoScrolling(direction) {
    window.scroll(scrollX + direction.x, scrollY + direction.y);
    mausx += direction.x*2;
    mausy += direction.y*2;
    scrollingInterac.PC = true;
    scrollingInterac.pos = {x: scrollX, y: scrollY};
    // setTimeout(function () {
    //   scrollingInterac.PC = false;
    // }, 500);
  }
  function nextLevel() {
    if (!document.getElementById('level ' + level.aktuell).text.includes("✅")) document.getElementById('level ' + level.aktuell).text = "✅ " + document.getElementById('level ' + level.aktuell).text;
    level.aktuell++;
    zaehler = "newLevel";
    setTimeout(function () {
      zaehler = 0;
    }, 500);
    setupLevel();
    levelSelected(level.aktuell + ". level");
    // inOrAgainstDirection = 1;
  }
  var heartBeatInt
  var saveHighscores = true;
  function heartBeatFunc(firstCall) {
    if (currentLevel.heart.ball && sphere.ball.heartBeatAction != false) {
      /*sphere.*/sphere.ball.style.width = cssToNumber(sphere.ball.style.width) + currentLevel.heart.ball.pixelPerFunctionCall*/*sphere.*/ball.direction + "px";
      /*sphere.*/sphere.ball.style.height = cssToNumber(sphere.ball.style.height) + currentLevel.heart.ball.pixelPerFunctionCall*/*sphere.*/ball.direction + "px";
    }
    if (currentLevel.heart.schieber && sphere.schieber.heartBeatAction != false) {
      sphere.schieber.style.width = cssToNumber(sphere.schieber.style.width) + currentLevel.heart.schieber.pixelPerFunctionCall*sphere.schieber.direction + "px";
      sphere.schieber.style.height = cssToNumber(sphere.schieber.style.height) + currentLevel.heart.schieber.pixelPerFunctionCall*sphere.schieber.direction + "px";
    }
    if (currentLevel.heart.ball && cssToNumber(sphere.ball.style.width) > currentLevel.heart.ball.max && sphere.ball.heartBeatAction != false) {
      ball.direction = -1;
      heartBeatStop("ball", "max", firstCall);
    }
    if (currentLevel.heart.ball && cssToNumber(sphere.ball.style.width) < currentLevel.heart.ball.min && sphere.ball.heartBeatAction != false) {
      ball.direction =  1;
      heartBeatStop("ball", "min", firstCall);
    }
    // if (ball.height > currentLevel.heart.ball.max) ball.direction = -1;
    // if (ball.height < currentLevel.heart.ball.min) ball.direction =  1;
    if (currentLevel.heart.schieber && cssToNumber(sphere.schieber.style.width) > currentLevel.heart.schieber.max && sphere.schieber.heartBeatAction != false) {
      sphere.schieber.direction = -1;
      heartBeatStop("schieber", "max", firstCall);
    }
    if (currentLevel.heart.schieber && cssToNumber(sphere.schieber.style.width) < currentLevel.heart.schieber.min && sphere.schieber.heartBeatAction != false) {
      sphere.schieber.direction =  1;
      heartBeatStop("schieber", "min", firstCall);
    }
      setTimeout(function () {
        if (currentLevel.heart != undefined) heartBeatFunc();
      }, 100);
    ball.width = cssToNumber(sphere.ball.style.width);
    ball.height = cssToNumber(sphere.ball.style.height);
  }
  function heartBeatStop(component, extrempunt, firstCall) {
    if (currentLevel.heart[component].waitBeforeDirectionSwitchInSec[extrempunt]) {
      sphere[component].heartBeatAction = false;
      var time = currentLevel.heart[component].waitBeforeDirectionSwitchInSec[extrempunt]*1000;
      if (firstCall && currentLevel.heart[component].waitBeforeDirectionSwitchInSec.levelBegin != undefined) time = currentLevel.heart[component].waitBeforeDirectionSwitchInSec.levelBegin;
      setTimeout(function () {
        sphere[component].heartBeatAction = true;
      }, time);
    }
  }
  function setupLevel(direction) {
    if (oppositeCheck.checked) sensibility = {x: 1, y: 1};
    else if (saveHighscores) sensibility = {x: 17, y: 17};
    sensibility.value = sensibility.x;
    level.checkpoint = 0;
    if (!direction) checkpoint = [{schieber: {x: currentLevel.spawnPoint.schieber.x, y: currentLevel.spawnPoint.schieber.y}, ball: {x: currentLevel.spawnPoint.ball.x, y: currentLevel.spawnPoint.ball.y}}];
    restartLevel();
    ball.width = currentLevel.sizes.ball.width;
    ball.height = currentLevel.sizes.ball.height;
    sphere.schieber.style.width = currentLevel.sizes.schieber.width + "px";
    sphere.schieber.style.height = currentLevel.sizes.schieber.height + "px";
    sphere.ball.style.width = ball.width + "px";
    sphere.ball.style.height = ball.height + "px";
    if (!direction && currentLevel.heart != undefined) {sphere.schieber.direction = 1; /*sphere.*/ball.direction = 1; heartBeatFunc(true);}
    scrollingInterac.user = false;
  }
  var directionBefore = [];

  function isCollide(a, b) {
    if ((level.mode == "slide" && (!(
      ((a.y + a.height) < (b.y)) ||
      (a.y > (b.y + b.height)) ||
      ((a.x + a.width) < b.x) ||
      (a.x > (b.x + b.width))
    ) || zaehler == 0)) || level.mode != "slide") {
    if (((a.y + a.height) < (b.y)) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "down";
    // else if (((a.y + a.height) < (b.y))) directionBefore.push("down");
    // else if ((
    //     (a.y > (b.y + b.height)) ||
    //     ((a.x + a.width) < b.x) ||
    //     (a.x > (b.x + b.width))
    //   )) removeDirection("down");
    if (((a.y > (b.y + b.height))) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "up";
    // else if (((a.y > (b.y + b.height)))) directionBefore.push("up");
    // else if ((
    //     ((a.y + a.height) < (b.y)) ||
    //     ((a.x + a.width) < b.x) ||
    //     (a.x > (b.x + b.width))
    //   )) removeDirection("up");
    if ((((a.x + a.width) < b.x)) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "right";
    // else if ((((a.x + a.width) < b.x))) directionBefore.push("right");
    // else if ((
    //     ((a.y + a.height) < (b.y)) ||
    //     (a.y > (b.y + b.height)) ||
    //     (a.x > (b.x + b.width))
    //   )) removeDirection("right");
    if (((a.x > (b.x + b.width))) /* && level.mode != "allDirections"*/ ) directionBefore[0] = "left";
    // else if (((a.x > (b.x + b.width)))) directionBefore.push("left");
    // else if ((
    //     ((a.y + a.height) < (b.y)) ||
    //     (a.y > (b.y + b.height)) ||
    //     ((a.x + a.width) < b.x)
    //   )) removeDirection("left");
    // if (!(
    //     ((a.y + a.height) < (b.y)) ||
    //     (a.y > (b.y + b.height)) ||
    //     ((a.x + a.width) < b.x) ||
    //     (a.x > (b.x + b.width))
    //   )) {}
    }
    return !(
      ((a.y + a.height) < (b.y)) ||
      (a.y > (b.y + b.height)) ||
      ((a.x + a.width) < b.x) ||
      (a.x > (b.x + b.width))
    );
  }
  var inOrAgainstDirection = 1;

  function winnerScreen() {
    level.aktuell = "winnerScreen";
    Bild = new Image();
    Bild.src = "https://adi.nicolaiweitkemper.de/Bilder/Gewinnerbildschirm.jpeg";
    canvas.drawImage(Bild, 0, 0);
    setTimeout(function () {
      canvas.drawImage(Bild, 0, 0, window.innerWidth, window.innerHeight);
    }, 500);
  }
  var currentLevel = level.normal[1];
  function levelSelected(value) {
    for (const mode of Object.keys(level)) {
      if (highscores[mode] && highscores[mode][Object.keys(level[mode]).length]) document.getElementById(mode + "Selection").innerHTML = "✅" + mode;
    }
    sphere.schieber.backgroundColor = "blue";
    if (value == "winnerScreen") {
      winnerScreen();
    }
    else {
      levelSelector.value = value;
      if (levelSelector.value == "") levelSelector.value = "✅ " + value;
      value = value.replace('✅ ', '');
      level.aktuell = JSON.parse(value.toString().split('. level')[0]);
      currentLevel = level[level.mode][level.aktuell];
      if (easyMaps.checked) currentLevel = level.easyMaps[level.mode][level.aktuell];
    if (running == 0) startPause();
    else time = 0;
    setupLevel();
    if (checkpoints[level.mode] && checkpoints[level.mode][level.aktuell]) {
      checkpoint = JSON.parse(JSON.stringify(checkpoints[level.mode][level.aktuell])); 
      level.checkpoint = checkpoint.length - 1;
      if (!level.checkpoint) level.checkpoint = 0;
      else checkpointSelection.value = level.checkpoint + '. checkpoint';
      restartLevel();
      time = checkpoint[level.checkpoint].timeNeededToReach;
    }
  }
  if (currentLevel.rotating) requestAnimationFrame(renderLoop);
}
  function modeSelected(mode) {
    if (mode == "showScores") showScores(highscores);
    else {
      textur.style.display = "inline";
      levelSelector.style.display = "inline";
      sphere.schieber.style.display = "inline";
      sphere.ball.style.display = "inline";
    level.mode = mode;
    while (document.getElementById('levelSelector').options.length > 0) {
      document.getElementById('levelSelector').options[0] = undefined;
    }
    var mapsFinished = 0;
    if (highscores[mode]) mapsFinished = Object.keys(highscores[mode])?.length;//0;
    if (highscores[mode + " easy maps"] && Object.keys(highscores[mode + " easy maps"])?.length > mapsFinished) mapsFinished = Object.keys(highscores[mode + " easy maps"])?.length;
    if (highscores[mode + " easy maps (joystick)"] && Object.keys(highscores[mode + " easy maps (joystick)"])?.length > mapsFinished) mapsFinished = Object.keys(highscores[mode + " easy maps (joystick)"])?.length;
    if (highscores[mode + " (joystick))"] && Object.keys(highscores[mode + " (joystick))"])?.length > mapsFinished) mapsFinished = Object.keys(highscores[mode + " (joystick)"])?.length;
    for (var i = 0; i < Object.keys(level[mode]).length; i++) {
      opt = document.createElement("option");
      document.getElementById("levelSelector").options.add(opt);
      opt.setAttribute("id", "level " + (i + 1));
      opt.text = (i + 1) + ". level";
      if (i < mapsFinished) opt.text = "✅ " + opt.text;
    }
    if (mapsFinished == Object.keys(level[mode]).length) {
      opt = document.createElement("option");
      document.getElementById("levelSelector").options.add(opt);
      // opt.setAttribute("id", i);
      opt.text = "winnerScreen";
      levelSelected(/*"1. level"*/mapsFinished + ". level");
  }
    else levelSelected(/*"1. level"*/(mapsFinished + 1) + ". level");
    // else inOrAgainstDirection = 1;
    gameModeSelection.value = mode;
}
  }
  var highscoresDisplayedBefore = {};
  function showScores(highscores) {
    scores.style.display = "inline";
     textur.style.display = "none";
     sphere.schieber.style.display = "none";
     sphere.ball.style.display = "none";
    for (var i = 0; i < 100; i++) {
      try {
        document.getElementById("scores").deleteRow(0);
      } catch (e) {
        console.log("wanted to delete too many elements of table");
      }
    }
    highscoresDisplayedBefore = highscores;
    var cell = [ /*row.insertCell(0)*/ ];
    var player = []
    var mostLevel = 0;
    for (const mode of Object.keys(highscores)) {
      if (mostLevel < Object.keys(highscores[mode]).length) mostLevel = Object.keys(highscores[mode]).length;
        var table = document.getElementById("scores");
        var row = table.insertRow(0); // row geht nach unten (Spalt)
        cell.push(row.insertCell(0)); // cell geht nach rechts (Zeit))
        cell.push(row.insertCell(1));
        cell[cell.length - 2] = row.insertCell(1);
      for (var i1 = 1; highscores[mode] && i1 < Object.keys(highscores[mode]).length + 1; i1++) {
          if (i1 < Object.keys(highscores[mode]).length + 1) {
            cell[cell.length] = row.insertCell(i1 + 2);
            if (highscores[mode] && highscores[mode][i1]) {
              if (highscores[mode][i1]) cell[cell.length - 1].innerHTML = highscores[mode][i1];
            }

          } else {
            cell[cell.length - 1] = row.insertCell(i1 + 1);
          }
      }
      if (table) var row = table.insertRow(/*i*/table.rows.length);
  if (table) {
    var row = table.insertRow(/*i2*/0);
    cell[0] = row.insertCell(0);
    cell[0].innerHTML = "";
    cell[0] = row.insertCell(0);
    cell[0].innerHTML = mode;
  }
    }
    var row = table.insertRow(0);
    cell.push(row.insertCell(0));
    for (var i1 = 0; i1 < mostLevel + 1; i1++) {
      cell.push(row.insertCell(i1));
      if (i1 == 0) cell[cell.length - 1].innerHTML = "mode";
      else cell[cell.length - 1].innerHTML = (i1) + ". level";
    }
    cell.push(row.insertCell(1));
    cell.push(row.insertCell(2));
  }
  // function removeDirection(direction) {
  //   for (var i = 0; i < directionBefore.length; i++) {
  //     if (directionBefore[i] == direction) {
  //       directionBefore.splice(i, 1);
  //       i--;
  //     }
  //   }
  // }

  function cssToNumber(cssStyle) {
    return JSON.parse(cssStyle.toString().split('px')[0])
  }
  var time = 0;
  var running = 0;

function startPause() {
if (running == 0) {
  running = 1;
  time = 0;
  increment();
}
else {
  running = 0;
}
}
function reset() {
running = 0;
timer = 0;
}
var mins = 0;
var secs = 0;
var tenths = 0;
function increment() {
if (running == 1 && !pause) {
setTimeout(function () {
  time++;
  mins = Math.floor(time/10/60);
  secs = Math.floor(time/10);
      secs -= 60*mins;
  tenths = time % 10;
  if (mins < 10) {
    mins = "0" + mins
  }
  if (secs < 10) {
    secs = "0" + secs;
  }
  increment();
}, 100);
}
}
startPause();
// rotating shapes:
function drawPath(path, x, y, angle) {
    canvas.setTransform(1, 0, 0, 1, x, y);
    canvas.rotate(angle);
    canvas.stroke(path);
}

function drawPath_V2(path, x, y, scale, angle, strokeStyle, fillStyle) {
    canvas.setTransform(scale, 0, 0, scale, x, y);
    canvas.rotate(angle);
    fillStyle && (canvas.fillStyle = fillStyle, canvas.fill(path));
    strokeStyle && (canvas.strokeStyle = strokeStyle, canvas.stroke(path));
}
var myReq;
function renderLoop(time) {
    //canvas.clearRect(0, 0, textur.width, textur.height);
    checkColourCollisions();
    var scale = Math.sin(time / 500) * 0.2 + 1.0;
    var scale2 = Math.cos(time / 1000) * 0.4 + 1.0;
    var miliSecsPerRotation = 2222;
    var angle = 0;
    var sizeRelationToOriginal = 1.0;
    for (var i = 0; i < currentLevel.rotating.length; i++) {
      if (currentLevel.rotating[i].angle) angle = currentLevel.rotating[i].angle;
      if (currentLevel.rotating[i].miliSecsPerRotation) miliSecsPerRotation = currentLevel.rotating[i].miliSecsPerRotation;
      if (easyMaps.checked && currentLevel.rotating[i].miliSecsPerRotationEasy) miliSecsPerRotation = currentLevel.rotating[i].miliSecsPerRotationEasy;
      if (currentLevel.rotating[i].sizeRelationToOriginal) sizeRelationToOriginal = currentLevel.rotating[i].sizeRelationToOriginal;
      scale2 = Math.cos(time / 1000) * 0.4 + 1.0;
      if (currentLevel.rotating[i].heart && currentLevel.rotating[i].heart.onceInMiliSec) scale2 = Math.cos(time / currentLevel.rotating[i].heart.onceInMiliSec) * 0.4 + sizeRelationToOriginal;
      else if (easyMaps.checked && currentLevel.rotating[i].heart && currentLevel.rotating[i].heart.onceInMiliSecEasy) scale2 = Math.cos(time / currentLevel.rotating[i].heart.onceInMiliSecEasy) * 0.4 + sizeRelationToOriginal;
      else scale2 = sizeRelationToOriginal;
    if (currentLevel.rotating[i].shape && currentLevel.rotating[i].shape == "triangle") drawPath_V2(triangle, currentLevel.rotating[i].position.x, currentLevel.rotating[i].position.y, scale2, (time / (miliSecsPerRotation/2) * Math.PI) + angle, "", "black"); //360 every 2 second
    // scale path
    if (currentLevel.rotating[i].shape && currentLevel.rotating[i].shape == "rectangle") drawPath_V2(rectangle, currentLevel.rotating[i].position.x, currentLevel.rotating[i].position.y, scale2, (time / (miliSecsPerRotation/2) * Math.PI) + angle, "", "black"); //360 every 4 second
    }
    for (var i = 0; i < pointShapes.length; i++) {
      if (pointShapes[i].angle) angle = pointShapes[i].angle;
      if (pointShapes[i].miliSecsPerRotation) miliSecsPerRotation = pointShapes[i].miliSecsPerRotation;
      if (pointShapes[i].sizeRelationToOriginal) sizeRelationToOriginal = pointShapes[i].sizeRelationToOriginal;
      if (pointShapes[i].onceInMiliSec) scale2 = Math.cos(time / pointShapes[i].onceInMiliSec) * 0.4 + sizeRelationToOriginal;
      drawPath_V2(pointShapes[i].path, pointShapes[i].position.x, pointShapes[i].position.y, scale2, (time / (miliSecsPerRotation/2) * Math.PI) + angle, "", "black");
    }
    // fill scale path
    // drawPath_V2(thing  , 125, 100, scale2, time / 3000 * Math.PI, "", "black");

    canvas.setTransform(1, 0, 0, 1, 0, 0);
    if (currentLevel.rotating && level.aktuell != "winnerScreen" && !pause) myReq = requestAnimationFrame(renderLoop);
}


function createPath(...points) {
    var cx = 0; cy = 0;
    for (const p of points) {
        cx += p.x;
        cy += p.y;
    }
    cx /= points.length;
    cy /= points.length;

    const path = new Path2D;
    for (const p of points) {
        path.lineTo(p.x - cx , p.y - cy);
    }
    path.closePath();
    return path;
}

if (gerät == "PC") alert("please click to place a joy-stick!"); 
joyStick = "place";
function canvasClicked() {
  if (/*joyStick == "place" && */gerät == "PC") {
    joyStick = {coordinates : {x: mausx - scrollX, y: mausy - scrollY}};
  }
}
document.addEventListener('touchmove', touch);
document.addEventListener('touchstart', touch);
document.addEventListener('touchend', touch);
var joyStick;
function touch(ev) {
scrollingInterac.user = true;
if (joyStickPlay.checked && ev.type == "touchend" && joyStick.coordinates) {
  //textur.style.touchAction = '';
  mausx = joyStick.coordinates.x;
  mausy = joyStick.coordinates.y;
}
if (ev.touches[0] != undefined) {
    mausx = ev.touches[0]["pageX"]// + scrollX;
    mausy = ev.touches[0]["pageY"]// + scrollY;
  }
if (joyStickPlay.checked && ev.type == "touchstart" && mausy < textur.getBoundingClientRect().bottom + scrollY) {
  joyStick = {coordinates : {x: mausx, y: mausy}};
  if (!ev.touches[1]) textur.style.touchAction = 'none';
  else textur.style.touchAction = '';
}
}
function readMouseMove(e) {
  mausx = e.clientX + scrollX;
  mausy = e.clientY + scrollY;
  //  console.log(mausx + " - " + mausy);
}
document.onmousemove = readMouseMove
function cssToNumber(string) {
return JSON.parse(string.toString().split("px")[0]);
}
var pause = false;
document.onkeydown = function(event) {
  if (event.key == "p") {
    pause = !pause;
    if (pause) {
      cancelAnimationFrame(myReq);
    }
    else {
      requestAnimationFrame(renderLoop);
      increment();
    }
  }
}
getDatabase();
</script>
